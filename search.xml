<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/Hello-world/</url>
    <content><![CDATA[<p><img src="https://ipcounter.ihcr.top/?mode=2&amp;mail=(2465478971qq@gmail.com)&amp;qq=(2465478971)&amp;gh=(song-jx)&amp;lg=(plate_let)" /> 在无数久的 🐦咕咕咕 后一个博客它建成了！</p>
<p>一些有用的网站：</p>
<ul>
<li><a href="https://www.udebug.com/">uDebug</a></li>
<li><a href="https://t.me/codeforces_official">Codeforces Official</a></li>
<li><a href="http://m2.codeforces.com">Codeforces m2</a></li>
<li><a href="https://blog.csdn.net/garfielder007/article/details/51646604">LaTeX 各种命令，符号</a></li>
<li><a href="https://csacademy.com/app/graph_editor/">graph editor</a></li>
</ul>
<p>关于我：</p>
<ul>
<li>QQ: 2465478971</li>
<li>E-Mail: 2465478971qq@gmail.com</li>
<li>Codeforces ID：songjiaxing platelets</li>
<li>Atcoder ID：songjiaxing platelets</li>
<li>洛谷 ID：plate_let</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  _|_|                              _|  _|    _|  </span><br><span class="line">_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    </span><br><span class="line">_|    _|  _|_|          _|          _|  _|_|      </span><br><span class="line">_|    _|  _|          _|      _|    _|  _|  _|    </span><br><span class="line">  _|_|    _|        _|_|_|_|    _|_|    _|    _|</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>部分题解合集</title>
    <url>/problems/</url>
    <content><![CDATA[<p>懒得分开写咕咕咕。</p>
<h3 id="tc13459">TC13459</h3>
<p>“1”的限制分两种，在同一行或在同一列，但 “1” 的数量很多，不能枚举每个“1”是哪一种，设“在同一行”的边为白边，“在同一列的”的边为黑白，考虑边之间的约束关系。</p>
<p>考虑两条边 <span class="math inline">\((i,j),(i,k)\)</span>，当边 <span class="math inline">\((j,k)\)</span> 存在时说明 <span class="math inline">\((i,j)\)</span> 和 <span class="math inline">\((i,k)\)</span> 的颜色相同，反之亦然。</p>
<p>这样就可以表示出所有的约束，必要性显然，充分性是因为合法解中同色边一定构成了若干不含公共点的团，这种对于相邻两条边的约束关系就很充分了。</p>
<p>在所有的约束条件下，所有的边及其约束关系构成类似二分图的结构，联通块分两类，一类是整个连通块一定同色，另一类是一定包含两种颜色。</p>
<p>设第一类连通块有 <span class="math inline">\(x\)</span> 个，第二类连通块有 <span class="math inline">\(y\)</span> 个，枚举第一类连通块有 <span class="math inline">\(i\)</span> 个白色，即可得到答案： <span class="math display">\[
\sum_{i=0}^x\binom xi2^yn^{\underline{i+y}}n^{\underline{x-i+y}}
\]</span> 复杂度 <span class="math inline">\(O(n^3)\)</span>（DFS 求连通块）或 <span class="math inline">\(O(n^3\alpha(n^2))\)</span>（并查集求连通块）。</p>
<h3 id="tc12909">TC12909</h3>
<p>任意时刻局面的样子都是若干个连续段，我们只关心每个连续段的样子和它们在环上的相对顺序，而不关心空白的位置，因为只有知道前者的方案数，当前局面的方案数是可以算的。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示当前已经来了 <span class="math inline">\(i\)</span> 个朋友，共构成 <span class="math inline">\(j\)</span> 个连续段的方案数，转移分三种：</p>
<ul>
<li>第 <span class="math inline">\(i+1\)</span> 个朋友新开一个连续段，<span class="math inline">\(f_{i+1,j+1} \leftarrow j \cdot f_{i,j}\)</span>。</li>
<li>第 <span class="math inline">\(i+1\)</span> 个朋友加入一个连续段的开头或结尾，<span class="math inline">\(f_{i+1,j} \leftarrow 2j \cdot f_{i,j}\)</span>。</li>
<li>第 <span class="math inline">\(i+1\)</span> 个朋友将两个连续段接在了一起，<span class="math inline">\(f_{i+1,j-1} \leftarrow j \cdot f_{i,j}\)</span>。</li>
</ul>
<p>只需要保证 <span class="math inline">\(j \le G\)</span> 就行了，而不需要考虑连续段过多而导致前两种转移不合法，因为不合法了贡献系数一定为 <span class="math inline">\(0\)</span>。</p>
<p>最后是贡献系数，假设 <span class="math inline">\(K\)</span> 个人到齐后有 <span class="math inline">\(x\)</span> 个连续段，则贡献系数为 <span class="math inline">\(N\binom{N-K-1}{K-1}\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<h3 id="tc13692">TC13692</h3>
<p>搬家具的排列很像拓扑序，但又有点区别。</p>
<p>枚举 <span class="math inline">\(S_1-S_2\)</span> 路径上第一个选的点 <span class="math inline">\(u\)</span>，再对每条边定向定向，然后就转化成了一张图的拓扑序，记这个东西为 <span class="math inline">\(f_u\)</span>。当 <span class="math inline">\(u=S_1\)</span> 或 <span class="math inline">\(S_2\)</span> 时这张图就是树，否则这张图和树唯一的区别是点 <span class="math inline">\(u\)</span> 有两个父亲，但这张图的拓扑序并不好算，单次复杂度只能做到 <span class="math inline">\(O(n^2)\)</span>，无法通过。</p>
<p>注意到这题只需要求出 <span class="math inline">\(S_1-S_2\)</span> 路径上每个点 <span class="math inline">\(f\)</span> 的总和。</p>
<p>枚举 <span class="math inline">\(S_1-S_2\)</span> 路径上的一条边 <span class="math inline">\((u,v)\)</span>，然后断开 <span class="math inline">\((u,v)\)</span>，再对每条边定向定向，然后就转化成了两棵树的拓扑序，这个是可以 <span class="math inline">\(O(n)\)</span> 算的，发现算出来的正好是 <span class="math inline">\(f_u+f_v\)</span>。</p>
<p>最后把前一步骤的计算结果加起来，再加上 <span class="math inline">\(f_{S_1}+f_{S_2}\)</span> 并除以二，即是答案。</p>
<h3 id="agc017f">AGC017F</h3>
<p>容易想到用位向量来表示折线，<span class="math inline">\(0\)</span> 表示这一步向左走，<span class="math inline">\(1\)</span> 表示向右，容易得到折线的形态只有 <span class="math inline">\(2^{N-1}\)</span> 种。</p>
<p>由于相邻两条折线 <span class="math inline">\(S,T\)</span> 的约束关系是 <span class="math inline">\(T\)</span> 的每个前缀后都大于等于 <span class="math inline">\(S\)</span> 的对应前缀和。</p>
<p>不难想到轮廓线 <code>DP</code>，设 <span class="math inline">\(f_{i,j,k,S}\)</span> 表示满足以下条件的方案数：</p>
<ul>
<li>第 <span class="math inline">\(i\)</span> 条折线已经填了前 <span class="math inline">\(j\)</span> 位。</li>
<li><span class="math inline">\(S\)</span> 的前 <span class="math inline">\(j\)</span> 位是第 <span class="math inline">\(i\)</span> 条折线的，后 <span class="math inline">\(N-1-j\)</span> 位是第 <span class="math inline">\(i-1\)</span> 条折线的。</li>
<li>第 <span class="math inline">\(i-1\)</span> 条折线前 <span class="math inline">\(j\)</span> 位之和为 <span class="math inline">\(k\)</span>。</li>
</ul>
<p>转移就枚举第 <span class="math inline">\(i\)</span> 条折线第 <span class="math inline">\(j+1\)</span> 为填什么。</p>
<p>复杂度 <span class="math inline">\(O(n^32^n)\)</span>，无法通过。</p>
<p>再次考虑相邻两条折线 <span class="math inline">\(S,T\)</span> 的约束关系，发现从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 是以下过程：</p>
<ul>
<li><p>把每个 <span class="math inline">\(1\)</span> 都往前移或不动，并且不改变相对顺序。</p></li>
<li><p>最后一个 <span class="math inline">\(1\)</span> 之后的 <span class="math inline">\(0\)</span> 任意变成 <span class="math inline">\(1\)</span>。</p></li>
</ul>
<p>重新定义 <code>DP</code> 状态 <span class="math inline">\(f_{i,j,S}\)</span> 表示正在确定了第 <span class="math inline">\(i\)</span> 条折线，当前为 <span class="math inline">\(S\)</span>，已经固定了前 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(1\)</span> 的方案数。</p>
<p>转移为：</p>
<ul>
<li>如果存在第 <span class="math inline">\(j+1\)</span> 个 <span class="math inline">\(1\)</span>，就枚举它往前移多少位，不能跨过前一个 <span class="math inline">\(1\)</span>，这个枚举量平均是 <span class="math inline">\(O(1)\)</span> 的。</li>
<li>如果不存在，要么确定第 <span class="math inline">\(i\)</span> 条折线，要么枚举最后一个 <span class="math inline">\(1\)</span> 之后的一个 <span class="math inline">\(0\)</span> 把它变成 <span class="math inline">\(1\)</span>，这个枚举量平均也是 <span class="math inline">\(O(1)\)</span> 的。</li>
</ul>
<p>当确定第 <span class="math inline">\(i\)</span> 条折线后把不合法的状态置成 <span class="math inline">\(0\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(n^22^n)\)</span>。</p>
<h3 id="arc078d">ARC078D</h3>
<p>考虑从 <span class="math inline">\(1-n\)</span> 只有一条点不重复的路径的充要条件：</p>
<ul>
<li>把这条唯一路径上的边都断开后路径上的点两两不连通。</li>
</ul>
<p>假设知道这条唯一路径是 <span class="math inline">\(u_1,u_2,\cdots,u_k\)</span>（<span class="math inline">\(u_1=1,u_k=n\)</span>），要将点集划分成 <span class="math inline">\(k\)</span> 份，第 <span class="math inline">\(i\)</span> 份包含 <span class="math inline">\(u_k\)</span>，最大化每个点集内部的边权之和。</p>
<p>可以得到一个状压做法：</p>
<ul>
<li>设 <span class="math inline">\(g_S\)</span> 表示两个端点都在点集 <span class="math inline">\(S\)</span> 内部的所有边的权值之和。</li>
<li>设 <span class="math inline">\(f_S\)</span> 表示点集 <span class="math inline">\(S\)</span> 已经被考虑时，最大的保留边权之和。</li>
<li>转移为：<span class="math inline">\(f_S \leftarrow f_{S-T} + g_T({T \subseteq S})\)</span>，其中 <span class="math inline">\(T\)</span> 恰好包含一个关键点。</li>
</ul>
<p>由于并不知道这条路径，所以需要该一下 <code>DP</code> 状态：</p>
<p>设 <span class="math inline">\(f_{i,S}\)</span> 表示点集 <span class="math inline">\(S\)</span> 已经被考虑且 <span class="math inline">\(1-i\)</span> 只有一条路径时，最大的保留边权之和。</p>
<p>转移为:</p>
<ul>
<li><span class="math inline">\(f_{i,S \cup \{i\}} \leftarrow f_{j,S} + w(j,i)(j \not\in S)\)</span>。</li>
<li><span class="math inline">\(f_{i,S\cup T} \leftarrow f_{i,S}+g_{T\cup\{i\}}(S \cap T = \varnothing)\)</span>。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n3^n)\)</span>。</p>
<p>ARC068D</p>
<p>AGC004F</p>
<p>ARC097D</p>
<p>TC10265</p>
<p>TC9844</p>
<p>ARC067C</p>
<p>ARC097C</p>
<h3 id="tc10727">TC10727</h3>
<p>根据“跳跳棋”的结论，所有的三元组构成二叉森林的形态，于是问题就转化成了：</p>
<ul>
<li>在一棵无限满二叉树上，从点 <span class="math inline">\(u\)</span> 走到点 <span class="math inline">\(v\)</span> 长度恰好为 <span class="math inline">\(k\)</span> 的路径条数。</li>
</ul>
<p>直接算感觉很困难，考虑 <code>DP</code>，容易想到记录当前步数和所在点 <span class="math inline">\(x\)</span>，但 <span class="math inline">\(x\)</span> 显然是记不了的。考虑用关键信息来替代 <span class="math inline">\(x\)</span>，记录 <span class="math inline">\(\text{dis}(x,\text{lca}(x,v)),\text{dis}(v,\text{lca}(x,v))\)</span> 就够了。</p>
<p>状态 <span class="math inline">\(f_{i,j,k}\)</span> 为走了 <span class="math inline">\(i\)</span> 步，<span class="math inline">\(\text{dis}(x,\text{lca}(x,v))=j,\text{dis}(v,\text{lca}(x,v))=k\)</span> 的路径条数。</p>
<p>转移为：</p>
<ul>
<li><span class="math inline">\(f_{i+1,j+1,k} \leftarrow 2f_{i,j,k},f_{i+1,j-1,k} \leftarrow f_{i,j,k}(j&gt;0)\)</span></li>
<li><span class="math inline">\(f_{i+1,1,k} \leftarrow f_{i,0,k},f_{i+1,\max(1-k,0),\max(k-1,0)} \leftarrow f_{i,0,k}(k&gt;0)\)</span></li>
<li><span class="math inline">\(f_{i+1,0,k+1} \leftarrow f_{i,0,k}(k &lt; \text{depth}_v)\)</span></li>
</ul>
<p>TC10664</p>
<p>TC10566</p>
<p>TC10773</p>
<h3 id="tc10993">TC10993</h3>
<p>容易发现把所有的环缩成点之后这张图就变成的一棵树，把 <span class="math inline">\(0\)</span> 结点所在的环看出根。树边和环边分开考虑。</p>
<p>对于树边，显然所有人都只会向上走，最坏情况就是 <span class="math inline">\(C\)</span> 个人全在这条树边的下面，故每条树边需要 <span class="math inline">\(C\)</span> 个急救仓。</p>
<p>对于一个环，子树中的人都是先向上走到这个环上，再聚集到向上的树边的下端点，最后一起离开这个环。</p>
<p>可以看出环之间是独立的，考虑一个环怎么做。对于一个环来说，最坏的情况肯定是 <span class="math inline">\(C\)</span> 个人聚集在一个点上，然后这 <span class="math inline">\(C\)</span> 个人再分成两批，一批从左边绕到终点，另一批从右边绕到终点，要求 <span class="math inline">\(\min 左边 + \min 右边 \ge C\)</span>。</p>
<p>方法是 <code>DP</code>，设 <span class="math inline">\(f_{i,j}\)</span> 表示已经确定了从终点开始向左的 <span class="math inline">\(i\)</span> 条边，它们的 <span class="math inline">\(\min\)</span> 为 <span class="math inline">\(j\)</span> 时的最小代价。</p>
<p>转移时枚举第 <span class="math inline">\(i+1\)</span> 条边的急救仓数 <span class="math inline">\(k\)</span>：<span class="math inline">\(f_{i+1,\min(j,k)} \leftarrow f_{i,j}(j+k \ge C)\)</span>。因为 <span class="math inline">\(j\)</span> 只会变小，所以对于第 <span class="math inline">\(i+1\)</span> 条之后的边，它们的限制会更严，所以转移只需要使第 <span class="math inline">\(i+1\)</span> 条边满足限制。</p>
<p>复杂度 <span class="math inline">\(O(nC^2)\)</span>，无法通过。</p>
<p>考虑将这个转移拆开：</p>
<ul>
<li><span class="math inline">\(f_{i+1,j} \leftarrow f_{i,j}(k \ge \max(j,C-j))\)</span>，此时肯定要最小化 <span class="math inline">\(k\)</span>。</li>
<li><span class="math inline">\(f_{i+1,k} \leftarrow f_{i,j}(k \le j \le C -k)\)</span>，考虑 <span class="math inline">\(k\)</span> 从小到大时，可行的 <span class="math inline">\(j\)</span> 组成的区间在扩展，容易做到均摊 <span class="math inline">\(O(1)\)</span> 转移。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(nC)\)</span>。</p>
<p>TC10741</p>
<p>TC10854</p>
<p>TC10848</p>
<p>TC10902</p>
<p>TC10737</p>
<p>TC10758</p>
<p>TC11003</p>
<p>TC11026</p>
<p>TC11032</p>
<p>TC10748</p>
<p>TC11213</p>
<p>TC11305</p>
<p>TC12620</p>
<p>TC10758</p>
<p>TC11032</p>
<h3 id="gym102391e">Gym102391E</h3>
<p>先二分一个直径 <span class="math inline">\(D\)</span>，建出圆方树，设 <span class="math inline">\(f_u\)</span> 表示：</p>
<ul>
<li>已经确定了 <span class="math inline">\(u\)</span> 子树内的所有方点表示的环怎么断。</li>
<li>子树内直径不超过 <span class="math inline">\(D\)</span>。</li>
<li><span class="math inline">\(f_u\)</span> 为子树内到 <span class="math inline">\(u\)</span>（圆点）/ <span class="math inline">\(fa_u\)</span>（方点）的最大距离。</li>
</ul>
<p>转移分两种：</p>
<ul>
<li><p><span class="math inline">\(u\)</span> 为圆点，判断一下儿子 <span class="math inline">\(f\)</span> 最大的两个之和是否小于等于 <span class="math inline">\(D\)</span>，大于 <span class="math inline">\(D\)</span> 说明 <span class="math inline">\(D\)</span> 小了，停止 <code>DP</code>，否则继承儿子 <span class="math inline">\(f\)</span> 的最大值。</p></li>
<li><p><span class="math inline">\(u\)</span> 为方点，设 <span class="math inline">\(fa\)</span> 为 <span class="math inline">\(u\)</span> 的父亲，枚举一下断该环上的哪条边，然后算一下子树内直径，直径有两种可能情况。</p>
<ul>
<li>一个儿子 <span class="math inline">\(v\)</span> 到断边的较大环上距离 <span class="math inline">\(+f_v\)</span>。</li>
<li>两个儿子 <span class="math inline">\(v_1,v_2\)</span> 在不跨过断边时的环上距离 <span class="math inline">\(+f_{v_1}+f_{v_2}\)</span>。</li>
</ul>
<p>如果直径大于 <span class="math inline">\(D\)</span>，就说明这条边不能断，否则</p>
<p><span class="math inline">\(f_u \leftarrow \max\limits_vf_v+\)</span> <span class="math inline">\(v\)</span> 在不跨过断边时到 <span class="math inline">\(fa\)</span> 的环上距离。</p>
<p><span class="math inline">\(f_u \leftarrow\)</span> 断边到 <span class="math inline">\(fa\)</span> 的环上距离。</p>
<p>直接转移复杂度为 <span class="math inline">\(O(儿子数量^2)\)</span>，记录一些儿子前后缀信息就可以优化到线性，以前缀为例：</p>
<ul>
<li>第 <span class="math inline">\(i\)</span> 个儿子向左绕到 <span class="math inline">\(fa\)</span> 的距离。</li>
<li>前 <span class="math inline">\(i\)</span> 个儿子子树内在不跨过 <span class="math inline">\(fa\)</span> 时到第 <span class="math inline">\(i\)</span> 个儿子的最大距离。</li>
<li>前 <span class="math inline">\(i\)</span> 个儿子子树内和断边向左绕到 <span class="math inline">\(fa\)</span> 的最大距离。</li>
<li>前 <span class="math inline">\(i\)</span> 个儿子子树内的直径。</li>
</ul></li>
</ul>
<p>复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<h3 id="zoj3970">ZOJ3970</h3>
<p>考虑在操作序列中有相邻的加减操作并且加操作在前面，应用如下调整：</p>
<ul>
<li>如果两个操作区间无交，则交换操作顺序。</li>
<li>如果有交，那么相交的部分相当于什么都没做，直接去掉相交部分，变成上一种情况。</li>
</ul>
<p>经过有限步调整，操作序列变成了若干减后若干加。</p>
<p>假设已知第 <span class="math inline">\(i\)</span> 个位置需要进行 <span class="math inline">\(a_i\)</span> 次减操作，那么最小操作次数为 <span class="math inline">\(\sum_{i=2}^n\max(0,a_i-a_{i-1})\)</span>。</p>
<p>加操作同理。</p>
<p>设 <span class="math inline">\(pre_i\)</span> 表示上一个满足 <span class="math inline">\(t_j&gt;0\)</span> 的位置 <span class="math inline">\(j\)</span>。</p>
<p><span class="math inline">\(f_{i,j}\)</span> 表示考虑了前 <span class="math inline">\(i\)</span> 个位置，其中第 <span class="math inline">\(i\)</span> 个位置被 <span class="math inline">\(j\)</span> 个减操作覆盖时的最小操作次数。</p>
<p>转移为：</p>
<p><span class="math display">\[
f_{i,j}=\min_kf_{pre_i,k}+\max(0,j-k)+\max(0,t_i-s_i+j-t_{pre_i}+s_{pre_i}-k)+\max(0,\max_{pre_i&lt;x&lt;i}s_x-\max(j,k))
\]</span></p>
<p>其中最后一项表示将区间 <span class="math inline">\((pre_i,i)\)</span> 减成 <span class="math inline">\(0\)</span> 需要的额外减操作次数。</p>
<p>复杂度 <span class="math inline">\(O(nV^2)\)</span>，无法通过。</p>
<p>打表发现函数 <span class="math inline">\(f_i\)</span> 分三段，每一段都是一次函数，并且斜率递增。</p>
<p>注意到转移方程后面的每一项都是分段一次函数，因此它们的和也是分段一次函数，所以 <span class="math inline">\(\min\)</span> 只会在拐点处取到，这样就可以 <span class="math inline">\(O(1)\)</span> 算出一个 <span class="math inline">\(f_{i,j}\)</span>。</p>
<p>求函数 <span class="math inline">\(f_i\)</span> 的两个拐点？考虑分治，对于一个区间 <span class="math inline">\([l,r]\)</span>，如果 <span class="math inline">\(f_{i,l},f_{i,mid},f_{i,r}\)</span> 等差，说明 <span class="math inline">\([l,r]\)</span> 一定在同一个段，否则递归左右两半。</p>
<p>复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<h3 id="zoj3989">ZOJ3989</h3>
<p>为了方便处理，先对所有点旋转一个角度，使所有点横坐标两两不同。</p>
<p>对于一个三角剖分，考虑一个维护折线过程：</p>
<ul>
<li>初始为下凸包。</li>
<li>每次将折线上一条边换成它上方三角形的另外两条边，要保证这两条边不在折线上。</li>
<li>或者将折线上在同一三角形内的相邻两条边换成第三条边，要保证三角形在原来两条边的上方。</li>
<li>最终为上凸包。</li>
</ul>
<p>这个过程会遍历三角剖分中的所有边，容易想到把折线作为 <code>DP</code> 状态，但折线数量太大了。</p>
<p>给折线加一条限制：折线上的拐点横坐标递增。但这样可能会导致折线找不到合法的转移。</p>
<p>事实上这种情况不存在：</p>
<ul>
<li>对于二换一的转移，显然合法，所以考虑只能进行一换二的时候。</li>
<li>对于最左边的折线，假设它的横坐标区间为 <span class="math inline">\([l,r]\)</span>，进行一换二后新的拐点横坐标为 <span class="math inline">\(x\)</span>，要么 <span class="math inline">\(l &lt; x &lt; r\)</span>，这时可以直接转移，否则 <span class="math inline">\(x &gt; r\)</span>，即它上方的三角形向右偏。</li>
<li>对于最右边的折线，如果它不能直接转移，同理可以得到它上方的三角形向左偏。</li>
<li>最左边的折线上方的三角形向右偏，最右边的折线上方的三角形向左偏，故中间一定存在一条折线可以进行合法的一换二。</li>
</ul>
<p>这样的折线就可以用拐点集合来表示了，状态数为 <span class="math inline">\(2^{n-2}\)</span>，转移时不能跨过点。</p>
<p>这样就解决了最优化问题，但计数会算重。</p>
<p>定义一次转移的「横坐标」为它涉及到的两个或三个点中横坐标的最大值，所有当前能进行的转移的「横坐标」一定两两不同。</p>
<p>考虑将折线的转移序列标准化，使得转移序列与三角剖分一一对应：每次进行「横坐标」最大的合法转移。</p>
<p>另一个等价的定义是每次转移的「横坐标」单调不减。</p>
<p>设 <span class="math inline">\(f_{S,i}\)</span> 表示当前折线为 <span class="math inline">\(S\)</span>，上次转移的「横坐标」为 <span class="math inline">\(i\)</span> 时的最小代价及其方案数。</p>
<p>复杂度 <span class="math inline">\(O(n^22^n)\)</span>。</p>
<h3 id="来源不明的题">来源不明的题</h3>
<blockquote>
<p>给定一个二分图，左右各 <span class="math inline">\(n\)</span> 个点。对于左部点的一个集合 <span class="math inline">\(S\)</span>，设 <span class="math inline">\(f(S)\)</span> 表示与 <span class="math inline">\(S\)</span> 中至少一个点相邻的右部点集合。判断是否存在一个集合 <span class="math inline">\(S \ne \{1,2,\cdots,n\}\)</span>，使得 <span class="math inline">\(|f(S)| \le |S|\)</span>，输出方案。</p>
<p><span class="math inline">\(n, m \le 10^5\)</span></p>
</blockquote>
<p>Hall 定理：一个二分图存在完美匹配的充要条件是对于任意 <span class="math inline">\(S\)</span>，<span class="math inline">\(|f(S)| \ge |S|\)</span>。</p>
<p>如果不存在完美匹配，就存在 <span class="math inline">\(S\)</span> 使得 <span class="math inline">\(|f(S)| \le |S|\)</span>，考虑求出一个这样的 <span class="math inline">\(S\)</span>。</p>
<p>先求出一个最大匹配，找一个未匹配点为根建匈牙利树，树上所有的左部点就是 <span class="math inline">\(S\)</span>。</p>
<p>如果存在完美匹配，解的形式一定是一个左部点集合 <span class="math inline">\(S\)</span>，它们的匹配点集合为 <span class="math inline">\(f(S)\)</span>。</p>
<p>所以如果选了右部点 <span class="math inline">\(v\)</span>，就一定会选它的匹配点 <span class="math inline">\(\text{match}(v)\)</span>。</p>
<p>把原来的每条边 <span class="math inline">\((u,v)\)</span> 换成 <span class="math inline">\((u,\text{match}(v))\)</span> 再求出拓扑序最小的强连通分量即可。</p>
<h3 id="arc107f">ARC107F</h3>
<p>由于一个连通块的贡献带有绝对值符号，不太好处理，变成枚举符号不会影响答案。</p>
<p>现在变成如下问题：</p>
<ul>
<li>每个点有三种状态：正、负、删，代价分别为 <span class="math inline">\(-B_i,A_i,B_i\)</span>。</li>
<li>对于相邻的点 <span class="math inline">\(u,v\)</span>，如果它们的状态都不是删，就必须相同。</li>
<li>求最小代价。</li>
</ul>
<p>想到最小割模型，由于每个点有三种状态，所以把每个点 <span class="math inline">\(i\)</span> 变成两个点 <span class="math inline">\(U_i,V_i\)</span>。</p>
<p>用 <span class="math inline">\((S,U_i),(U_i,V_i),(V_i,T)\)</span> 三条边表示三种状态。</p>
<p>令它们的代价分别为 <span class="math inline">\(\infty-B_i,\infty+A_i,\infty+B_i\)</span>，那么这三条边一定恰好割掉一条。</p>
<p>对于相邻的点 <span class="math inline">\((i,j)\)</span>，有两个约束关系：</p>
<ul>
<li>不能同时割 <span class="math inline">\((S,U_i),(V_j,T)\)</span>，如果要割 <span class="math inline">\((S,U_i)\)</span>，说明 <span class="math inline">\(U_i\)</span> 能到达 <span class="math inline">\(T\)</span>，如果要割 <span class="math inline">\((V_j,T)\)</span>，说明 <span class="math inline">\(S\)</span> 能到达 <span class="math inline">\(V_j\)</span>，所以连一条 <span class="math inline">\((V_j,U_i)\)</span>，代价为 <span class="math inline">\(\infty^2\)</span> 的边。</li>
<li>不能同时割 <span class="math inline">\((S,U_j),(V_i,T)\)</span>，同理连一条 <span class="math inline">\((V_i,U_j)\)</span>，代价为 <span class="math inline">\(\infty^2\)</span> 的边。</li>
</ul>
<p>最后答案为最小割减去 <span class="math inline">\(n\infty\)</span>。</p>
<figure>
<img src="https://i.loli.net/2021/09/08/4ragjEUYIev5wot.png" alt=".png" /><figcaption aria-hidden="true">.png</figcaption>
</figure>
<h3 id="gym101471j">Gym101471J</h3>
<p>CF1307G</p>
<h3 id="cf1307f">CF1307F</h3>
<p>P3980</p>
<p>CF1368H2</p>
<h3 id="agc038e">AGC038E</h3>
<p>先考虑一个弱化版问题：<span class="math inline">\(B_i=1\)</span> 时怎么做。</p>
<p>这是一个经典问题，一般做法有两种：状压 <code>DP</code> 和 <code>min-max</code> 容斥。</p>
<p>它们的复杂度都是 <span class="math inline">\(O(n2^n)\)</span> 或 <span class="math inline">\(O(2^n)\)</span> 的，然而这题数据范围是 <span class="math inline">\(400\)</span>，说明需要用的此题的特殊性质。</p>
<p>通过 <code>min-max</code> 容斥可以得出答案为 <span class="math display">\[
\sum_{S}(-1)^{|S|}\frac{\sum_{i=1}^n A_i}{\sum_{i \in S} A_i}
\]</span> 发现分母是小于 <span class="math inline">\(400\)</span> 的非负整数！可以用背包数出每种分母的贡献 <span class="math inline">\(\sum_S(-1)^{|S|}\)</span>。</p>
<p>设 <span class="math display">\[
f_{i,j} = \sum_{S \subseteq \{1,2,\cdots,i\}}(-1)^{|S|}[\sum_{i \in S}A_i=j]
\]</span> 转移为 <span class="math inline">\(f_{i,j}=f_{i-1,j}-f_{i-1,j-A_i}\)</span>，答案为 <span class="math display">\[
(\sum_{i=1}^n A_i)\sum_{i=0}^{400}\frac{f_{n,i}}i
\]</span> 现在回到原问题，还是考虑 <code>min-max</code> 容斥，答案就是 <span class="math display">\[
\sum_{S}(-1)^{|S|}[S 中第一次有元素达到目标时的期望步数]
\]</span></p>
<p>设 <span class="math inline">\(p_i=\frac{A_i}{\sum_{j \in S}A_j}\)</span>。</p>
<p>根据期望的线性性质，期望步数可以分摊到经过每个状态上。所以后面那坨东西为： <span class="math display">\[
\begin{aligned}
&amp;\sum_{\forall i \in S,c_i&lt;B_i}[到达c状态的概率]\cdot[离开c状态的期望步数]\\
&amp;=\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{\prod_{i \in S} c_i!}\prod_{i \in S}p_i^{c_i} \cdot \frac{\sum_{i=1}^n A_i}{\sum_{i \in S} A_i}\\
&amp;=\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{\prod_{i \in S} c_i!}\prod_{i \in S}A_i^{c_i} \cdot \frac{\sum_{i=1}^n A_i}{(\sum_{i \in S} A_i)^{(\sum_{i \in S}c_i)+1}}
\end{aligned}
\]</span></p>
<p>把前面说的东西拼起来，答案为： <span class="math display">\[
\begin{aligned}
&amp;\sum_S(-1)^{|S|}\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{\prod_{i \in S} c_i!}\prod_{i \in S}A_i^{c_i} \cdot \frac{\sum_{i=1}^n A_i}{(\sum_{i \in S} A_i)^{(\sum_{i \in S}c_i)+1}}\\
&amp;=(\sum_{i=1}^n A_i)\sum_S(-1)^{|S|}\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{(\sum_{i \in S} A_i)^{(\sum_{i \in S}c_i)+1}} \cdot \prod_{i \in S}\frac{A_i^{c_i}}{c_i!}
\end{aligned}
\]</span></p>
<p>式子中比较难转移的东西就是 <span class="math inline">\(\sum_{i \in S} A_i\)</span> 和 <span class="math inline">\(\sum_{i \in S}c_i\)</span>，把它们记状态里就行了。</p>
<p>状态为 <span class="math display">\[
f_{i,j,k}=\sum_{S \subseteq \{1,2,\cdots,i\}}(-1)^{|S|}\sum_{\forall i \in S,c_i&lt;B_i}\prod_{i \in S}\frac{A_i^{c_i}}{c_i!}[\sum_{i \in S} A_i=j \land \sum_{i \in S}c_i=k]
\]</span> 转移为 <span class="math display">\[
f_{i,j,k}=f_{i-1,j,k}-\sum_{c=0}^{B_i-1}f_{i-1,j-A_i,k-c}\frac{A_i^c}{c!}
\]</span> 答案为 <span class="math display">\[
(\sum_{i=1}^n A_i)\sum_{i=0}^{400}\sum_{j=0}^{400}\frac{j!f_{n,i,j}}{i^{j+1}}
\]</span> 分析一下时间复杂度，虽然每次转移的枚举量是 <span class="math inline">\(B_i\)</span>，但由于 <span class="math inline">\(\sum_{i=1}^nB_i\)</span> 是 <span class="math inline">\(O(n)\)</span> 的，所以总复杂度是 <span class="math inline">\(O(n^3)\)</span>，空间复杂度可以用滚动数组优化到 <span class="math inline">\(O(n^2)\)</span>。</p>
<hr />
<h3 id="agc037d">AGC037D</h3>
<p>考虑第三次操作前第 <span class="math inline">\(i\)</span> 行一定由 <span class="math inline">\((i-1)m+1\)</span> 到 <span class="math inline">\(im\)</span> 构成，记 <span class="math inline">\((i-1)m+1\)</span> 到 <span class="math inline">\(im\)</span> 的颜色为 <span class="math inline">\(i\)</span>。</p>
<p>第二次操作的目标就是使颜色为 <span class="math inline">\(i\)</span> 的数在第 <span class="math inline">\(i\)</span> 行，所以第一次操作的目标就是使每一列 <span class="math inline">\(n\)</span> 种都颜色各有一个。</p>
<p>先考虑如何确定第一列的颜色，这显然是一个行与颜色的完美匹配问题。由于任意选 <span class="math inline">\(i\)</span> 行，这 <span class="math inline">\(i\)</span> 行的颜色数至少为 <span class="math inline">\(i\)</span>，根据 Hall 定理，一定存在完美匹配。每一列依次求完美匹配就可以构造出一组解。</p>
<p>然后第二三次操作就非常简单了，复杂度 <span class="math inline">\(O(n^4)\)</span>。</p>
<h3 id="agc043d">AGC043D</h3>
<p>考虑什么样的排列 <span class="math inline">\(P\)</span> 是能被造出来的。</p>
<p>考虑构造过程：每次选择一个头元素最小的序列 <span class="math inline">\(A_i\)</span>，删除 <span class="math inline">\(A_i\)</span> 开头单调递减的一段，再继续找头元素最小的序列。</p>
<p>这启发我们把同时删除的元素看成一段，分段具有如下性质：</p>
<ul>
<li>每一段是长度不超过 <span class="math inline">\(3\)</span> 的单调递减序列。</li>
<li>每一段的头元素递增。</li>
<li>长度为 <span class="math inline">\(1\)</span> 的段不少于长度为 <span class="math inline">\(2\)</span> 的段（因为每一个长度为 <span class="math inline">\(2\)</span> 的段必须要对应一个长度为 <span class="math inline">\(1\)</span> 的段来一起构成一个 <span class="math inline">\(A_i\)</span>）。</li>
</ul>
<p>同时，只要满足上面三个条件，这个 <span class="math inline">\(P\)</span> 就能被造出来的，将每个段配配对就可以得到一个生成 <span class="math inline">\(P\)</span> 的 <span class="math inline">\(A\)</span> 序列。</p>
<p>由于 <span class="math inline">\(P\)</span> 和分段内容是一一对应的，问题转化为对合法的分段内容计数。</p>
<p>枚举长度分别为 <span class="math inline">\(1,2,3\)</span> 的段数 <span class="math inline">\(cnt_1,cnt_2,cnt_3\)</span>，满足 <span class="math inline">\(cnt_1+2cnt_2+3cnt_3=3n\)</span> 和 <span class="math inline">\(cnt_1 \ge cnt_2\)</span>。</p>
<p>贡献即为 <span class="math display">\[
\binom{cnt_1+cnt_2+cnt_3}{cnt_1,cnt_2,cnt_3}\frac{(3n)!}{(cnt_1+cnt_2+cnt_3)!2^{cnt_2}3^{cnt_3}}
\]</span> 前面的组合数是划分出每一段的方案数，除以 <span class="math inline">\((cnt_1+cnt_2+cnt_3)!\)</span> 是保证每一段的头元素递增，除以 <span class="math inline">\(2^{cnt_2}3^{cnt_3}\)</span> 是保证每一段的头元素为最大值。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc049d">AGC049D</h3>
<p>考虑如何描述一个非负凸序列。</p>
<ul>
<li>枚举最小值 <span class="math inline">\(c\)</span>，以及取到最小值的第一个位置 <span class="math inline">\(i\)</span>，令 <span class="math inline">\(A=(c,c,\cdots,c)\)</span>。</li>
<li>多次选一个位置 <span class="math inline">\(j&lt;i\)</span>，将 <span class="math inline">\(A_j,A_{j-1},A_{j-2},\cdots,A_1\)</span> 分别加上 <span class="math inline">\(1,2,3,\cdots,j\)</span>。</li>
<li>多次选一个位置 <span class="math inline">\(j&gt;i\)</span>，将 <span class="math inline">\(A_j,A_{j+1},A_{j+2},\cdots,A_n\)</span> 分别加上 <span class="math inline">\(1,2,3,\cdots,n-j+1\)</span>，若 <span class="math inline">\(i&gt;1\)</span> 则 <span class="math inline">\(i-1\)</span> 必须被选到一次。</li>
</ul>
<p>第三步可以事先选 <span class="math inline">\(i-1\)</span> 一次，对总和产生 <span class="math inline">\(\frac {i(i-1)}2\)</span> 的贡献，然后第三步就和第二步一样了。</p>
<p>先枚举 <span class="math inline">\(i\)</span>，第二三步本质上就是完全背包，由于体积的特性，有用的物品数量是 <span class="math inline">\(O(\sqrt m)\)</span> 的，可以 <span class="math inline">\(O(m\sqrt m)\)</span> 预处理出背包数组，然后 <span class="math inline">\(O(\frac mn)\)</span> 枚举 <span class="math inline">\(c\)</span>，计算贡献。</p>
<p>这样做的复杂度为 <span class="math inline">\(O(nm\sqrt m)\)</span>，无法通过。</p>
<p>考虑 <span class="math inline">\(i \rightarrow i+1\)</span> 时，物品最多删一个，也最多添一个，并且总改变次数是 <span class="math inline">\(O(\sqrt m)\)</span> 的，动态维护背包即可做到 <span class="math inline">\(O(m\sqrt m)\)</span> 的复杂度。</p>
<h3 id="agc050d">AGC050D</h3>
<p>设 <span class="math inline">\(f_{i,a,b,j}\)</span> 表示从以下局面出发，还没有赢的人中从左到右第 <span class="math inline">\(j\)</span> 个人最终赢的概率。</p>
<ul>
<li>有 <span class="math inline">\(a\)</span> 个人还没有赢且已经排除了 <span class="math inline">\(i\)</span> 个错误选项。</li>
<li>有 <span class="math inline">\(b\)</span> 个人还没有赢且已经排除了 <span class="math inline">\(i+1\)</span> 个错误选项。</li>
</ul>
<p>转移就枚举这 <span class="math inline">\(a\)</span> 个人中下一个人是赢还是输即可（这里 <span class="math inline">\(f_{i,0,b,j}=f_{i+1,b,0,j}\)</span>）。</p>
<ul>
<li><span class="math inline">\(f_{i,a,b,j}=win \cdot f_{i,a-1,b,j-[j&gt;b]} + lost \cdot f_{i,a-1,b+1,j}(j\ne b+1)\)</span></li>
<li><span class="math inline">\(f_{i,a,b,b+1}=win + lost \cdot f_{i,a-1,b+1,b+1}(j\le b)\)</span></li>
</ul>
<p>复杂度 <span class="math inline">\(O(n^4)\)</span>。</p>
<h3 id="noi2021day1t1">NOI2021Day1T1</h3>
<p>如果把修改操作看成把路径上的点染成一种新的颜色，那么重边就是两端同色的边，轻边就是两端异色的边。</p>
<p>所以询问操作就是查询路径上两端同色的边数，这个可以用树链剖分和线段树维护。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="noi2021day1t2">NOI2021Day1T2</h3>
<p>当 <span class="math inline">\(k=2\)</span> 时，交点就是逆序对，自然联想到行列式，发现答案就是行列式。</p>
<p>当 <span class="math inline">\(n_1=n_2=\cdots=n_k\)</span> 时，答案就是把每相邻两层邻接矩阵的行列式乘起来。</p>
<p>对于原问题，答案就是相邻两层邻接矩阵乘积的行列式。</p>
<p>证明：</p>
<ul>
<li><p>对于一个合法的路径组，考虑两条路径 <span class="math inline">\((P_1,P_2,\cdots,P_k)\)</span> 和 <span class="math inline">\((Q_1,Q_2,\cdots,Q_k)\)</span>，两条路径有奇数个交点 <span class="math inline">\(\iff\)</span> <span class="math inline">\((P_1,Q_1)\)</span> 和 <span class="math inline">\((P_k,Q_k)\)</span> 逆序。</p></li>
<li><p>对于一个不合法的路径组，考虑对其进行以下变换：</p>
<ul>
<li>找到最靠上的一个点被覆盖多次，多个在同一层时取最靠左的一个。</li>
<li>找到经过此点的编号最小两条路径，将它们的下一半交换。</li>
</ul>
<p>这样的变换是相互的，并且会使每条路径头尾形成的逆序对总数的奇偶性改变，故不合法的路径组的贡献会两两抵消。</p></li>
</ul>
<p>复杂度 <span class="math inline">\(O(n^4)\)</span>。</p>
<h3 id="noi2021day1t3">NOI2021Day1T3</h3>
<p>容易发现对于一次询问，答案为 <span class="math inline">\(s\)</span> 能到达且能到达 <span class="math inline">\(t\)</span> 的点数。</p>
<p>由于研究的是可达性，先进行强连通分量缩点。</p>
<p>再考虑限制：若 <span class="math inline">\(x\Rightarrow z\)</span> 且 <span class="math inline">\(y\Rightarrow z\)</span>，则 <span class="math inline">\(x\Rightarrow y\)</span> 或 <span class="math inline">\(y\Rightarrow x\)</span>。这说明能到达 <span class="math inline">\(z\)</span> 的点在一条链上，进一步，整张图是一棵树加上若干条从祖先到儿子的边。</p>
<p>如何求出这棵树？一个点的父亲就是所有连向它的点中拓扑序最大的一个，注意所完点后编号就是拓扑序的逆序。</p>
<p>对于加边操作，对 <span class="math inline">\(s,t\)</span> 以及所有边的端点建虚树，统计一下虚树上的点和边的贡献即可。</p>
<p>由于此题卡常，树剖求 <code>LCA</code> 效果最佳，用邻接链表存虚树，不能用 <code>vector</code>。</p>
<p>复杂度 <span class="math inline">\(O(n+q\log n)\)</span>。</p>
<h3 id="noi2021day2t1">NOI2021Day2T1</h3>
<p><span class="math inline">\(k \le 15\)</span> 是此题的突破点，这意味着把 <span class="math inline">\(256\)</span> 平均分成 <span class="math inline">\(16\)</span> 段后必然有一段是完全相同的。</p>
<p>枚举完全相同的是哪一段，确定了 <span class="math inline">\(16\)</span> 位后，期望只有 <span class="math inline">\(7\)</span> 个符合条件的串，对它们用 <code>popcount</code> 检验即可。</p>
<h3 id="noi2021day2t2">NOI2021Day2T2</h3>
<p><del>结论题。</del></p>
<p>假设已知 <span class="math inline">\(a\)</span> 序列，怎么算答案。</p>
<p>维护最后一项 <span class="math inline">\(a_n\)</span>​ 的分子分母 <span class="math inline">\(x,y\)</span>​，一次变换后 <span class="math inline">\(\frac {x&#39;}{y&#39;}=a_{n-1}+\frac 1{a_n}=\frac {a_{k-1}x+y}x\)</span>​。发现不会发生约分，并且相当于对 <span class="math inline">\((x,y)\)</span>​​ 做了一个线性变换： <span class="math display">\[
\begin{bmatrix}
x&#39;\\
y&#39;
\end{bmatrix}
=
\begin{bmatrix}
a_{n-1}&amp;1\\
1&amp;0
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix}
\]</span> 算出 <span class="math display">\[
\begin{bmatrix}
a&amp;c\\
b&amp;d
\end{bmatrix}
=
\prod_{i=1}^n
\begin{bmatrix}
a_i&amp;1\\
1&amp;0
\end{bmatrix}
\]</span> 答案即为 <span class="math inline">\(\frac ab\)</span>。</p>
<p>然后考虑两种操作：</p>
<ul>
<li><p><code>W</code> 类型：因为 <span class="math inline">\(\begin{bmatrix}x&amp;1\\1&amp;0\end{bmatrix}\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}=\begin{bmatrix}x+1&amp;1\\1&amp;0\end{bmatrix}\)</span>​，所以 'W' 操作就是在后面乘一个 <span class="math inline">\(\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}\)</span>。</p></li>
<li><p><code>E</code> 类型：虽然定义中如果最后一项为 <span class="math inline">\(1\)</span> 时要特别处理，但发现当最后一项为 <span class="math inline">\(1\)</span> 时两种处理方式的结果是一样的。</p>
<p>给倒数第二项加 <span class="math inline">\(1\)</span> 的影响： <span class="math display">\[
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}
\rightarrow
\begin{bmatrix}
1&amp;0\\
1&amp;1
\end{bmatrix}
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}
=
\begin{bmatrix}
1&amp;1\\
2&amp;1
\end{bmatrix}
\]</span> 给数列的<strong>最后一项</strong>减 <span class="math inline">\(1\)</span>，接着在数列尾再加两项，两项的值都是 <span class="math inline">\(1\)</span> 的影响： <span class="math display">\[
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}
\rightarrow
\begin{bmatrix}
0&amp;1\\
1&amp;0
\end{bmatrix}
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}^2
=
\begin{bmatrix}
1&amp;1\\
2&amp;1
\end{bmatrix}
\]</span> 所以把 <code>E</code> 操作按第二种处理方式就行了，给数列的最后一项减 <span class="math inline">\(1\)</span>​ 相当于乘 <span class="math inline">\(\begin{bmatrix}1&amp;0\\-1&amp;1\end{bmatrix}\)</span>。</p>
<p>于是 <code>E</code> 操作相当于乘 <span class="math inline">\(\begin{bmatrix}1&amp;0\\-1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^2=\begin{bmatrix}2&amp;1\\-1&amp;0\end{bmatrix}\)</span>。</p></li>
</ul>
<p>此时这题就很容易了，<code>APPEND</code>，<code>FLIP</code> 和 <code>REVERSE</code> 都是可以平衡树维护的，每个结点不仅要维护区间矩阵乘积，还要维护倒着乘的结果，<code>FLIP</code> 后的结果，和 <code>FLIP</code> 后倒着乘的结果。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="noi2021day2t3">NOI2021Day2T3</h3>
<p>发现每个机器人对纸带的修改本质上只有 <span class="math inline">\(4\)</span> 种：赋值为 <span class="math inline">\(0\)</span>，赋值为 <span class="math inline">\(1\)</span>，不变，取反，分别用 <span class="math inline">\(0,1,2,3\)</span> 表示。</p>
<p>不难想到容斥原理：枚举一个起始位置集合 <span class="math inline">\(mask\)</span>，计算有多少种输入使得机器人从这些位置出发的输出都一样。每条纸带上每个位置受到的修改是确定且独立的，讨论一下一个位置的可行输入，乘起来就是贡献：</p>
<ul>
<li>如果一个位置同时包含 <span class="math inline">\(0,1\)</span> 或 <span class="math inline">\(2,3\)</span>，那么输入只能为空，方案数为 <span class="math inline">\(1\)</span>。</li>
<li>否则，如果一个位置包含两种操作，那么输入可以为空或 <span class="math inline">\(01\)</span> 中的一种，方案数为 <span class="math inline">\(2\)</span>。</li>
<li>否则，三种输入都可行，方案数为 <span class="math inline">\(3\)</span>。</li>
</ul>
<p>至此，得到一个 <span class="math inline">\(O(2^nmn^2)\)</span> 的做法。</p>
<p>考虑优化计算一个机器人对一个起始位置集合的贡献，记状压数组 <span class="math inline">\(g_{0/1/2/3,S}\)</span> 表示选择起始位置集合 <span class="math inline">\(S\)</span> 时包含 <span class="math inline">\(0/1/2/3\)</span> 的位置，<span class="math inline">\(g\)</span> 可以 <span class="math inline">\(O(2^n)\)</span> 求出，有了 <span class="math inline">\(g\)</span> 也可以 <span class="math inline">\(O(1)\)</span>​ 算贡献。</p>
<p>复杂度 <span class="math inline">\(O(2^nm)\)</span>。</p>
<p>题目限制 <span class="math inline">\(n \le 32\)</span>，猜想是分大小两类计算来平衡复杂度。进一步观察发现当 <span class="math inline">\(mask\)</span> 的最高位大于等于 <span class="math inline">\(\lceil\frac n2\rceil\)</span> 时，修改范围大于 <span class="math inline">\(\lceil\frac n2\rceil\)</span> 的机器人都会爆掉。</p>
<p>枚举 <span class="math inline">\(mask\)</span> 的最高位 <span class="math inline">\(\max\)</span>，这样就确定了哪些机器人会爆掉（不用考虑），分两种情况：</p>
<ul>
<li><p><span class="math inline">\(\max \le \lceil\frac n2\rceil\)</span>，这个可以暴力容斥，复杂度 <span class="math inline">\(O(2^{\frac n2}m)\)</span>。</p></li>
<li><p><span class="math inline">\(\max &gt; \lceil\frac n2\rceil\)</span>，这意味着需要考虑的机器人修改范围都不超过 <span class="math inline">\(n-\max+1\)</span>。</p>
<p>一个修改范围大小为 <span class="math inline">\(R\)</span>​ 的机器人所在的纸带上，一个位置的状态只和两个因素有关：</p>
<ul>
<li><p>它前面 <span class="math inline">\(R\)</span> 个位置哪些在 <span class="math inline">\(mask\)</span> 中。</p></li>
<li><p>它是否没有被某个区间覆盖。</p></li>
</ul>
<p>如果所有区间都覆盖了某个位置，说明 <span class="math inline">\(mask\)</span>​ 的最低位大于等于 <span class="math inline">\(2\max-n+1\)</span>​，可以暴力容斥，复杂度 <span class="math inline">\(O(2^{n-\max+1}m)\)</span>​。 否则只需要考虑第一条，可以 <code>DP</code>，设 <span class="math inline">\(f_{i,S}\)</span>​ 表示已经确定了 <span class="math inline">\(mask\)</span>​ 的前 <span class="math inline">\(i\)</span>​ 位，其中最后 <span class="math inline">\(n-\max+1\)</span>​ 位为 <span class="math inline">\(S\)</span>​，转移直接枚举第 <span class="math inline">\(i+1\)</span>​ 位选不选即可，可以 <span class="math inline">\(O(2^{n-\max+1}m)\)</span>​ 预处理转移系数，复杂度 <span class="math inline">\(O(2^{n-\max+1}n)\)</span>​。</p></li>
</ul>
<p>总复杂度 <span class="math inline">\(O(2^{n/2}m)\)</span>​。</p>
<h3 id="cf1548d2">CF1548D2</h3>
<p>根据 Pick 定理： <span class="math display">\[
S=i+\frac b2-1
\]</span> 合法三角形的条件即为 <span class="math inline">\(S\in \mathbb Z \land2S\equiv b \pmod 4\)</span>​。</p>
<p>对于三角形 <span class="math inline">\(ABC\)</span>​， <span class="math inline">\(2S=|\overrightarrow A\times \overrightarrow B+\overrightarrow B\times \overrightarrow C+\overrightarrow C\times \overrightarrow A|\)</span>​​​，由于 <span class="math inline">\(S\)</span> 是整数，所以绝对值不会影响 <span class="math inline">\(S\)</span> 的奇偶性，只需要各个顶点的坐标模 <span class="math inline">\(4\)</span> 的结果就可以知道 <span class="math inline">\(2S \bmod 4\)</span>​。</p>
<p>一条线段 <span class="math inline">\(AB\)</span>​​​ 的 <strong>边界数</strong> 为线段上整点数减一，<span class="math inline">\(b\)</span>​​ 就是三条线段的边界数之和。线段 <span class="math inline">\(AB\)</span>​​ 的边界数 <span class="math inline">\(\text{bounds}(A,B)=\gcd(|X_A-X_B|,|Y_A-Y_B|)\)</span>​​​​，不太好简单表示。</p>
<p>由于要求 <span class="math inline">\(S\)</span> 为整数，所以 <span class="math inline">\(b\)</span> 为偶数，这是一个很重要的条件，这意味着合法三角形三条边的边界数中至少有一条是偶数，另外两个奇偶性相同，判断 <span class="math inline">\(\text{bounds}(A,B) \bmod 4\)</span> 是 <span class="math inline">\(0\)</span> 还是 <span class="math inline">\(2\)</span> 要容易得多， <span class="math display">\[
\text{bounds}(A,B) \equiv 0\pmod 4 \iff X_A\equiv X_B\pmod 4 \land Y_A\equiv Y_B\pmod 4
\]</span> 在 <span class="math inline">\(\text{bounds}(A,B) \not\equiv 0\pmod 4\)</span> 的前提下 <span class="math display">\[
\text{bounds}(A,B) \equiv 2\pmod 4 \iff X_A\equiv X_B\pmod 2 \land Y_A\equiv Y_B\pmod 2
\]</span> 判断这两个条件只需要各个顶点的坐标模 <span class="math inline">\(4\)</span> 的结果。</p>
<p>此时做法就清晰起来了，合法三角形按三条边的边界数奇偶性可以分成 EEE 和 EOO 两类，设 <span class="math inline">\(cnt_{A,x,y,z}\)</span> 表示有多少个点 <span class="math inline">\(B\)</span>​​ 满足 <span class="math display">\[
X_B\equiv x\pmod 4 \land Y_B\equiv y\pmod 4 \land \text{bounds}(A,B) \equiv z\pmod 4
\]</span> 这个是可以 <span class="math inline">\(O(n^2\log V)\)</span> 预处理的。</p>
<p>考虑分别对两类合法三角形 <span class="math inline">\(ABC\)</span>​​​ 计数，先枚举点 <span class="math inline">\(A\)</span>​，再枚举 <span class="math display">\[
X_B\bmod 4,Y_B\bmod 4,\text{bounds}(A,B)\bmod 4\\X_C\bmod 4,Y_C\bmod 4,\text{bounds}(A,C)\bmod 4
\]</span> 满足 <span class="math display">\[
S \in \mathbb Z\\
\text{bounds}(A,B)\equiv\text{bounds}(A,C)\pmod 2\\
X_B\equiv X_C \pmod 2\\
Y_B\equiv Y_C\pmod 2\\
S\equiv \text{bounds}(A,B)+\text{bounds}(A,C)+\text{bounds}(B,C)\pmod 4
\]</span> 使用 <span class="math inline">\(cnt\)</span> 数组可以 <span class="math inline">\(O(1)\)</span>​​ 计算贡献。</p>
<p>这样每个 EEE 三角形会被算 <span class="math inline">\(3\)</span> 遍，每个 EOO 三角形会被算 <span class="math inline">\(1\)</span> 遍。</p>
<p>复杂度 <span class="math inline">\(O(n^2\log V)\)</span>。</p>
<h3 id="cf1548e">CF1548E</h3>
<p><del>最简单的 3400。</del></p>
<p>把坏格子填成 <span class="math inline">\(1\)</span>，其他填成 <span class="math inline">\(0\)</span>，问题就是求矩阵中有多少个“1”的四-连通块。</p>
<blockquote>
<p>引理：对于任意两行 <span class="math inline">\(i,j\)</span>​​​，“1” 所在列的集合一定是相互包含的。</p>
</blockquote>
<p>不妨假设 <span class="math inline">\(a_i \ge a_j\)</span>​​，<span class="math inline">\(a_i+b_k \le x \Rightarrow a_j+b_k \le x\)</span>​。</p>
<p>同时，此引理也就是这个矩阵的全部性质了，因为任何一个符合引理的矩阵都是可以构造出 <span class="math inline">\(a,b\)</span> 数组的。此题唯一的条件也就是这个引理了，目标很明确。</p>
<p>我们数连通块的思路是这样的：</p>
<ul>
<li>对于一个连通块 <span class="math inline">\(S\)</span>​​​​​​，它上到 <span class="math inline">\(L_r\)</span>​​​​​​，下到 <span class="math inline">\(R_r\)</span>​​​​​​，左到 <span class="math inline">\(L_c\)</span>​​​​​，右到 <span class="math inline">\(R_c\)</span>​​​​​​。</li>
<li>设 <span class="math inline">\(a_{L_r},a_{L_r+1},\cdots,a_{R_r}\)</span>​​​ 中第一个取到最小值的位置为 <span class="math inline">\(i\)</span>，显然 <span class="math inline">\((i,L_c),(i,L_c+1),\cdots,(i,R_c)\)</span>​ 都为 “1”。</li>
<li>我们希望 <span class="math inline">\(S\)</span> 被 <span class="math inline">\(i\)</span> 数到。</li>
</ul>
<p>再考虑对于 <span class="math inline">\(i\)</span>​，有多少个连通块会被它数到，对于第 <span class="math inline">\(i\)</span> 行的一个 “1” 的连续段 <span class="math inline">\([l,r]\)</span>，它所在的连通块会被 <span class="math inline">\(i\)</span>​​ 数当且仅当：</p>
<ul>
<li>它向上不能走到一行 <span class="math inline">\(j\)</span>​​​ 满足 <span class="math inline">\(a_j \le a_i\)</span>​​​​，形式化地，<span class="math inline">\(\min_{k\in [l,r]}a_k+\max_{k\in (j,i]}b_k&gt;x\)</span>​​。</li>
<li>它向下不能走到一行 <span class="math inline">\(j\)</span>​​ 满足 <span class="math inline">\(a_j&lt;a_i\)</span>​​​，形式化地，<span class="math inline">\(\min_{k\in [l,r]}a_k+\max_{k\in [i,j)}b_k&gt;x\)</span>​​​。</li>
</ul>
<p>综上，记 <span class="math inline">\(i\)</span> 前面第一个满足 <span class="math inline">\(a_j\le a_i\)</span> 的 <span class="math inline">\(j\)</span> 为 <span class="math inline">\(pre\)</span>， <span class="math inline">\(i\)</span> 后面第一个满足 <span class="math inline">\(a_j&lt; a_i\)</span> 的 <span class="math inline">\(j\)</span> 为 <span class="math inline">\(suf\)</span>，连续段 <span class="math inline">\([l,r]\)</span> 造成贡献当且仅当 <span class="math inline">\(\min_{i\in [l,r]}a_i&gt;x-\max_{i\in (pre,suf)}\)</span>，不等式右边对于每个 <span class="math inline">\(i\)</span> 是确定的，而且是可以通过单调栈 <span class="math inline">\(O(n)\)</span>​ 预处理的东西，对于左边则可以使用数据结构来维护。</p>
<p>下面我们进一步讨论这个数据结构需要干什么：</p>
<ul>
<li>这个数据结构维护所有连续段 <span class="math inline">\(b\)</span> 的最小值。</li>
<li>将所有行以 <span class="math inline">\(a_i\)</span>​ 为第一关键字，<span class="math inline">\(i\)</span>​​ 为第二关键字从大到小排序。每次序列中一个 <span class="math inline">\(0\)</span> 改成 <span class="math inline">\(1\)</span>​，会导致新增连续段，也会导致两个连续段合并，修改就是加入元素和删除元素。</li>
<li>询问操作就是查询有多少个元素大于 <span class="math inline">\(key\)</span>。</li>
</ul>
<p>对于新增连续段和合并连续段可以用并查集维护，元素则用反向树状数组维护。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t1">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T1</h3>
<p>把两端同色的边看成实边，两端异色的边看成虚边。</p>
<ul>
<li><code>1</code> 操作就是 <code>access(u)</code>。</li>
<li><code>2</code> 操作就是查询两点间的虚边条数，转化一下变成查询一个点到根路径上的虚边条数。</li>
<li><code>3</code> 操作转化一下就是查询 <code>dfs</code> 序区间中的点到根路径上的虚边条数总和。</li>
<li><code>4</code> 操作就是每条实链点数选二之和。</li>
</ul>
<p>对于 <code>23</code> 操作，需要维护每个点到根路径上的虚边条数，支持区间加、区间求和，树状数组即可。</p>
<p>对于 <code>4</code> 操作，在 <code>LCT</code> 中维护实链的点数，就可以在 <code>access</code> 时维护答案。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t2">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T2</h3>
<p>记 <span class="math inline">\(f_{i,j}\)</span> 表示有多少个串恰好有 <span class="math inline">\(i\)</span> 个 <code>a</code>、<span class="math inline">\(j\)</span>​​ 个 <code>b</code>，不难写出它的生成函数 <span class="math inline">\((x+y+k-2)^L\)</span>。</p>
<p>而题目中求的就是 <span class="math inline">\(\sum_{i=0}^L\sum_{j=0}^L[n|i-p][n|j-q][x^i][y^j](x+y+k-2)^L\)</span>​​。</p>
<p>题目还保证 <span class="math inline">\(n|P-1\)</span>​，考虑单位根反演，得到答案为 <span class="math display">\[
\frac 1{n^2}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}(\omega_n^i+\omega_n^j+k-2)^L\omega_n^{-ip}\omega_n^{-jq}
\]</span> 记 <span class="math inline">\(A_{i,j}=(\omega_n^i+\omega_n^j+k-2)^L\)</span> 可以 <span class="math inline">\(O(n^2\log L)\)</span> 预处理，答案矩阵 <span class="math inline">\(B\)</span> 就是 <span class="math inline">\(A\)</span> 对两维分别做 <code>IDFT</code> 得到的。每次固定一维，对另一维做 <code>IDFT</code> 就行了，暴力做复杂度 <span class="math inline">\(O(n^3)\)</span>，或者 Bluestein + MTT 可以做到 <span class="math inline">\(O(n^2\log n)\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(n^3)\)</span> 或者 <span class="math inline">\(O(n^2\log L)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t9">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T9</h3>
<p>称区间中数量超过一半的数为 <strong>主元素</strong>。</p>
<p>由于一个合法区间只有一个主元素，可以考虑每个主元素的贡献。</p>
<h4 id="做法-1">做法 1</h4>
<p>考虑枚举一个值 <span class="math inline">\(v\)</span>​，计算这个值的贡献。</p>
<p>假设 <span class="math inline">\(v\)</span>​ 在序列中的出现位置为 <span class="math inline">\(p_1,p_2,\cdots,p_k\)</span>​​，区间 <span class="math inline">\([l,r]\)</span> 中第一个 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(p_i\)</span> 出现，最后一个 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(p_j\)</span>​ 出现。</p>
<p>考虑枚举 <span class="math inline">\(j\)</span>​，快速查询有多少对合法的 <span class="math inline">\((l,r)\)</span>​。把等于 <span class="math inline">\(v\)</span>​ 的位置变成 <span class="math inline">\(1\)</span>​，不等于 <span class="math inline">\(v\)</span>​ 的位置变成 <span class="math inline">\(-1\)</span>​，记前缀和为 <span class="math inline">\(sum_i\)</span>​，那么区间 <span class="math inline">\([l,r]\)</span>​ 合法的充要条件为 <span class="math inline">\(sum_{l-1}&lt;sum_r\)</span>​，因此需要维护的是 <span class="math inline">\(sum_1,sum_2,\cdots,sum_{p_j}\)</span>​ 组成的集合，<span class="math inline">\(j\rightarrow j+1\)</span>​ 时，加入的元素是 <span class="math inline">\(sum_{p_j},sum_{p_j+1},\cdots,sum_{p_{j+1}-1}\)</span>​，它们的值是连续的一段，所以这是一个区间 <span class="math inline">\(+1\)</span>​，对于一个 <span class="math inline">\(r\in[p_j,p_{j+1})\)</span>​，合法 <span class="math inline">\(l\)</span>​ 的数量就是集合中小于 <span class="math inline">\(sum_r\)</span>​​ 的元素数量，这是一个前缀和，而 <span class="math inline">\([p_j,p_{j+1})\)</span>​ 内所有的 <span class="math inline">\(sum_r\)</span>​ 构成一个区间，所以询问操作是查询前缀和的前缀和，可以用三个树状数组实现。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h4 id="做法-2">做法 2</h4>
<p>考虑分治，计算有多少个合法区间 <span class="math inline">\([l,r]\)</span>​​ 满足 <span class="math inline">\(l\le mid+1 \land r\ge mid\)</span>​​。</p>
<p>可以发现区间 <span class="math inline">\([l,r]\)</span>​​ 合法的必要条件是 <span class="math inline">\([l,mid]\)</span> 和 <span class="math inline">\([mid+1,r]\)</span> 中至少有一个是合法的。</p>
<blockquote>
<p>引理：一个序列所有前缀的主元素中本质不同只有 <span class="math inline">\(O(\log n)\)</span> 个。</p>
</blockquote>
<p>所以可能产生贡献的 <span class="math inline">\(v\)</span> 只有 <span class="math inline">\(O(\log n)\)</span> 个。枚举 <span class="math inline">\(v\)</span>。把等于 <span class="math inline">\(v\)</span> 的位置变成 <span class="math inline">\(1\)</span>，不等于 <span class="math inline">\(v\)</span> 的位置变成 <span class="math inline">\(-1\)</span>，记前缀和为 <span class="math inline">\(sum_i\)</span>，枚举 <span class="math inline">\(r\)</span> 后，需要查询有多少个 <span class="math inline">\(l\le mid+1\)</span> 满足 <span class="math inline">\(sum_{l-1}&lt;sum_r\)</span>，这个可以预处理前缀和做到 <span class="math inline">\(O(1)\)</span> 查询。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t13">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T13</h3>
<p>先二分一个直径 <span class="math inline">\(D\)</span>，考虑用 <code>DP</code> 去判定。</p>
<p>设 <span class="math inline">\(f_{u,0/1}\)</span> 表示以下情形以 <span class="math inline">\(u\)</span>​ 为端点向子树内延伸的最长链的最小值（不存在时为 <span class="math inline">\(\infty\)</span>）：</p>
<ul>
<li>确定了 <span class="math inline">\(u\)</span>​ 子树内每个点选哪条边。</li>
<li><span class="math inline">\(u\)</span> 选的边是否是 <span class="math inline">\(u\)</span>​ 和父亲的连边。</li>
<li>子树内直径不超过 <span class="math inline">\(D\)</span>。</li>
</ul>
<p><span class="math inline">\(f_{u,1}\)</span>​​​ 可以直接从每个儿子 <span class="math inline">\(v\)</span>​​​ 用 <span class="math inline">\(\min(f_{v,0}+w(u,v),f_{v,1}+\max(w(u,v)-p_v,0))\)</span>​​​ 转移过来，如果前两大的值之和大于 <span class="math inline">\(D\)</span>​​，<span class="math inline">\(f_{u,1}=\infty\)</span>​​，否则就取这些值中的最大值。</p>
<p><span class="math inline">\(f_{u,0}\)</span>​ 的转移需要分析一下，<span class="math inline">\(u\)</span>​ 选择的边 <span class="math inline">\((u,v)\)</span>​​ 必须要满足 <span class="math inline">\(v\)</span>​ 是 <span class="math inline">\(\min(f_{v,0}+w(u,v),f_{v,1}+w(u,v)-p_v)\)</span>​​ 前两大的儿子，所以枚举一下 <span class="math inline">\(v\)</span>，就可以直接转移了。</p>
<p>复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<h3 id="agc041d">AGC041D</h3>
<p>考虑任意 <span class="math inline">\(k\)</span>​ 道题的总分都小于任意 <span class="math inline">\(k+1\)</span>​ 道题的总分这个限制，发现它等价于前 <span class="math inline">\(\lceil\frac n2\rceil\)</span>​ 道题的总分小于后 <span class="math inline">\(\lceil\frac n2\rceil-1\)</span>​ 道题的总分。</p>
<p>考虑如何生成一个合法的序列 <span class="math inline">\(A\)</span>：</p>
<ul>
<li>枚举第 <span class="math inline">\(\lfloor\frac n2\rfloor+1\)</span>​ 道题的分值 <span class="math inline">\(c\)</span>​，令 <span class="math inline">\(A=(c,c,\cdots,c)\)</span>​。</li>
<li>多次选一个位置 <span class="math inline">\(j&lt;\lfloor\frac n2\rfloor+1\)</span>​​，将 <span class="math inline">\(A_1,A_2,\cdots,A_j\)</span>​ 全部减一。</li>
<li>多次选一个位置 <span class="math inline">\(j&gt;\lfloor\frac n2\rfloor+1\)</span>​，将 <span class="math inline">\(A_j,A_{j+1},\cdots,A_n\)</span>​​​ 全部加一。</li>
<li>由于 <span class="math inline">\(A_1 \ge 1\)</span>​​​，所以第二种操作的次数不得超过 <span class="math inline">\(c-1\)</span>​​​，同理第三种操作的次数不得超过 <span class="math inline">\(n-c\)</span>​​​。</li>
<li>设前 <span class="math inline">\(\lceil\frac n2\rceil\)</span>​ 道题的总分减后 <span class="math inline">\(\lceil\frac n2\rceil-1\)</span>​ 道题的总分为 <span class="math inline">\(x\)</span>​，第一步后 <span class="math inline">\(x=c\)</span>​，第二种操作每一次都会使 <span class="math inline">\(x\)</span>​ 减小 <span class="math inline">\(j\)</span>​，第三种操作每一次都会使 <span class="math inline">\(x\)</span>​ 减小 <span class="math inline">\(n-j+1\)</span>​​，因此第二、三种操作的总贡献要小于 <span class="math inline">\(c\)</span>。</li>
</ul>
<p>可以看出这是一个完全背包，第二种操作就是添加体积为 <span class="math inline">\(1,2,\cdots,\lfloor\frac n2\rfloor\)</span>​​ 的物品，而且最多添加 <span class="math inline">\(c-1\)</span>​ 个，第三种操作就是添加体积为 <span class="math inline">\(1,2,\cdots,\lceil\frac n2\rceil-1\)</span>​​​​ 的物品，最多添加 <span class="math inline">\(n-c\)</span>​ 个，总体积要小于 <span class="math inline">\(c\)</span>​。</p>
<p>对于第二种操作，考虑预处理 <span class="math inline">\(L_{i,j}\)</span>​ 表示选择 <span class="math inline">\(i\)</span> 个物品，总体积为 <span class="math inline">\(j\)</span> 的方案数。用传统背包做复杂度肯定不行，事实上它能直接转移： <span class="math display">\[
L_{i,j}=L_{i-1,j-1}+L_{i,j-i}-L_{i-1,j-i-\lfloor\frac n2\rfloor}
\]</span> 对于第三种操作，同理可以预处理 <span class="math inline">\(R_{i,j}\)</span>。</p>
<p>然后就可以枚举 <span class="math inline">\(c\)</span>​ 后 <span class="math inline">\(O(n)\)</span>​​ 计算合法方案数。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc027d">AGC027D</h3>
<p>构造的思路是先黑白染色，然后填好黑格，再让每个白格满足：</p>
<ul>
<li>它大于周围四个黑格。</li>
<li>它模周围四个黑格都等于 <span class="math inline">\(1\)</span>。</li>
</ul>
<p>填白格的过程是容易的，对于一个白格，先算出周围四个黑格的 <span class="math inline">\(\text{lcm}\)</span>，然后尝试填 <span class="math inline">\(\text{lcm}+1\)</span>​，如果已经填过了，就继续尝试 <span class="math inline">\(2\text{lcm}+1,3\text{lcm}+1,\cdots\)</span>​。</p>
<p>如果没有值域限制，这题就做完了，考虑怎样让填的数尽可能小。</p>
<p>填白格没有什么好优化的（尝试过优先填 <span class="math inline">\(\text{lcm}\)</span>​​ 较大的格子，但完全没有效果），所以考虑如何填黑格，才能使 <span class="math inline">\(\text{lcm}\)</span> 比较小。</p>
<ul>
<li>填法一：顺序填或随机填，大概只能构造 <span class="math inline">\(N\)</span> 等于一百多。</li>
<li>填法二：考虑到一个白格周围四个黑格有两个是同一行的，有两个是同一列的，令 <span class="math inline">\(A_{i,j}\)</span> 是 <span class="math inline">\(\text{lcm(i,j)}\)</span> 的倍数，具体怎么确定，像确定白格那样确定，大概能构造 <span class="math inline">\(N\)</span> 等于两百多。</li>
<li>填法三：考虑到一个白格周围四个黑格只涉及四条斜线，令 <span class="math inline">\(A_{i,j}\)</span> 是 <span class="math inline">\(\text{lcm}(i+j,i-j+n)\)</span> 的倍数，大概能构造 <span class="math inline">\(N\)</span> 等于 <span class="math inline">\(425\)</span> 左右。</li>
<li>填法四：经过一番尝试，令 <span class="math inline">\(A_{i,j}\)</span>​​ 是 <span class="math inline">\(\text{lcm}(i+(n-j+1),i-(n-j+1)+n)\)</span>​（就是把列编号倒过来）可以通过。</li>
<li>填发五：考虑给每条斜线分配一个质数，黑格就等于所在的两条斜线质数的乘积，白格就等于周围四条斜线质数的乘积加一，一定不会有数重复。</li>
</ul>
<p>填发四需要用 <code>set</code> 维护哪些数填过，复杂度 <span class="math inline">\(O(n^2\log n)\)</span>​​。</p>
<p>填发五复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc025d">AGC025D</h3>
<p>对于两个距离为 <span class="math inline">\(\sqrt D\)</span>​ 的点 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>​，考虑 <span class="math inline">\(x_1-x_2,y_1-y_2\)</span>​​ 的奇偶性： <span class="math display">\[
x_1 \equiv x_2 \pmod 2,y_1 \equiv y_2 \pmod 2 \iff D \equiv 0 \pmod 4\\
x_1 \equiv x_2 \pmod 2,y_1 \not\equiv y_2 \pmod 2 \iff D \equiv 1 \pmod 4\\
x_1 \not\equiv x_2 \pmod 2,y_1 \not\equiv y_2 \pmod 2 \iff D \equiv 2 \pmod 4\\
\]</span> 因此 <span class="math inline">\(D \bmod 4\)</span>​ 说明了两点坐标差的奇偶性。</p>
<blockquote>
<p>引理：将平面上距离为 <span class="math inline">\(\sqrt D\)</span> 的点对连边后是一张二分图。</p>
</blockquote>
<p>考虑构造一个黑白染色方案，设 <span class="math inline">\(\text{color}(x,y,D)=0/1\)</span> 表示点 <span class="math inline">\((x,y)\)</span> 的颜色。</p>
<ul>
<li><p>当 <span class="math inline">\(D\equiv 3\pmod 4\)</span> 时，没有边，<span class="math inline">\(\text{color}(x,y,D)=0\)</span>。</p></li>
<li><p>当 <span class="math inline">\(D\equiv 2\pmod 4\)</span> 时，<span class="math inline">\(\text{color}(x,y,D)=x\bmod 2\)</span>，这样距离为 <span class="math inline">\(\sqrt D\)</span> 的点对就必然异色。</p></li>
<li><p>当 <span class="math inline">\(D \equiv 1\pmod 4\)</span> 时，<span class="math inline">\(\text{color}(x,y,D)=(x+y)\bmod 2\)</span>，这样距离为 <span class="math inline">\(\sqrt D\)</span> 的点对就必然异色。</p></li>
<li><p>当 <span class="math inline">\(D\equiv 0\pmod 4\)</span> 时，<span class="math inline">\(\text{color}(x,y,D)=\text{color}(\lfloor\frac x2\rfloor,\lfloor\frac y2\rfloor,\frac D4)\)</span>​​，下面证明为什么合法：</p>
<p>对于两个距离为 <span class="math inline">\(\sqrt D\)</span> 的点 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>，由于 <span class="math inline">\(x_1 \equiv x_2 \pmod 2,y_1 \equiv y_2 \pmod 2\)</span>，所以 <span class="math display">\[
\lfloor\frac {x_1}2\rfloor-\lfloor\frac {x_2}2\rfloor=\frac 12(x_1-x_2)\\
\lfloor\frac {y_1}2\rfloor-\lfloor\frac {y_2}2\rfloor=\frac 12(y_1-y_2)
\]</span> 进一步： <span class="math display">\[
\begin{aligned}
&amp;(x_1-x_2)^2+(y_1-y_2)^2=D\\
\Rightarrow &amp;(\lfloor\frac {x_1}2\rfloor-\lfloor\frac {x_2}2\rfloor)^2+(\lfloor\frac {y_1}2\rfloor-\lfloor\frac {y_2}2\rfloor)^2=\frac D4\\
\Rightarrow &amp;\text{color}(\lfloor\frac {x_1}2\rfloor,\lfloor\frac {y_1}2\rfloor,\frac D4)\ne\text{color}(\lfloor\frac {x_2}2\rfloor,\lfloor\frac {y_2}2\rfloor,\frac D4)
\end{aligned}
\]</span></p></li>
</ul>
<p>对于 <span class="math inline">\(D_1\)</span>​ 和 <span class="math inline">\(D_2\)</span>​ 分别黑白染色后本质有 <span class="math inline">\(4\)</span>​ 种颜色，这 <span class="math inline">\(4\)</span>​​ 种颜色中肯定有一种点数大于等于 <span class="math inline">\(n^2\)</span>​，输出这种颜色的 <span class="math inline">\(n^2\)</span>​ 个点即可。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc036d">AGC036D</h3>
<p>没有负环等价于差分约束有解，假设解为 <span class="math inline">\(d_1,d_2,\cdots,d_n\)</span>​，不妨令 <span class="math inline">\(d_1=0\)</span>。</p>
<p>由于 <span class="math inline">\(i\rightarrow i+1\)</span> 的边是不能被删的，所以 <span class="math inline">\(d\)</span> 是单调不增的，也就是一段 <span class="math inline">\(0\)</span>，一段 $-1 $，一段 <span class="math inline">\(-2\cdots\)</span> 的形式。</p>
<p>考虑一段一段的枚举 <span class="math inline">\(d\)</span>​​​，上一段是 <span class="math inline">\([a,b]\)</span>​​​，即 <span class="math inline">\(d_{a,a+1,\cdots,b}=x+1\)</span>​​​，枚举了新的一段 <span class="math inline">\([b+1,c]\)</span>​​，即 <span class="math inline">\(d_{b+1,b+2,\cdots,c}=x\)</span>​​​​​，​分析哪些边需要删：</p>
<ul>
<li>对于 <span class="math inline">\(b+1\le i &lt; j \le c\)</span>，边 <span class="math inline">\((i,j)\)</span> 需要删除。</li>
<li>对于 <span class="math inline">\(b+1\le i\le c,j&lt;a\)</span>，边 <span class="math inline">\((i,j)\)</span> 需要删除。</li>
</ul>
<p>然后就可以 <code>DP</code> 了，设 <span class="math inline">\(f_{a,b}\)</span> 表示填的最后一段为 <span class="math inline">\([a,b]\)</span> 时的最小代价，转移为 <span class="math display">\[
f_{a,b}+\text{cost}_1(b+1,c)+\text{cost}_2(b+1,c,a-1)\rightarrow f_{b+1,c}
\]</span> 其中 <span class="math inline">\(\text{cost}_1\)</span>​ 和 <span class="math inline">\(\text{cost}_2\)</span>​​ 在预处理二维前缀和后可以 <span class="math inline">\(O(1)\)</span> 算。</p>
<p>复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
<h3 id="agc045d">AGC045D</h3>
<p>如果 <code>Snuke</code> 按到了 <span class="math inline">\(p_i=i\)</span> 的位置就死了，所以他要最小化有解时死的概率，分析 <code>Snuke</code> 的最优策略：</p>
<ul>
<li>最初需要按下一个按钮，由于 <code>Snuke</code> 不知道排列，所以按每个按钮都是一样的，不妨按 <span class="math inline">\(1\)</span>。</li>
<li>如果按下了 <span class="math inline">\(p_i=i\)</span> 的按钮就死了。</li>
<li>否则，<span class="math inline">\(p_i\)</span>​ 一定是一个安全的按钮，继续按下 <span class="math inline">\(p_i\)</span>，这样就可以安全地按下许多按钮。</li>
<li>又需要尝试一个按钮时就按没按过的编号最小的按钮。</li>
</ul>
<p>于是，得到了 <code>Snuke</code> 胜利的充要条件：假设 <span class="math inline">\(1-A\)</span> 中第一个满足 <span class="math inline">\(p_i=i\)</span> 的 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(\min\)</span>​​，<span class="math inline">\(\forall i&gt;A,\exists j&lt;\min\)</span> 使得 <span class="math inline">\(j\)</span> 能到达 <span class="math inline">\(i\)</span>。</p>
<p>容易想到枚举 <span class="math inline">\(\min\)</span>​，把排列看成若干个循环，要求 <span class="math inline">\(\min\)</span>​ 前面没有孤立点，这个可以容斥：</p>
<ul>
<li>钦定 <span class="math inline">\(i\)</span>​​​ 个孤立点，系数为 <span class="math inline">\((-1)^i\binom{\min-1}i\)</span>​。</li>
<li>对于 <span class="math inline">\([1,\min-1]\)</span>​​ 中剩下的 <span class="math inline">\(\min-1-i\)</span>​​ 个点先生成若干个循环，方案数为 <span class="math inline">\((\min-1-i)!\)</span>。</li>
<li>对于 <span class="math inline">\([A+1,n]\)</span> 中的点，它们只能加入前面的循环，方案数为 <span class="math inline">\((\min-1-i)^{\overline{n-A}}\)</span>​。</li>
<li>对于 <span class="math inline">\([\min+1,A]\)</span> 中的点，它们既可以加入前面的循环，又可以新建一个环，方案数为 <span class="math inline">\((\min-1-i+n-A)^{\overline{A-\min}}\)</span>。</li>
</ul>
<p>综上，得到 <span class="math inline">\(\min\)</span> 的贡献为： <span class="math display">\[
\sum_{i=0}^{\min-1}(-1)^i\binom{\min-1}i\frac{(n-1-i)!(\min-1-i)}{\min-1-i+n-A}
\]</span> 当 <span class="math inline">\(\min\)</span>​ 不存在时需要特判，贡献为： <span class="math display">\[
\sum_{i=0}^A(-1)^i\binom Ai(n-i)!
\]</span> 复杂度 <span class="math inline">\(O(A^2+n)\)</span>。</p>
<h3 id="agc041e">AGC041E</h3>
<h4 id="对于-t1">对于 <span class="math inline">\(T=1\)</span></h4>
<p>将网络抽象成一张有向图：</p>
<ul>
<li>将每条线的起点、终点和平衡器的端点抽象成结点。</li>
<li>同一条线上的结点后面向前面连边。</li>
<li>平衡器抽象成两个方向的边。</li>
</ul>
<p>考虑暴力怎么做，枚举最终汇聚到第 <span class="math inline">\(t\)</span>​ 条线，判断 <span class="math inline">\(t\)</span> 的终点是否可以到达所有的起点。</p>
<p>可以用一个 <code>bitset</code> 来压哪些汇点能到达这个点，然后 <code>DFS</code> 来求这些 <code>bitset</code>。可以做到 <span class="math inline">\(O(\frac {nm}{\omega})\)</span>​​​ 的复杂度。</p>
<h4 id="对于-t2">对于 <span class="math inline">\(T=2\)</span></h4>
<p><span class="math inline">\(n=2\)</span> 时显然无解，下面构造说明了 <span class="math inline">\(n&gt;2\)</span> 时一定有解。</p>
<p>考虑从右往左依次插入每个平衡器，维护 <span class="math inline">\(size_i\)</span> 表示当前网络有多少个起点会到达第 <span class="math inline">\(i\)</span> 条线的终点。</p>
<ul>
<li>初始时，<span class="math inline">\(size_i=1\)</span>。</li>
<li>加入平衡器 <span class="math inline">\((x,y)\)</span> 时，要么 <span class="math inline">\(size_x+1\)</span>，要么 <span class="math inline">\(size_y+1\)</span>，选择 <span class="math inline">\(size_x\)</span> 和 <span class="math inline">\(size_y\)</span> 中较小的一个 <span class="math inline">\(+1\)</span>。一定不会出现 <span class="math inline">\(size_x=n-1\land size_y=n-1\)</span> 的情况，因为 <span class="math inline">\(size_x+size_y\le n\)</span>。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<h3 id="abc214g">ABC214G</h3>
<p>以下解法可以解决 <span class="math inline">\(n \le 10^5\)</span>​​ 的问题。</p>
<p>设 <span class="math inline">\(F_k\)</span>​​​ 表示确定 <span class="math inline">\(k\)</span>​​​ 个位置的值 <span class="math inline">\(r_{i_1},r_{i_2},\cdots,r_{i_k}(i_1&lt;i_2&lt;\cdots&lt;i_k)\)</span>​​​​​​​​ 满足以下条件的方案数： <span class="math display">\[
\forall x\in[1,k],r_{i_x}=p_{i_x}\lor r_{i_x}=q_{i_x}
\]</span> 根据二项式反演，答案为 <span class="math display">\[
\sum_{i=0}^n(-1)^iF_i(n-i)!
\]</span> 将 <span class="math inline">\(p_i,q_i\)</span>​​​​​​​ 连边，得到一张由若干个环组成的图，选择一个满足 <span class="math inline">\(r_i=p_i\lor r_i=q_i\)</span>​​ 的位置 <span class="math inline">\(i\)</span>​​​​ 就是选择一条边并占用一个端点，这对于每个环是独立的，所以对每个环求出 <span class="math inline">\(F\)</span>​​ 数组，再用分治 <code>FFT</code> 合并就可以得到整张图的 <span class="math inline">\(F\)</span>​ 数组。</p>
<p>考虑求一个大小为 <span class="math inline">\(m\)</span>​ 的环的 <span class="math inline">\(F\)</span>​ 数组，假设点编号为 <span class="math inline">\(1,2,\cdots,m\)</span>，边为 <span class="math inline">\((1,2),(2,3),\cdots,(m-1,m),(m,1)\)</span>，将选择 <span class="math inline">\(i\)</span> 条边的方案分为以下两类：</p>
<ul>
<li><p>不选边 <span class="math inline">\((1,2)\)</span>​，把边 <span class="math inline">\((2,3)\)</span> 占用 <span class="math inline">\(2\)</span> 的方式编号为 <span class="math inline">\(1\)</span>，边 <span class="math inline">\((2,3)\)</span> 占用 <span class="math inline">\(3\)</span> 的方式编号为 <span class="math inline">\(2\)</span>，边 <span class="math inline">\((3,4)\)</span> 占用 <span class="math inline">\(3\)</span> 的方式编号为 <span class="math inline">\(3\)</span>，边 <span class="math inline">\((3,4)\)</span> 占用 <span class="math inline">\(4\)</span> 的方式编号为 <span class="math inline">\(4\)</span>，依次类推。方案就是从 <span class="math inline">\(2m-2\)</span>​ 种选择方式选 <span class="math inline">\(i\)</span>​ 种，限制就是编号相邻的不能同时选择。</p>
<blockquote>
<p>引理：从 <span class="math inline">\(n\)</span> 个物品中选 <span class="math inline">\(r\)</span> 个，编号相邻的不能同时选择的方案数为 <span class="math inline">\(\binom {n-r+1}r\)</span>​。</p>
<p>证明：将选择的第 <span class="math inline">\(i\)</span> 个物品的编号减去 <span class="math inline">\(i-1\)</span> 就得到了从 <span class="math inline">\(n-r+1\)</span> 个物品中选 <span class="math inline">\(r\)</span> 个的方案数。</p>
</blockquote>
<p>这部分方案数为 <span class="math inline">\(\binom{2m-i-1}i\)</span>​。</p></li>
<li><p>选边 <span class="math inline">\((1,2)\)</span>​​，那么边 <span class="math inline">\((1,2)\)</span>​​ 可以占用 <span class="math inline">\(1\)</span>​​ 或 <span class="math inline">\(2\)</span>​​，但两种方式是等价的，不妨假设占用了 <span class="math inline">\(1\)</span>​​。方案就是从 <span class="math inline">\(2m-3\)</span>​​ 种选择方式选 <span class="math inline">\(i-1\)</span>​​​​ 种，限制还是编号相邻的不能同时选择。</p>
<p>这部分方案数为 <span class="math inline">\(2\binom{2m-i-1}{i-1}\)</span>。</p></li>
</ul>
<p>对于一个大小为 <span class="math inline">\(m\)</span> 的环 <span class="math display">\[
F_i=\binom{2m-i-1}i+2\binom{2m-i-1}{i-1}=\binom{2m-i}i+\binom{2m-i-1}{i-1}
\]</span> 然后每个环的 <span class="math inline">\(F\)</span>​ 就可以 <span class="math inline">\(O(n)\)</span>​ 求了，复杂度瓶颈在于分治 <code>FFT</code>，复杂度 <span class="math inline">\(O(n\log^2n)\)</span>​​​。</p>
<p>分治 <code>FFT</code> 有两种优化：</p>
<ul>
<li>由于每个环的大小之和为 <span class="math inline">\(n\)</span>，故只有 <span class="math inline">\(O(\sqrt n)\)</span> 种大小不同的环，大小相同的环可以通过快速幂 <span class="math inline">\(O(n\log n)\)</span>​ 地算出乘积。</li>
<li>整个分治过程形成一棵二叉树的结构，总时间就是 <span class="math inline">\(\sum_{u\in \mathbb{leaf}}\text{degree}_u\text{depth}_u\)</span>​，最小化时间就是 <code>Huffman</code> 树，每次贪心地将两个次数最小的多项式乘起来。 ​​​</li>
</ul>
<h3 id="abc214h">ABC214H</h3>
<p>走到了一个强连通分量就肯定会走完内部的所有点，缩点后图就变成了 <code>DAG</code>，假设原图就是 <code>DAG</code>。</p>
<p>想到用最小费用流解决：</p>
<ul>
<li>把每个点 <span class="math inline">\(u\)</span> 拆成 <span class="math inline">\(\text{in}_u\)</span> 和 <span class="math inline">\(\text{out}_u\)</span>。</li>
<li><span class="math inline">\(\text{in}_u\)</span> 向 <span class="math inline">\(\text{out}_u\)</span> 连一条容量为 <span class="math inline">\(1\)</span>​，费用为 <span class="math inline">\(-X_u\)</span>​ 的边，再连一条容量为 <span class="math inline">\(K\)</span>，费用为 <span class="math inline">\(0\)</span> 的边。</li>
<li>对于原图中的边 <span class="math inline">\((u,v)\)</span>​，<span class="math inline">\(\text{out}_u\)</span>​ 向 <span class="math inline">\(\text{in}_v\)</span>​ 连一条容量为 <span class="math inline">\(K\)</span>​，费用为 <span class="math inline">\(0\)</span>​ 的边。</li>
<li><span class="math inline">\(S\)</span> 向 <span class="math inline">\(\text{in}_1\)</span> 连一条容量为 <span class="math inline">\(K\)</span>，费用为 <span class="math inline">\(0\)</span> 的边，<span class="math inline">\(\text{out}_u\)</span> 向 <span class="math inline">\(T\)</span> 连一条容量为 <span class="math inline">\(K\)</span>，费用为 <span class="math inline">\(0\)</span> 的边。</li>
</ul>
<p><code>SSP</code> 算法肯定是通过不了的，考虑变成 <code>Primal-Dual</code> 算法可以做的问题。</p>
<h4 id="sol-1">Sol 1</h4>
<p>初始图是一张 <code>DAG</code>，可以跑一遍 <code>DP</code> 预处理最短路作为点的初始势能。</p>
<h4 id="sol-2">Sol 2</h4>
<p>求出 <code>DAG</code> 的一组拓扑序，然后给每个点按拓扑序从大到小重新编号（也就是缩完点后的编号）。</p>
<p>容易构造一组满足差分约束的初始势能：</p>
<ul>
<li><span class="math inline">\(S\)</span>​​ 势能为 <span class="math inline">\(\sum X_u\)</span>​​，<span class="math inline">\(T\)</span>​​​ 势能为 <span class="math inline">\(0\)</span>​​。</li>
<li><span class="math inline">\(\text{in}_u\)</span>​ 的势能为 <span class="math inline">\(\sum_{i=1}^uX_i\)</span>​，<span class="math inline">\(\text{out}_u\)</span> 的势能为 <span class="math inline">\(\sum_{i=1}^{u-1}X_i\)</span>。</li>
</ul>
<p>上述两种做法复杂度都是 <span class="math inline">\(O(nK\log n)\)</span>。</p>
<h3 id="agc027e">AGC027E</h3>
<p>考虑什么样的串能变成单个字母 <span class="math inline">\(a\)</span> 或 <span class="math inline">\(b\)</span>。</p>
<p>打表发现能变成 <span class="math inline">\(a\)</span> 的串 <span class="math inline">\(S\)</span> 满足的 <span class="math inline">\(a,b\)</span> 数量关系是 <span class="math inline">\(a\)</span> 的数量减 <span class="math inline">\(b\)</span> 的数量模 <span class="math inline">\(3\)</span> 余 <span class="math inline">\(1\)</span>，并且这个条件在 <span class="math inline">\(|S|\)</span> 为偶数时也是充分条件，当 <span class="math inline">\(|S|\)</span> 为奇数时恰好多了一个串 <span class="math inline">\(ababab\cdots aba\)</span>​。​</p>
<blockquote>
<p>引理一：记 <span class="math inline">\(p(S)\)</span>​ 表示 <span class="math inline">\(S\)</span>​ 中 <span class="math inline">\(a\)</span>​ 的个数减 <span class="math inline">\(b\)</span>​ 的个数模 <span class="math inline">\(3\)</span>​，<span class="math inline">\(S\)</span>​ 能变成单个字母 <span class="math inline">\(c\)</span>​ 当且仅当：</p>
<ul>
<li><span class="math inline">\(p(S)=p(c)\)</span></li>
<li><span class="math inline">\(S=c\)</span> 或 <span class="math inline">\(S\)</span> 中有相邻的相同字母。</li>
</ul>
</blockquote>
<p>必要性显然，下面证明充分性：当 <span class="math inline">\(|S|\le 3\)</span> 时显然成立，当 <span class="math inline">\(|S|&gt;3\)</span> 时取出 <span class="math inline">\(S\)</span> 中最长的连续相同子串，不妨假设它是 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(a\)</span>，分两种情况讨论：</p>
<ul>
<li><span class="math inline">\(n \ge 4\)</span>，直接将前两个 <span class="math inline">\(a\)</span>​​ 合并，<span class="math inline">\(|S|\)</span> 减小了 <span class="math inline">\(1\)</span>，并且还满足引理条件。</li>
<li><span class="math inline">\(n\le 3\)</span>​，由于 <span class="math inline">\(|S|&gt;3\)</span>​，这个子串不可能前后都没有字母，不妨假设它不在开头，那么它前面必然是 <span class="math inline">\(b\)</span>​，将前两个 <span class="math inline">\(a\)</span>​ 合并成 <span class="math inline">\(b\)</span>，那么此时有两个 <span class="math inline">\(b\)</span> 会相邻，<span class="math inline">\(|S|\)</span> 减小了 <span class="math inline">\(1\)</span>​，并且还满足引理条件。</li>
</ul>
<p>然后问题就转化成了有多少个串 <span class="math inline">\(T\)</span> 满足以下条件：</p>
<ul>
<li>存在一种将 <span class="math inline">\(S\)</span> 划分为 <span class="math inline">\(|T|\)</span> 段的方式，使得每一段与 <span class="math inline">\(T\)</span>​​ 中的对应字母满足引理一。</li>
</ul>
<p>这个问题的主要难点在于引理一的条件二。</p>
<p>事实上，当 <span class="math inline">\(S\)</span>​ 中有相邻的相同字母时，<strong>忽略引理一的条件二</strong> 不会影响答案。</p>
<blockquote>
<p>引理二：若 <span class="math inline">\(S\)</span> 中有相邻的相同字母，<span class="math inline">\(S\)</span> 能够变成 <span class="math inline">\(T\)</span>​ 当且仅当：</p>
<ul>
<li>存在一种将 <span class="math inline">\(S\)</span>​ 划分为 <span class="math inline">\(|T|\)</span>​ 段的方式，设 <span class="math inline">\(S\)</span>​ 被划分成了 <span class="math inline">\(S_1,S_2,\cdots,S_{|T|}\)</span>​，<span class="math inline">\(T\)</span>​ 中每个字母分别为 <span class="math inline">\(T_1,T_2,\cdots,T_{|T|}\)</span>​。</li>
<li>满足 <span class="math inline">\(\forall i,p(S_i)=p(T_i)\)</span>。</li>
</ul>
</blockquote>
<p>必要性显然，下面证明充分性：</p>
<ul>
<li>假设存在一组满足上述条件的划分 <span class="math inline">\((S_1,S_2,\cdots,S_{|T|})\)</span>​。</li>
<li>将 <span class="math inline">\(S_1,S_2,\cdots,S_{|T|-1}\)</span> 的长度最小化得到新的划分 <span class="math inline">\((S_1&#39;,S_2&#39;,\cdots,S_{|T|}&#39;)\)</span>​。</li>
<li>由于最小化，容易发现 <span class="math inline">\(S_1,S_2,\cdots,S_{|T|-1}\)</span>​ 已经满足了引理一。</li>
<li>此时 <span class="math inline">\(S_{|T|}\)</span> 有可能不合法，比如 <span class="math inline">\(S_{|T|}=abab\cdots aba\)</span>，由于不合法时 <span class="math inline">\(|T|&gt;1\)</span>，可以让 <span class="math inline">\(S_{|T|}\)</span> 只保留最后一个字母，把前面的部分扔给 <span class="math inline">\(S_{|T|-1}\)</span>，于是 <span class="math inline">\(T\)</span> 删去最后一个字母对于 <span class="math inline">\(S\)</span>​ 删去最后一个字母满足引理二，故 <span class="math inline">\(S\)</span> 可以变成 <span class="math inline">\(T\)</span>。</li>
</ul>
<p>有了引理二就很好做了，特判掉 <span class="math inline">\(S\)</span> 中没有相邻的相同字母的情况，容易用一个自动机来判断 <span class="math inline">\(T\)</span>​ 是否合法，计数可以在自动机上 <code>DP</code>。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="gym101667g">Gym101667G</h3>
<p>如果两个楼梯一个朝上一个朝下，那么就没有封闭区域，如果两个朝下可以对称一下，变成两个都朝上的情况。</p>
<p>可以看出一个封闭区域开始的标志是 L 横线和 U 竖线相交，结束的标志是 U 横线和 L 竖线相交。考虑用扫描线来求出每一个封闭区域，从左到右处理每一条竖线，并维护变量 <code>isRegion</code> 表示当前竖线是否经过一个封闭区域，<code>area</code> 表示当前区域的面积：</p>
<ul>
<li>当 <code>isRegion</code> 为真时将 <code>area</code> 加上当前竖线和上一条竖线之间矩形的面积。</li>
<li>当一个封闭区域开始时清零 <code>area</code>。</li>
<li>当一个封闭区域结束时，答案累加上 <code>area</code>。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<figure>
<img src="https://i.loli.net/2021/09/08/a4fEq6tJWRbrxDy.png" alt=".png" /><figcaption aria-hidden="true">.png</figcaption>
</figure>
<h3 id="gym101667j">Gym101667J</h3>
<p>完美匹配的存在性容易想到 Hall 定理，设 <span class="math inline">\(f(S)\)</span> 表示与点集 <span class="math inline">\(S\)</span> 距离恰好等于 <span class="math inline">\(1\)</span> 的点集，问题转化为判定： <span class="math display">\[
\forall |S|\le\frac n2,|T|=\frac n2,S \cap T=\varnothing\\
|f(S)\cap T| \ge |S|
\]</span> 由于 <span class="math inline">\(|f(S)\cap T|\)</span> 最小值为 <span class="math inline">\(|f(S)|+|S|-\frac n2\)</span>，条件改写为 <span class="math inline">\(|f(S)|\ge\frac n2\)</span>。</p>
<p>考虑求 <span class="math inline">\(\min_{|S|\le \frac n2}|f(S)|\)</span>，事实上这就是图的最小点割（删去最少的点使图不连通）：</p>
<ul>
<li><span class="math inline">\(f(S)\)</span> 是 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(V-S-f(S)\)</span> 之间的一组点割。</li>
<li>任意一组点割 <span class="math inline">\(T\)</span> 割出来的多个连通块都有一个点数不超过 <span class="math inline">\(\frac n2\)</span>，设这个连通块的点集为 <span class="math inline">\(S\)</span>，那么 <span class="math inline">\(|f(S)|\le |T|\)</span>。</li>
</ul>
<p>求最小点割就是每对点都求一遍最小割：</p>
<ul>
<li>把每个点 <span class="math inline">\(u\)</span> 拆成 <span class="math inline">\(\text{in}_u\)</span> 和 <span class="math inline">\(\text{out}_u\)</span>。</li>
<li><span class="math inline">\(\text{in}_u\)</span> 向 <span class="math inline">\(\text{out}_u\)</span> 连一条代价为 <span class="math inline">\(1\)</span> 的边。</li>
<li>对于原图中的边 <span class="math inline">\((u,v)\)</span>，<span class="math inline">\(\text{out}_u\)</span> 向 <span class="math inline">\(\text{in}_v\)</span>，<span class="math inline">\(\text{out}_v\)</span> 向 <span class="math inline">\(\text{in}_u\)</span> 分别连一条代价为 <span class="math inline">\(\infty\)</span> 的边。</li>
<li>枚举两个不同的点 <span class="math inline">\(u,v\)</span>，用 <span class="math inline">\(\text{out}_u\)</span> 到 <span class="math inline">\(\text{in}_v\)</span> 的最小割更新答案。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n^2\cdot flow)\)</span>。</p>
<p><del>负</del>优化：注意到如果最小点割小于 <span class="math inline">\(\frac n2\)</span>，那么不在割中的点就超过一半，每次随机选取一个点 <span class="math inline">\(u\)</span>，枚举点 <span class="math inline">\(v\)</span>，求 <span class="math inline">\(\text{out}_u\)</span> 到 <span class="math inline">\(\text{in}_v\)</span> 的最小割，都有大半的概率求出最优解，如果随机 <span class="math inline">\(k\)</span> 次，复杂度为 <span class="math inline">\(O(nk\cdot flow)\)</span>。</p>
<h3 id="abc215h">ABC215H</h3>
<p>如何判定当前的卷心菜是否能满足所有公司？</p>
<ul>
<li><span class="math inline">\(S\)</span> 向卷心菜 <span class="math inline">\(i\)</span> 连容量为 <span class="math inline">\(A_i\)</span> 的边。</li>
<li>公司 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(T\)</span> 连容量为 <span class="math inline">\(B_i\)</span> 的边。</li>
<li>如果 <span class="math inline">\(c_{i,j}=1\)</span>，那么卷心菜 <span class="math inline">\(i\)</span> 向公司 <span class="math inline">\(j\)</span> 连容量为 <span class="math inline">\(\infty\)</span> 的边。</li>
<li><span class="math inline">\(\max flow=\sum_{i=1}^mB_i\)</span>。</li>
</ul>
<p>也等价于 <span class="math inline">\(T\)</span> 的所有入边不是最小割。由于 <span class="math inline">\(S\)</span> 的出边很少，考虑枚举最小割中有哪些 <span class="math inline">\(S\)</span> 的出边，假设这些边为 <span class="math inline">\(mask\)</span>，割掉 <span class="math inline">\(mask\)</span> 后有一些 <span class="math inline">\(T\)</span> 的入边就不需要割了，假设这些边的容量和为 <span class="math inline">\(sum\)</span>，那么需要吃点的卷心菜数量就是 <span class="math inline">\(\sum_{i\in mask}A_i-sum+1\)</span>，要求 <span class="math inline">\(sum&gt;0\)</span>。</p>
<p>这时就可以解决第一问了，考虑对于所有 <span class="math inline">\(mask\)</span>，怎么求它们的 <span class="math inline">\(sum\)</span>，注意到 <span class="math inline">\(B_i\)</span> 贡献给 <span class="math inline">\(mask\)</span> 的条件是 <span class="math inline">\(mask\)</span> 包含所有能供应给公司 <span class="math inline">\(i\)</span> 的卷心菜，可以用子集前缀和（<code>FMT</code>）求出。然后枚举 <span class="math inline">\(mask\)</span> 用 <span class="math inline">\(\sum_{i\in mask}A_i-sum+1\)</span> 更新第一问的答案即可。</p>
<p>第二问还要进一步分析，为了不算重，我们枚举一个 <span class="math inline">\(mask\)</span> 表示被吃的卷心菜品种的集合，一个 <span class="math inline">\(mask\)</span> 可行当前仅当存在一个取到第一问答案的 <span class="math inline">\(S\)</span>，使得 <span class="math inline">\(mask\subseteq S\)</span>，这个同样可以用 <code>FMT</code> 做。设第一问答案为 <span class="math inline">\(ans\)</span>，最后是对于一个 <span class="math inline">\(mask\)</span>，求有多少种从 <span class="math inline">\(mask\)</span> 中吃掉 <span class="math inline">\(ans\)</span> 个卷心菜的方式，满足 <span class="math inline">\(mask\)</span> 中的每种卷心菜至少被吃一个。容易想到容斥，钦定一些卷心菜品种不吃，然后不考虑每种卷心菜必吃的限制，但对每个 <span class="math inline">\(mask\)</span> 都通过容斥来计算复杂度高达 <span class="math inline">\(O(3^n)\)</span>。</p>
<p>设 <span class="math inline">\(f_S\)</span> 表示有多少种从 <span class="math inline">\(S\)</span> 中吃掉 <span class="math inline">\(ans\)</span> 个卷心菜的方式，满足 <span class="math inline">\(mask\)</span> 中的每种卷心菜至少被吃一个，发现 <span class="math display">\[
\sum_{T\subseteq S}f_T=\binom{\sum_{i\in S}A_i}{ans}
\]</span> 对右边做 <code>IFMT</code> 就可以求得 <span class="math inline">\(f\)</span> 数组。</p>
<p>复杂度 <span class="math inline">\(O(n2^n+nm)\)</span>。</p>
<h3 id="agc020e">AGC020E</h3>
<p>先考虑对于一个串 <span class="math inline">\(S\)</span> 如何单独计算答案，这个不难，容易想到用区间 <code>DP</code> 做。设 <span class="math inline">\(f_{l,r}\)</span> 表示子串 <span class="math inline">\([l,r]\)</span> 的改写方案数，转移分两种：</p>
<ul>
<li><span class="math inline">\(s_l\)</span> 没有参与改写，贡献为 <span class="math inline">\(f_{l+1,r}\)</span>。</li>
<li><span class="math inline">\(s_l\)</span> 参与改写了，枚举最外层的覆盖 <span class="math inline">\(s_l\)</span> 的改写：周期 <span class="math inline">\(T\)</span> 和循环次数 <span class="math inline">\(i&gt;1\)</span>，如果合法，则贡献为 <span class="math inline">\(f_{l,l+T-1}\cdot f_{l+Ti,r}\)</span>。</li>
</ul>
<p>当尝试用区间 <code>DP</code> 做原问题的时候，发现做不了，因为当 <span class="math inline">\(s_l\)</span> 参与改写时，原来的 <span class="math inline">\(f_{l,l+T-1}\)</span> 不再是一个区间的 <code>DP</code> 值。详细地说，设 <span class="math inline">\(f(s)\)</span> 表示字符串 <span class="math inline">\(s\)</span> 的答案（子集的改写方案数总和），设 <span class="math inline">\(suf(i)\)</span> 表示 <span class="math inline">\(s\)</span> 从 <span class="math inline">\(s_i\)</span> 开始的后缀，转移为两种：</p>
<ul>
<li><p>第一个字符没有参与改写，贡献为 <span class="math inline">\((s_0+1)f(suf(1))\)</span>。</p></li>
<li><p>第一个字符参与了，枚举最外层的覆盖 <span class="math inline">\(s_l\)</span> 的改写：周期 <span class="math inline">\(T\)</span> 和循环次数 <span class="math inline">\(i&gt;1\)</span>，由于每个周期内要相等，所有子集的限制要叠加，设 <span class="math inline">\(s[l,r]\)</span> 表示 <span class="math inline">\(s\)</span> 的第 <span class="math inline">\(l\)</span> 个字符到第 <span class="math inline">\(r\)</span> 个字符的子串，设 <span class="math display">\[
t=s[0,T-1]\&amp;s[T,2T-1]\&amp;\cdots\&amp;s[T(i-1),Ti-1](\&amp;\ is\ \text{bitand})
\]</span> 那么贡献为 <span class="math inline">\(f(t)\cdot f(suf(Ti))\)</span>。</p></li>
</ul>
<p>这里的复杂度上限看起来是 <span class="math inline">\(O(2^{n+1})\)</span>，这个题最重要的地方就是，你要看出来这个做法其实是 <span class="math inline">\(O(能过)\)</span> 的，进而分析出其真正的复杂度，而不是被假上限给吓跑了。</p>
<p>下面证明，有一个上界是 <span class="math inline">\(O(n^3+2^{\frac n8})\)</span>。首先长度小于等于 <span class="math inline">\(\frac n8\)</span> 的串最多有 <span class="math inline">\(2^{\frac n8}\)</span> 个，长度大于等于 <span class="math inline">\(\frac n8\)</span> 的串最多被压缩两次（因为每压缩一次长度减半），只有三种压缩方式：</p>
<ul>
<li>先选择一个子段划分成 <span class="math inline">\(2\)</span> 段，再选择一个子段划分成 <span class="math inline">\(2\)</span> 段。</li>
<li>先选择一个子段划分成 <span class="math inline">\(2\)</span> 段，再选择一个子段划分成 <span class="math inline">\(3\)</span> 段。</li>
<li>先选择一个子段划分成 <span class="math inline">\(3\)</span> 段，再选择一个子段划分成 <span class="math inline">\(2\)</span> 段。</li>
</ul>
<p>显然第一种压缩方式可以得到的串是最多的，考虑第一种压缩方式得到的串是怎样的，形如：</p>
<p><span class="math inline">\(s[a,a+k-1]\&amp;s[a+k,a+2k-1]\&amp;s[b,b+k-1]\&amp;s[b+k,b+2k-1]\)</span></p>
<p>显然它是由 <span class="math inline">\(a,b,k\)</span> 三个参数决定的，故数量是 <span class="math inline">\(O(n^3)\)</span>，因此三种压缩方式的总和也是 <span class="math inline">\(O(n^3)\)</span>。</p>
<p>另外，通过打表可以求出长度大于 <span class="math inline">\(12\)</span> 的串更为精准的上界为 <span class="math inline">\(41703\)</span>。</p>
<h3 id="cf1562e">CF1562E</h3>
<p>先分析最长上升子序列有什么性质，假设最长上升子序列为 <span class="math display">\[
s[l_1,r_1],s[l_2,r_2],\cdots,s[l_k,r_k]
\]</span> 比较显然的是对于每个 <span class="math inline">\(l\)</span>，选择的 <span class="math inline">\(r\)</span> 是一个区间。更强的结论是存在一组最优解满足对于每个 <span class="math inline">\(l\)</span>，选择的 <span class="math inline">\(r\)</span> 是一个后缀。</p>
<p>反证法：假设对于一个 <span class="math inline">\(l\)</span>，选择的 <span class="math inline">\(r\in[r_1,r_2]\)</span>，其中 <span class="math inline">\(r_2&lt;n\)</span>，<span class="math inline">\(s[l,r_2]\)</span> 之后的子串为 <span class="math inline">\(s[l&#39;,r&#39;]\)</span>。如果 <span class="math inline">\(s[l,r_2+1]&lt;s[l&#39;,r&#39;]\)</span>，直接在 <span class="math inline">\(s[l,r_2]\)</span> 后插入 <span class="math inline">\(s[l,r_2+1]\)</span>，得到一组更优的解。否则 <span class="math inline">\(s[l,r_2]&lt;s[l&#39;,r&#39;]\le s[l,r_2+1]\)</span>，说明 <span class="math display">\[
s[l&#39;,l&#39;+r_1-l]=s[l,r_1]\\
s[l&#39;,l&#39;+r_1+1-l]=s[l,r_1+1]\\
s[l&#39;,l&#39;+r_1+2-l]=s[l,r_1+2]\\
\cdots\\
s[l&#39;,l&#39;+r_2-l]=s[l,r_2]
\]</span> 于是可以用前者们一一替换后者们，得到一组不存在 <span class="math inline">\(l\)</span> 作为左端点的子串的解。</p>
<p>然后就可以 <code>DP</code> 了，设 <span class="math inline">\(f_i\)</span> 表示以 <span class="math inline">\(s[i,n]\)</span> 结尾的最长上升子序列，转移为 <span class="math display">\[
f_i=\max_{j&lt;i\land s[j,n]&lt;s[i,n]}f_j+n-\text{lcp}(s[i,n],s[j,n])+1
\]</span> 可以预处理 <span class="math inline">\(\text{lcp}(s[i,n],s[j,n])\leftarrow \text{lcp}(s[i+1,n],s[j+1,n])\)</span>，复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h4 id="优化">优化</h4>
<p>可以优化到 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>首先是 <code>LCP</code> 怎么处理，通常是使用后缀数组的 <code>height</code> 数组，这里也可以这么处理。</p>
<p>求出后缀数组 <span class="math inline">\(SA\)</span> 和 <code>height</code> 数组，转移为 <span class="math display">\[
f_{SA_i}=\max_{j&lt;i \land SA_j&lt;SA_i}f_{SA_j}+\max_{k=j+1}^in-height_k+1
\]</span> 注意关于 <code>height</code> 的那项是一个后缀 <span class="math inline">\(\max\)</span>，考虑单调栈维护，栈内维护两元组 <span class="math inline">\((v,S)\)</span>，每次将 <span class="math inline">\((n-height_{i+1}+1,\{i\})\)</span> 压栈。假设栈顶元素为 <span class="math inline">\((v_1,S_1)\)</span>，下一个元素为 <span class="math inline">\((v_2,S_2)\)</span>，如果 <span class="math inline">\(v_1\ge v_2\)</span>，就把这两个元素合并成 <span class="math inline">\((v_1,S_1\cup S_2)\)</span>。</p>
<p>在插入 <span class="math inline">\(i\)</span> 个元素后，就可以这样计算 <span class="math inline">\(f_{i+1}\)</span>：遍历栈内每个三元组 <span class="math inline">\((v,S)\)</span>，用 <span class="math inline">\(\max_{j \in S\land SA_j\le SA_i}+v\rightarrow f_{SA_{i+1}}\)</span>。但栈内元素可能很多，不能全部遍历，考虑把 <span class="math inline">\(|S|\le \sqrt n\)</span> 的栈元素的贡献用一个数据结构 <span class="math inline">\(A\)</span> 一起维护，每个 <span class="math inline">\(|S|&gt;\sqrt n\)</span> 的元素用数据结构 <span class="math inline">\(B\)</span> 单独维护，这样就只需要遍历最多 <span class="math inline">\(\sqrt n\)</span> 个 <span class="math inline">\(|S|&gt;\sqrt n\)</span> 的栈元素，即在 <span class="math inline">\(A\)</span> 中查询一次前缀 <span class="math inline">\(\max\)</span>，<span class="math inline">\(B\)</span> 中查询 <span class="math inline">\(\sqrt n\)</span> 次前缀 <span class="math inline">\(\max\)</span>。</p>
<p>元素合并的时候需要分类维护：</p>
<ul>
<li>当 <span class="math inline">\(|S_1|+|S_2|\le \sqrt n\)</span> 时，相当于把 <span class="math inline">\(S_2\)</span> 的贡献整体加上一个正数，可以在 <span class="math inline">\(A\)</span> 中进行 <span class="math inline">\(|S_2|\)</span> 次增大修改操作，这类操作总共不超过 <span class="math inline">\(n\sqrt n\)</span> 次。</li>
<li>当 <span class="math inline">\(|S_1|&gt;\sqrt n\land |S_2|\le \sqrt n\)</span> 时，在 <span class="math inline">\(B\)</span> 中进行 <span class="math inline">\(|S_2|\)</span> 次插入新元素，这类操作总共不超过 <span class="math inline">\(n\)</span> 次。</li>
<li>当 <span class="math inline">\(|S_1|,|S_2|&gt;\sqrt n\)</span> 或 <span class="math inline">\(|S_1|,|S_2|\le \sqrt n\land |S_1|+|S_2|&gt;\sqrt n\)</span> 时，用 <span class="math inline">\(|S_1|+|S_2|\)</span> 个元素重构一个 <span class="math inline">\(B\)</span>，这类操作总共不超过 <span class="math inline">\(\sqrt n\)</span> 次。</li>
</ul>
<p>综上，当 <span class="math inline">\(A\)</span> 做到 <span class="math inline">\(O(1)\)</span> 修改，<span class="math inline">\(O(\sqrt n)\)</span> 查询，<span class="math inline">\(B\)</span> 做到 <span class="math inline">\(O(\sqrt n)\)</span> 修改，<span class="math inline">\(O(1)\)</span> 查询时，复杂度为 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>因为修改是增大值，查询是前缀 <span class="math inline">\(\max\)</span>，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 都可以通过分块实现。</p>
<h3 id="cf1562f">CF1562F</h3>
<blockquote>
<p>有个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span>，元素两两不同且值域连续，但你不知道这个序列，每次可以询问两个不同数的 <span class="math inline">\(\text{lcm}\)</span>，最多使用 <span class="math inline">\(n+5000\)</span> 次询问求出 <span class="math inline">\(A\)</span>。</p>
<p><span class="math inline">\(n\le 10^5,A_i\le 2\cdot 10^5\)</span></p>
</blockquote>
<p>如果 <span class="math inline">\(\gcd(a,b)=1\)</span>，那么 <span class="math inline">\(\text{lcm}(a,b)=ab\)</span>，如果求出了 <span class="math inline">\(A\)</span> 序列中最大的质数 <span class="math inline">\(p\)</span>，就只需要 <span class="math inline">\(n-1\)</span> 次询问就可以求出 <span class="math inline">\(A\)</span>。</p>
<p>先考虑 <span class="math inline">\(p\)</span> 存在的情况，怎么求出 <span class="math inline">\(p\)</span> 和它的位置？询问 <span class="math inline">\(\text{lcm}(A_1,A_2),\text{lcm}(A_2,A_3),\text{lcm}(A_3,A_4),\cdots,\text{lcm}(A_{n-1},n)\)</span>，所有质因子中最大的就是 <span class="math inline">\(p\)</span>，同时也可以推断出 <span class="math inline">\(p\)</span> 的位置。然后再进行 <span class="math inline">\(n-1\)</span> 次询问就求出了 <span class="math inline">\(A\)</span>，询问次数为 <span class="math inline">\(2n-2\)</span>，可以处理 <span class="math inline">\(100&lt;n\le7500\)</span>。</p>
<p>再分别考虑 <span class="math inline">\(n\le 100\)</span> 和 <span class="math inline">\(n&gt;7500\)</span> 的情况。</p>
<p><span class="math inline">\(n\le 100\)</span> 可以先两两询问 <span class="math inline">\(\text{lcm}\)</span>，再逐个确定。当 <span class="math inline">\(n&gt;3\)</span> 时至少有两个奇数，根据两个奇数的 <span class="math inline">\(\text{lcm}\)</span> 为奇数就可以确定所有数的奇偶性，再取 <span class="math inline">\(\text{lcm}\)</span> 中最大的一个，它一定是 <span class="math inline">\(\max A_i(\max A_i-1)\)</span>，结合奇偶性就可以确定最大的 <span class="math inline">\(A_i\)</span>，然后删除最大值，重复上述过程，直到 <span class="math inline">\(n=3\)</span> 时，分类讨论即可。</p>
<p>当 <span class="math inline">\(n&gt;7500\)</span> 时需要用不超过 <span class="math inline">\(5000\)</span> 次询问求出 <span class="math inline">\(A\)</span> 序列中最大的质数 <span class="math inline">\(p\)</span>，然而比较困难，考虑不找最大的质数，找一个大于 <span class="math inline">\(450\)</span> 的质数 <span class="math inline">\(p&#39;\)</span> 就行了。</p>
<p>考虑随机询问 <span class="math inline">\(\text{lcm}(A_i,A_j)\)</span>，如果它是两个大于 <span class="math inline">\(450\)</span> 的质数 <span class="math inline">\(p,q\)</span> 的乘积，那么 <span class="math inline">\(A_i,A_j\)</span> 一定就是 <span class="math inline">\(p,q\)</span>，考虑进一步确定 <span class="math inline">\(A_i\)</span>，随机一个 <span class="math inline">\(k\)</span>，如果 <span class="math inline">\(p\not|\text{lcm}(A_i,A_k)\)</span> 说明 <span class="math inline">\(A_i=p\)</span>，如果 <span class="math inline">\(q\not|\text{lcm}(A_j,A_k)\)</span> 说明 <span class="math inline">\(A_i=q\)</span>，期望的总随机次数是 <span class="math inline">\(O(\ln^2n)\)</span>。</p>
<p>考虑 <span class="math display">\[
\text{lcm}(p&#39;,x)=
\begin{cases}
x&amp;(x|p&#39;)\\
xp&#39;&amp;(x\not|p&#39;)
\end{cases}
\]</span> 如果 <span class="math inline">\(\text{lcm}(p&#39;,x)&gt;2\cdot 10^5\)</span> 就说明 <span class="math inline">\(x\not|p&#39;\)</span>，可以确定 <span class="math inline">\(x\)</span> 的值，这样至少可以确定 <span class="math inline">\(n-900\)</span> 个数，并且最大的质数 <span class="math inline">\(p\)</span> 一定被确定了，最后再用 <span class="math inline">\(p\)</span> 和剩下的数询问即可。</p>
<h3 id="auoj1760">AUOJ1760</h3>
<blockquote>
<p>有 <span class="math inline">\(n\)</span> 个物品，其中可能有一个次品，它的质量与其他物品有差异。你需要多次使用天平后回答谜题：是否存在次品？次品是偏轻还是偏重？称量时，在天平两边放相同数量的物品，以得知那边更重。</p>
<p>构造一个能够解决谜题且称量次数最少的<strong>固定</strong>称量方案。</p>
<p><span class="math inline">\(n \le 10^6\)</span></p>
</blockquote>
<p>考虑什么样的称量方案能够解决谜题。</p>
<p>假设称量次数为 <span class="math inline">\(m\)</span>，定义矩阵 <span class="math inline">\(A\)</span>： <span class="math display">\[
A_{i,j}=
\begin{cases}
-1 &amp;(第 j 次称量物品 i 在天平左边)\\
0 &amp;(第 j 次称量物品 i 不在天平上)\\
1 &amp;(第 j 次称量物品 i 在天平右边)
\end{cases}
\]</span> 首先怎么判断有没有次品：如果有物品没上过天平，哪无论如何都不能判断，否则可以判断，不存在次品当且仅当每次天平都平衡。</p>
<p>得到条件一：<span class="math inline">\(A_i\ne \{0,0,\cdots, 0\}\)</span>。</p>
<p>确定了有次品，怎么确定是哪一个：先考虑已知次品偏重时怎么确定，根据每次天平的倾斜情况，可以得到每次称量时次品在天平的哪一边或不在天平上，定义序列 <span class="math inline">\(B\)</span>： <span class="math display">\[
B_i=
\begin{cases}
-1 &amp;(第 i 次称量次品在天平左边)\\
0 &amp;(第 i 次称量次品不在天平上)\\
1 &amp;(第 i 次称量次品在天平右边)
\end{cases}
\]</span> 然后看 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(A_?\)</span> 相等就可以确定次品是哪一个。</p>
<p>但是并不知道次品偏重还是偏轻，上面说了假设次品偏重可以得到一个序列 <span class="math inline">\(B\)</span>，类似地假设次品偏轻可以得到一个序列 <span class="math inline">\(C\)</span>，并且满足 <span class="math inline">\(C=-B\)</span>（元素对于互为相反数），可以解决谜题的条件是 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(C\)</span> 不能同时和某个 <span class="math inline">\(A_i\)</span> 相等。</p>
<p>得到条件二：<span class="math inline">\(\forall i \ne j, A_i\ne A_j \land A_i \ne -A_j\)</span>。</p>
<p>由于每次称量时两边放相同数量的物品。</p>
<p>得到条件三：<span class="math inline">\(\forall j\in[1,m],\sum_{i=1}^nA_{i,j}=0\)</span>。</p>
<p>满足以上三个条件就已经合法了，考虑对于一个 <span class="math inline">\(m\)</span>，哪些 <span class="math inline">\(n\)</span> 可以构造出 <span class="math inline">\(A\)</span> 矩阵。</p>
<p>首先在前两个条件的限制下，<span class="math inline">\(n\)</span> 最大能取得 <span class="math inline">\(\frac{3^m-1}2\)</span>，再加上第三个限制，<span class="math inline">\(n\)</span> 还能不能取到 <span class="math inline">\(\frac{3^m-1}2\)</span>？</p>
<p>答案是否定的，因为对于所有的方案，<span class="math inline">\(\forall j\in[1,m],\sum_{i=1}^n|A_{i,j}|=3^{m-1}\)</span>。</p>
<blockquote>
<p>引理，<span class="math inline">\(m\)</span> 次称量可以解决谜题当且仅当 <span class="math inline">\(n\le \frac{3^m-3}2\)</span>。</p>
</blockquote>
<p>这样就可以求出最小的 <span class="math inline">\(m\)</span> 了，怎么求方案？</p>
<p>当 <span class="math inline">\(3|n\)</span> 时有一个简单的构造：定义 <span class="math inline">\(\text{next}(A)\)</span> 表示把序列 <span class="math inline">\(A\)</span> 每一项循环移位（<span class="math inline">\(-1\rightarrow 0,0\rightarrow 1,1\rightarrow -1\)</span>）后得到的序列，不难发现一个事实，<span class="math inline">\(A,\text{next}(A),\text{next}(\text{next}(A))\)</span> 这三个序列对应位置之和等于 <span class="math inline">\(0\)</span>。</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 -1 1</span><br><span class="line">-1 1 0 -1</span><br><span class="line">0 -1 1 0</span><br></pre></td></tr></table></figure>
<p>除去 <span class="math inline">\(\{-1,-1,\cdots,-1\}\)</span> 和 <span class="math inline">\(\{1,1,\cdots,1\}\)</span>，把每三个这样的序列分为一组，恰好可以分成 <span class="math inline">\(\frac {3^m-3}3\)</span> 组，其中两两组互相为相反序列，于是删去一 半这样的组，恰好可以得到一个合法的矩阵 <span class="math inline">\(A\)</span>。</p>
<h3 id="思路一">思路一</h3>
<p>当 <span class="math inline">\(3\not|n\)</span> 时，感觉问题非常困难，考虑模拟退火：</p>
<ul>
<li>用 <span class="math inline">\(\sum_{j=1}^m|\sum_{i=1}^nA_{i,j}|\)</span> 作为一个解的权值，问题就是求权值最小的解。</li>
<li>还是先分组，取若干个组和一个不完整的组作为初始解。</li>
<li>每次以以下方式之一生成一个新解，如果新解更优则接受新解，否则以很低的概率接受新解。
<ul>
<li>选择一个 <span class="math inline">\(i\)</span>，将 <span class="math inline">\(A_i\)</span> 替换成 <span class="math inline">\(-A_i\)</span>。</li>
<li>选择一个 <span class="math inline">\(i\)</span>，选择一个 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(-B\)</span> 都没有在 <span class="math inline">\(A\)</span> 中出现过，令 <span class="math inline">\(A_i=B\)</span>。</li>
</ul></li>
</ul>
<p>效率还行，但不稳定，对于少数 <span class="math inline">\(n\)</span> 速度极慢，<span class="math inline">\(n\le 10^4\)</span> 是完全没有问题的。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lf = <span class="keyword">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gen</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ll k = <span class="number">0x9ddfea08eb382d69</span>ull;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">3</span>) x *= k, x ^= x &gt;&gt; <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">return</span> x * k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll s = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (s += <span class="built_in">gen</span>(s)) &amp; INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">2</span>, t = <span class="number">9</span>, nw[<span class="number">15</span>], idx, A[<span class="number">2500000</span>][<span class="number">15</span>], c[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, <span class="number">4</span>) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">1</span>, m) A[idx][k] = (nw[k] + j) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(idx == t) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">-1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        nw[i] = j, <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == t) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(t - <span class="number">3</span> &gt;&gt; <span class="number">1</span> &lt; n) m++, t *= <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">wrt</span>(m, <span class="number">10</span>);</span><br><span class="line">    t = t - <span class="number">1</span> &gt;&gt; <span class="number">1</span>, <span class="built_in">dfs</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">rep</span>(j, <span class="number">1</span>, m) c[j] += A[i][j];</span><br><span class="line">    <span class="keyword">int</span> su = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) su += <span class="built_in">abs</span>(c[i]);</span><br><span class="line">    <span class="keyword">while</span>(su) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rnd</span>() % n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rnd</span>() % t &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, m) d += <span class="built_in">abs</span>(c[j] - <span class="number">2</span> * A[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(d &lt; su || <span class="built_in">rnd</span>() % n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                su = d;</span><br><span class="line">                <span class="built_in">rep</span>(j, <span class="number">1</span>, m) c[j] -= <span class="number">2</span> * A[i][j], A[i][j] *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">rnd</span>() % (t - n) + n + <span class="number">1</span>, d = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, m) d += <span class="built_in">abs</span>(c[j] - A[i][j] + A[k][j]);</span><br><span class="line">            <span class="keyword">if</span>(d &lt; su || <span class="built_in">rnd</span>() % n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                su = d;</span><br><span class="line">                <span class="built_in">rep</span>(j, <span class="number">1</span>, m) c[j] -= A[i][j] - A[k][j], <span class="built_in">swap</span>(A[i][j], A[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">per</span>(j, m, <span class="number">1</span>) v = v * <span class="number">3</span> + A[i][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">wrt</span>(v, <span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="思路二">思路二</h3>
<p>另外，还有一种优秀的乱搞做法。</p>
<ul>
<li>先分组，取若干个组和一个不完整的组作为初始解，那么 <span class="math inline">\(\forall j\in[1,m],|\sum_{i=1}^nA_{i,j}|\le 1\)</span>。</li>
<li>对于每个 <span class="math inline">\(j\)</span>，如果 <span class="math inline">\(\sum_{i=1}^nA_{i,j}=-1\)</span>，找到一个 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(A_{i,j}&lt;1\)</span> 并且将 <span class="math inline">\(A_{i,j}\)</span> 增大一后仍然合法，然后将 <span class="math inline">\(A_{i,j}\)</span> 加一。</li>
</ul>
<p>会有极个别 <span class="math inline">\(n\)</span> 求出的解不合法，<span class="math inline">\(10^6\)</span> 以内应该不会超过 <span class="math inline">\(10\)</span> 个，而且都比较小，取决于初始解（所有可以通过）。</p>
<p>结合思路一可以构造出 <span class="math inline">\(10^6\)</span> 内的所有 <span class="math inline">\(n\)</span>。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">2</span>, t = <span class="number">9</span>, nw[<span class="number">15</span>], idx, A[<span class="number">1000005</span>], c[<span class="number">15</span>], as;</span><br><span class="line"><span class="keyword">bool</span> vs[<span class="number">1600000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i) <span class="built_in">rep</span>(j, <span class="number">-1</span>, <span class="number">1</span>) &#123; nw[i] = j, <span class="built_in">dfs</span>(i - <span class="number">1</span>); <span class="keyword">if</span>(idx == n) <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">per</span>(k, m, <span class="number">1</span>) x = x * <span class="number">3</span> + (j + nw[k]) % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(!x || vs[x] || idx == n) <span class="keyword">break</span>;</span><br><span class="line">        A[++idx] = x, vs[x] = vs[t - x] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, m) c[k] += (j + nw[k]) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(t - <span class="number">3</span> &gt;&gt; <span class="number">1</span> &lt; n) m++, t *= <span class="number">3</span>;</span><br><span class="line">    t--, vs[t / <span class="number">2</span>] = <span class="number">1</span>, <span class="built_in">wrt</span>(m, <span class="number">10</span>), nw[m] = <span class="number">-1</span>, <span class="built_in">dfs</span>(m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) as += <span class="built_in">abs</span>(c[i]);</span><br><span class="line">        <span class="keyword">int</span> th = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!c[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> v = A[i] / th % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">auto</span> Try = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nw = A[i] + x * th;</span><br><span class="line">                    <span class="keyword">if</span>(vs[nw]) <span class="keyword">return</span>;</span><br><span class="line">                    vs[A[i]] = vs[t - A[i]] = <span class="number">0</span>, vs[nw] = vs[t - nw] = <span class="number">1</span>;</span><br><span class="line">                    as -= <span class="built_in">abs</span>(c[j]), c[j] += x, v += x, as += <span class="built_in">abs</span>(c[j]), A[i] = nw;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">if</span>(v &lt; <span class="number">2</span> &amp;&amp; c[j] &lt; <span class="number">0</span>) <span class="built_in">Try</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(v &gt; <span class="number">0</span> &amp;&amp; c[j] &gt; <span class="number">0</span>) <span class="built_in">Try</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            th *= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">wrt</span>(A[i], <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="思路三">思路三</h3>
<p>这是官方解法，说是爬山算法，但感觉比较微妙，因为稍微扰动一下初始解就会有极个别 <span class="math inline">\(n\)</span> 跑不出来，流程是这样的：</p>
<ul>
<li><p>用 <span class="math inline">\(\sum_{j=1}^m|\sum_{i=1}^nA_{i,j}|\)</span> 作为一个解的权值，问题就是求权值最小的解。</p></li>
<li><p><span class="math inline">\(A\)</span> 矩阵初始为空，然按字典序<strong>从大到小</strong>枚举长度为 <span class="math inline">\(m\)</span>，值域为 <span class="math inline">\(\{-1,0,1\}\)</span> 的序列 <span class="math inline">\(B\)</span>，如果 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(-B\)</span> 没有在 <span class="math inline">\(A\)</span> 出现过，就把 <span class="math inline">\(B,\text{next}(B),\text{next}(\text{next}(B))\)</span> 依次加入 <span class="math inline">\(A\)</span> 末尾，加入 <span class="math inline">\(n\)</span> 行时终止。那么 <span class="math inline">\(\forall j\in[1,m],|\sum_{i=1}^nA_{i,j}|\le 1\)</span>。</p></li>
<li><p>对当前解重复进行如下修改，直到权值为 <span class="math inline">\(0\)</span>：</p>
<p>从小到大依次枚举 <span class="math inline">\(j\)</span> 和 <span class="math inline">\(i\)</span>，然后进行以下操作：</p>
<ul>
<li>如果 <span class="math inline">\(\sum_{i=1}^nA_{i,j}=-1\land A_{i,j}&lt;1\)</span>，尝试让 <span class="math inline">\(A_{i,j}\)</span> 加一。</li>
<li>如果 <span class="math inline">\(\sum_{i=1}^nA_{i,j}=1\)</span>，尝试让 <span class="math inline">\(A_{i,j}=0\)</span>。</li>
</ul></li>
</ul>
<p>实测能构造出 <span class="math inline">\(10^6\)</span> 内的所有 <span class="math inline">\(n\)</span>。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">2</span>, t = <span class="number">9</span>, nw[<span class="number">15</span>], idx, A[<span class="number">797170</span>], c[<span class="number">15</span>], as;</span><br><span class="line"><span class="keyword">bool</span> vs[<span class="number">1600000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i) <span class="built_in">per</span>(j, <span class="number">1</span>, <span class="number">-1</span>) &#123; nw[i] = j, <span class="built_in">dfs</span>(i - <span class="number">1</span>); <span class="keyword">if</span>(idx == n) <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">per</span>(k, m, <span class="number">1</span>) x = x * <span class="number">3</span> + (j + nw[k]) % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == t || vs[x] || idx == n) <span class="keyword">break</span>;</span><br><span class="line">        A[++idx] = x, vs[x] = vs[t - x] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, m) c[k] += (j + nw[k]) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(t - <span class="number">3</span> &gt;&gt; <span class="number">1</span> &lt; n) m++, t *= <span class="number">3</span>;</span><br><span class="line">    t--, vs[t / <span class="number">2</span>] = <span class="number">1</span>, <span class="built_in">wrt</span>(m, <span class="number">10</span>), nw[m] = <span class="number">1</span>, <span class="built_in">dfs</span>(m - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) as += <span class="built_in">abs</span>(c[i]);</span><br><span class="line">    <span class="keyword">while</span>(as) &#123;</span><br><span class="line">        <span class="keyword">int</span> th = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!c[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> v = A[i] / th % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">auto</span> Try = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nw = A[i] + x * th;</span><br><span class="line">                    <span class="keyword">if</span>(vs[nw]) <span class="keyword">return</span>;</span><br><span class="line">                    vs[A[i]] = vs[t - A[i]] = <span class="number">0</span>, vs[nw] = vs[t - nw] = <span class="number">1</span>;</span><br><span class="line">                    as -= <span class="built_in">abs</span>(c[j]), c[j] += x, v += x, as += <span class="built_in">abs</span>(c[j]), A[i] = nw;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">if</span>(v &lt; <span class="number">2</span> &amp;&amp; c[j] &lt; <span class="number">0</span>) <span class="built_in">Try</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(v &gt; <span class="number">0</span> &amp;&amp; c[j] &gt; <span class="number">0</span>) <span class="built_in">Try</span>(-v);</span><br><span class="line">            &#125;</span><br><span class="line">            th *= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">wrt</span>(A[i], <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="auoj1761">AUOJ1761</h3>
<blockquote>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span> （下标从 <span class="math inline">\(1\)</span> 开始）和一个长度为 <span class="math inline">\(m\)</span> 的序列 <span class="math inline">\(B\)</span>（下标从 <span class="math inline">\(0\)</span> 开始）。</p>
<p><span class="math inline">\(A\)</span> 初始全为 <span class="math inline">\(0\)</span>，每一天 <span class="math inline">\(A_i\)</span> 会增加 <span class="math inline">\(i\)</span>，在第 <span class="math inline">\(j\)</span> 天，如果 <span class="math inline">\(A_i&gt;B_{j\bmod m}\)</span>，则进行一次操作，令 <span class="math inline">\(A_i=B_{j\bmod m}\)</span>。</p>
<p><span class="math inline">\(q\)</span> 次询问，每次询问前 <span class="math inline">\(d_i\)</span> 天总共会进行多少次操作。</p>
<p><span class="math inline">\(n,m,q\le 3\cdot 10^5,d_i\le 3\cdot 10^{12},t_i\le 10^{18}\)</span></p>
</blockquote>
<p>由于 <span class="math inline">\(d_i\)</span> 很大，应该会用到操作的周期性，事实上对于每个 <span class="math inline">\(A_i\)</span>，从第一次操作它开始周期就为 <span class="math inline">\(m\)</span>。</p>
<blockquote>
<p>引理：假设在第 <span class="math inline">\(p\)</span> 天操作了 <span class="math inline">\(A_i\)</span>，那么它在第 <span class="math inline">\(p+m\)</span> 天又会被操作。</p>
</blockquote>
<p>证明：第 <span class="math inline">\(p-m\)</span> 天 <span class="math inline">\(A_i\)</span> 小于等于第 <span class="math inline">\(p\)</span> 天的 <span class="math inline">\(A_i=B_{p \bmod m}\)</span>，感性理解 <span class="math inline">\(A_i\)</span> 越小在 <span class="math inline">\(m\)</span> 天后越容易操作，第 <span class="math inline">\(p\)</span> 天操作了，第 <span class="math inline">\(p+m\)</span> 天肯定要操作。</p>
<p>设 <span class="math inline">\(A_i\)</span> 第一次操作在第 <span class="math inline">\(p_i\)</span> 天，那么在第 <span class="math inline">\(p_i,p_i+m,p_i+2m,pi+3m,\cdots\)</span> 都会操作，于是周期就是 <span class="math inline">\(m\)</span>。</p>
<p>不难发现 <span class="math inline">\(p_i\)</span> 是递减的，因为任意时刻 <span class="math inline">\(A\)</span> 序列都是递增的，每次操作的都是一段后缀。那么对于一次询问，进行过操作的 <span class="math inline">\(A_i\)</span> 是一段后缀，只要求出了 <span class="math inline">\(p_i\)</span> 就可以二分出这个后缀，下面考虑怎么求 <span class="math inline">\(p_i\)</span>。</p>
<p>设 <span class="math inline">\(pos\)</span> 表示 <span class="math inline">\(B\)</span> 中最小元素的位置，对于每个 <span class="math inline">\(i\)</span> 可以直接算出 <span class="math inline">\(A_i\)</span> 第一次被 <span class="math inline">\(B_{pos}\)</span> 操作的时间 <span class="math inline">\(T_i\)</span>，那么 <span class="math inline">\(p_i\in[T_i-m+1,T_i]\)</span>，设 <span class="math inline">\(p_i=T_i-m+k_i\)</span>，<span class="math inline">\(k_i\)</span> 就是最小的 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(ix+(T_i-m)i&gt;B_{pos+x}\)</span>，考虑在线段树上每个结点 <span class="math inline">\([l,r]\)</span> 维护 <span class="math inline">\(\min_{j=l}^rB_{pos+j}-ij\)</span>，每次只需要二分出最小的 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(\min_{j=1}^x\{B_{pos+j}-ij\}&lt;(T_i-m)i\)</span>，注意到式子是可以斜率优化的，随着 <span class="math inline">\(i\)</span> 的增大，对每个结点用一个单调队列维护下凸包。复杂度为 <span class="math inline">\(O(n\log n)\)</span>。这样就求出了 <span class="math inline">\(p_i\)</span>。</p>
<p>对于询问 <span class="math inline">\(d\)</span>，每个 <span class="math inline">\(A_i\)</span> 的贡献可以分为若干个完整周期和一个不完整周期。对于完整周期，由于周期长度为 <span class="math inline">\(m\)</span>，可以用线段树直接模拟周期中每一天的修改，然后就知道每个 <span class="math inline">\(A_i\)</span> 一个周期被清理多少次。对于不完整周期，可以把所有询问离线下来，然后用一个线段树模拟这个不完整周期，大致思路是在 <span class="math inline">\(p_i\bmod m\)</span> 天插入 <span class="math inline">\(A_i\)</span>，在 <span class="math inline">\(d\bmod m\)</span> 天进行查询，但有可能 <span class="math inline">\(d\bmod m&lt;p_i\bmod m\)</span>，所以实现上需要分类讨论一下。</p>
<h3 id="codechef-btree">CodeChef-btree</h3>
<blockquote>
<p>定义 <span class="math inline">\(S(u,k)\)</span> 表示与 <span class="math inline">\(u\)</span> 距离不超过 <span class="math inline">\(k\)</span> 的点集。</p>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，<span class="math inline">\(q\)</span> 次询问，每次询问 <span class="math inline">\(|S(u_1,k_1)\cup S(u_2,k_2)\cup S(u_3,k_3)\cup \cdots \cup S(u_{m_i},k_{m_i})|\)</span> 。</p>
<p><span class="math inline">\(n,q\le 5\cdot 10^4,\sum_{i=1}^qm_i\le 5\cdot 10^5\)</span>。</p>
</blockquote>
<p>考虑 <span class="math inline">\(|S(u,k)|\)</span> 怎么求，可以离线后点分治，也可以建出点分树在线求。</p>
<h4 id="sol-1-1">Sol 1</h4>
<p>先对 <span class="math inline">\(u_1,u_2,u_3,\cdots,u_{m_i}\)</span> 建虚树，假设虚树中非关键点的半径为 <span class="math inline">\(0\)</span>。</p>
<p>如果 <span class="math inline">\((u_1,k_1),(u_2,k_2)\)</span> 满足 <span class="math inline">\(k_1-\text{dis}(u_1,u_2)&gt;k_2\)</span>，就说明了 <span class="math inline">\(S(u_2,k_2)\subsetneq S(u_1,k_1)\)</span>，即 <span class="math inline">\(S(u_2,k_2)\)</span> 是没用的，但不能删去它，而是令 <span class="math inline">\(k_2=k_1-\text{dis}(u_1,u_2)\)</span>。</p>
<p>考虑对所有点的半径更新，直到不能更新为止，一种方法是像 <code>Dijkstra</code> 一样每次取半径最大的点更新周围点的半径，另一种做法是树形 <code>DP</code>，自底向上更新一遍，再自顶向下更新一遍。</p>
<p>然后发现一个很好的性质，记虚树点集为 <span class="math inline">\(V\)</span>，边集为 <span class="math inline">\(E\)</span>，<span class="math inline">\(u\)</span> 的半径为 <span class="math inline">\(r_u\)</span>，答案等于 <span class="math inline">\(\sum_{u\in V}|S(u,r_u)|-\sum_{(u,v)\in E}|S(u,r_u)\cap S(v,r_v)|\)</span>。证明很简单，考虑自顶向下将每个 <span class="math inline">\(S(u,r_u)\)</span> 并入，每次新增的点数为 <span class="math inline">\(|S(u,r_u)|-|S(u,r_u)\cap S(fa_u,r_{fa_u})|\)</span>。</p>
<p><span class="math inline">\(|S(u,r_u)|\)</span> 可以在点分树上查询，<span class="math inline">\(|S(u,r_u)\cap S(v,r_v)|\)</span> 是一个 <span class="math inline">\(S(w,r)\)</span>，其中 <span class="math inline">\(w\)</span> 可能是顶点，也可能是一条边的中点，如果在每条边上新建一个点，<span class="math inline">\(w\)</span> 就一定是顶点了。</p>
<p>复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>
<h4 id="sol-2-1">Sol 2</h4>
<p>答案求的是并集的大小，是 <code>bitset</code> 可以优化的。</p>
<p>注意到 <span class="math inline">\(nq \le 2.5\cdot 10^9,n\sum_{i=1}^qm_i\le 2.5\cdot 10^{10}\)</span>，一个时间复杂度 <span class="math inline">\(O(\frac{n\sum_{i=1}^qm_i}\omega)\)</span>，空间复杂度 <span class="math inline">\(O(\frac{nq}\omega)\)</span> 的算法是可以通过的。</p>
<p>怎么快速求 <span class="math inline">\(S(u,k)\)</span> 的 <code>bitset</code> 形式，希望能做到 <span class="math inline">\(O(\frac n\omega)\)</span>。</p>
<p>考虑把所有询问离线下来，在点分治的过程中每个 <span class="math inline">\(S(u,k)\)</span> 都被分解成了 <span class="math inline">\(O(\log n)\)</span> 个形如”深度不超过 <span class="math inline">\(d\)</span> 的点集”的并，如果每次都把”深度不超过 <span class="math inline">\(d\)</span> 的点集”并上去，求 <span class="math inline">\(S(u,k)\)</span> 就是 <span class="math inline">\(O(\frac{n\log n}\omega)\)</span> 的，不太行。注意到这 <span class="math inline">\(O(\log n)\)</span> 个点集的范围分别为 <span class="math inline">\(n,\frac n2,\frac n4,\frac n8,\cdots\)</span>，总和是 <span class="math inline">\(2n\)</span> 的，但每个点集编号的范围都是 <span class="math inline">\([1,n]\)</span>，每次并上去就太不优秀了，如何缩小编号的范围？只需要把所有点按照点分树的 <code>DFS</code> 序重新编号，那么每个点集编号的范围就缩小到了 <span class="math inline">\(n,\frac n2,\frac n4,\frac n8,\cdots\)</span>，每次只需要并到一个区间上，复杂度 <span class="math inline">\(O(\frac n\omega)\)</span>。</p>
<p>做法就是对每个询问开一个 <code>bitset</code>，点分治的过程中更新 <code>bitset</code> 的一个区间，答案就是对于 <code>bitset</code> 的 <code>popcount</code>，需要用 <code>unsigned long long</code> 实现 <code>bitset</code>，<code>popcount</code> 也建议手写，预处理 <span class="math inline">\([0,65536)\)</span> 内所有数的 <code>popcount</code>，把每个 <code>unsigned long long</code> 拆成四个 <span class="math inline">\([0,65536)\)</span> 内的数。</p>
<p>实测比 Sol 1 快。</p>
<h3 id="ural2118">URAL2118</h3>
<blockquote>
<p>给定前 <span class="math inline">\(k\)</span> 个字母的 <span class="math inline">\(01\)</span> 前缀编码（不存在一个编码是另一个编码的前缀）。</p>
<p>给定字符串 <span class="math inline">\(s\)</span>，设其解码后的 <span class="math inline">\(01\)</span> 串为 <span class="math inline">\(S\)</span>，求最多能将 <span class="math inline">\(S\)</span> 划分为多少段使得每一段都无法解码，无解输出 <span class="math inline">\(-1\)</span>。</p>
<p><span class="math inline">\(k \le 52, n\le 10^6\)</span></p>
</blockquote>
<p>首先考虑两种特殊情况：</p>
<ul>
<li>编码中既有 <span class="math inline">\(0\)</span>，也有 <span class="math inline">\(1\)</span>，那 <span class="math inline">\(S\)</span> 无论怎么划分都可以解码。</li>
<li>编码中既没 <span class="math inline">\(0\)</span>，也没 <span class="math inline">\(1\)</span>，那么答案为 <span class="math inline">\(|S|\)</span>。</li>
</ul>
<p>剩下的情况为：有 <span class="math inline">\(0\)</span> 无 <span class="math inline">\(1\)</span> 和有 <span class="math inline">\(1\)</span> 无 <span class="math inline">\(0\)</span>，由于对称性，只考虑有 <span class="math inline">\(0\)</span> 无 <span class="math inline">\(1\)</span>。</p>
<p>首先答案的上界为 <span class="math inline">\(1\)</span> 的个数，因为全 <span class="math inline">\(0\)</span> 的一段是可以被解码的。</p>
<p>如果最后一位为 <span class="math inline">\(1\)</span>，那么在每个 <span class="math inline">\(1\)</span> 后面断开，就可以取到这个上界。</p>
<p>如果最后一位为 <span class="math inline">\(0\)</span>，假设最后一段 <span class="math inline">\(T\)</span>，可以说明存在最优解满足 <span class="math inline">\(T\)</span> 前面是 <span class="math inline">\(1\)</span>：假设 <span class="math inline">\(T\)</span> 前面有 <strong>连续</strong> 的 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(0\)</span>，前面总共有 <span class="math inline">\(y\)</span> 个 <span class="math inline">\(1\)</span>。那么答案的上界为 <span class="math inline">\(y+1\)</span>，把这 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(0\)</span> 加入 <span class="math inline">\(T\)</span>，然后在 <span class="math inline">\(T\)</span> 前面的每个 <span class="math inline">\(1\)</span> 后面断开就可以到达这个上界。</p>
<p>如果 <span class="math inline">\(T\)</span> 前面有 <span class="math inline">\(y\)</span> 个 <span class="math inline">\(1\)</span>，最大段数就是 <span class="math inline">\(y+1\)</span>，问题就是求最大的 <span class="math inline">\(y\)</span>，假设 <span class="math inline">\(T&#39;\)</span> 是最短的无法被解码的后缀，可以说明最大的 <span class="math inline">\(y\)</span> 等于 <span class="math inline">\(T&#39;\)</span> 前面 <span class="math inline">\(1\)</span> 的个数：由于 <span class="math inline">\(|T|\ge |T&#39;|\)</span>，所以 <span class="math inline">\(y\)</span> 不会超过 <span class="math inline">\(T&#39;\)</span> 前面 <span class="math inline">\(1\)</span> 的个数，另外，令 <span class="math inline">\(T=T&#39;前面极长的一段0+T&#39;\)</span>，<span class="math inline">\(y\)</span> 就可以取到这个上界。</p>
<p>问题转化成了求 <span class="math inline">\(T&#39;\)</span>，那么 <span class="math inline">\(T&#39;\)</span> 的任何前缀都无法解码，否则 <span class="math inline">\(T&#39;\)</span> 不是最短的，记 <span class="math inline">\(suffix(i)\)</span> 表示 <span class="math inline">\(S\)</span> 长度为 <span class="math inline">\(i\)</span> 的后缀，问题就是依次判断 <span class="math inline">\(suffix(1),suffix(2),suffix(3),\cdots\)</span> 是否有前缀可以被解码，<code>AC</code> 自动机即可。</p>
<p>复杂度 <span class="math inline">\(O(nk)\)</span>。</p>
<h3 id="graph-subpaths">Graph Subpaths</h3>
<blockquote>
<p>没有提交地址。</p>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的有向无环图，再给定 <span class="math inline">\(k\)</span> 条路径，每条路径长度为 <span class="math inline">\(l_i\)</span>，一条合法路径不包含这 <span class="math inline">\(k\)</span> 条路径。</p>
<p>对于 <span class="math inline">\(i \in [2,n]\)</span>，求 <span class="math inline">\(1\rightarrow i\)</span> 的合法路径条数。</p>
<p><span class="math inline">\(n,m,\sum_{i=1}^kl_i \le 10^5\)</span></p>
</blockquote>
<h3 id="sol-1-2">Sol 1</h3>
<p>首先把所有边反向，就转化成了求 <span class="math inline">\(i\rightarrow 1\)</span> 的合法路径条数。</p>
<p>对于边 <span class="math inline">\((u,v)\)</span>，标记它的权值为 <span class="math inline">\(v\)</span>，设 <span class="math inline">\(T_i\)</span> 表示 <span class="math inline">\(i\rightarrow 1\)</span> 所有合法路径组成的 <code>trie</code>，考虑怎么按拓扑序求出每一个 <span class="math inline">\(T_u\)</span>，对于边 <span class="math inline">\((u,v)\)</span>，<span class="math inline">\(T_v\)</span> 是已经求过了，把 <span class="math inline">\(T_v\)</span> 复制到根的儿子，但这样会有一些以 <span class="math inline">\(u\)</span> 为起点的不合法路径，需要删除这些路径：从 <span class="math inline">\(T_u\)</span> 的根出发沿着不合法路径走，把以终点为根的子树删除即可。<span class="math inline">\(u\)</span> 的答案就是 <span class="math inline">\(T_u\)</span> 的叶子个数。</p>
<p>由于 <span class="math inline">\(T_u\)</span> 非常大，当然不能直接存下来，可行的方法是用可持久化的 <code>trie</code>，对于边 <span class="math inline">\((u,v)\)</span>，只需要从 <span class="math inline">\(T_u\)</span> 的根向 <span class="math inline">\(T_v\)</span> 连一条边就行了，而不用复制整棵 <span class="math inline">\(T_v\)</span>，删除子树也只需要对路径上的结点建新版本。</p>
<p>一个问题是儿子列表的维护，如果用链表维护的话，删除子树时新建的结点需要从原版本复制整个链表，复杂度可能达到 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>用主席树维护儿子列表就可以 <span class="math inline">\(O(n\log n)\)</span> 地新建结点。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="sol-2-2">Sol 2</h3>
<p>对所有路径建 <code>AC</code> 自动机，不难想到一个 <span class="math inline">\(O(n^2)\)</span> 状态的 <code>DP</code>，设 <span class="math inline">\(f_{i,u}\)</span> 表示在原图中走到 <span class="math inline">\(i\)</span>，<code>AC</code> 自动机上走到 <code>u</code>，且没有经过 <code>AC</code> 自动机上终止结点的路径条数。</p>
<p>由于 <code>AC</code> 自动机上的点对应唯一原图中的点的，所以 <code>DP</code> 状态定义成 <span class="math inline">\(f_u\)</span> 就可以转移了。</p>
<p>由于建 <code>AC</code> 自动机需要主席树，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="zoj3390">ZOJ3390</h3>
<blockquote>
<p>对于两棵树 <span class="math inline">\(T_1,T_2\)</span>，定义 <span class="math inline">\(T_1+T_2\)</span> 表示把根合并，<span class="math inline">\(T_1\cdot T_2\)</span> 表示把 <span class="math inline">\(T_1\)</span> 中每个结点换成 <span class="math inline">\(T_2\)</span>，<span class="math inline">\(T_1=T_2\)</span> 表示树同构。</p>
<p>给定树 <span class="math inline">\(A,B,C\)</span>，求 <span class="math inline">\(X,Y\)</span> 满足 <span class="math inline">\(AX+BY=C\)</span>。</p>
<p><span class="math inline">\(|A|,|B|,|C| \le 10^5\)</span></p>
</blockquote>
<p>设 <span class="math inline">\(height(T)\)</span> 表示 <span class="math inline">\(T\)</span> 的树高（最深叶子到根的距离）。</p>
<p>可以发现 <span class="math inline">\(height(T_1+T_2)=\max(height(T_1),height(T_2)),height(T_1\cdot T_2)=height(T_1)+height(T_2)\)</span>。</p>
<p>那么 <span class="math inline">\(\max(height(A)+height(X),height(B)+height(Y))=height(C)\)</span>，假设 <span class="math inline">\(height(A)+height(X)=height(C)\)</span>（另一种情况是一样的）。</p>
<p>这样就知道了 <span class="math inline">\(height(X)\)</span>，考虑怎么求 <span class="math inline">\(X\)</span>，很简单，假设 <span class="math inline">\(u\)</span> 为 <span class="math inline">\(C\)</span> 中最深叶子的 <span class="math inline">\(height(X)\)</span> 级祖先，以 <span class="math inline">\(u\)</span> 为根的子树就是 <span class="math inline">\(X\)</span>，这样就知道了 <span class="math inline">\(AX\)</span>，然后就可以求出 <span class="math inline">\(BY\)</span>，再用类似的方法就可以求出 <span class="math inline">\(Y\)</span> 了。</p>
<p>虽然思路很简单，但是有一定实现难度，求 <span class="math inline">\(BY\)</span> 时树的“减法“，以及判定答案是否合法都需要用到树哈希。</p>
<p>树哈希公式： <span class="math display">\[
f_u=1+\sum_{v\in son(u)}f_v\cdot \text{prime}(size_v)
\]</span> 其中 <span class="math inline">\(\text{prime}(i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个质数。</p>
<p><strong>注：</strong>对于两棵大小不同的树 <span class="math inline">\(T_1,T_2\)</span>，<span class="math inline">\(f_{T_1}=f_{T_2}\)</span> 是可能的，因此哈希应当和子树大小捆绑在一起。</p>
<p><code>Generator</code> ：参数 <span class="math inline">\(T,A,B,C,D\)</span> 可调，分别表示数据组数和树 <span class="math inline">\(A,X,B,Y\)</span> 的大小。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) int((x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc o * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmi(a, b) (a = min(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cma(a, b) (a = max(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ub upper_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs binary_search</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop __builtin_popcount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpop __builtin_popcountll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ctz __builtin_ctz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llctz __builtin_ctzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clz __builtin_clz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llclz __builtin_clzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> par __builtin_parity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpar __builtin_parityll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lf = <span class="keyword">double</span>;</span><br><span class="line"><span class="comment">// using P = pair&lt;int, int&gt;;</span></span><br><span class="line"><span class="keyword">using</span> V = vector&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="comment">// using cmp = complex&lt;lf&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gen</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ll k = <span class="number">0x9ddfea08eb382d69</span>ull;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">3</span>) x *= k, x ^= x &gt;&gt; <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">return</span> x * k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll s = <span class="built_in">time</span>(<span class="number">0</span>) + (ll)<span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">    <span class="keyword">return</span> (s += <span class="built_in">gen</span>(s)) &amp; INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">tmul</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>, su = n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? i : b[j] + su - <span class="number">1</span>);</span><br><span class="line">        su += m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">tplus</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? <span class="number">1</span> : b[j] + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>, A = <span class="number">5</span>, B = <span class="number">5</span>, C = <span class="number">5</span>, D = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">100000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T);</span><br><span class="line">    <span class="built_in">rep</span>(kase, <span class="number">1</span>, T) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rnd</span>() % A + <span class="number">1</span>, b = <span class="built_in">rnd</span>() % B + <span class="number">1</span>, c = <span class="built_in">rnd</span>() % C + <span class="number">1</span>, d = <span class="built_in">rnd</span>() % D + <span class="number">1</span>;</span><br><span class="line">        V t1&#123;<span class="number">0</span>&#125;, t2&#123;<span class="number">0</span>&#125;, t3&#123;<span class="number">0</span>&#125;, t4&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> get = [](V&amp; t, <span class="keyword">int</span> n) &#123; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) t.<span class="built_in">pb</span>(i &gt; <span class="number">1</span> ? <span class="built_in">rnd</span>() % (i - <span class="number">1</span>) + <span class="number">1</span> : <span class="number">0</span>); &#125;;</span><br><span class="line">        <span class="built_in">get</span>(t1, a), <span class="built_in">get</span>(t2, b), <span class="built_in">get</span>(t3, c), <span class="built_in">get</span>(t4, d);</span><br><span class="line">        V t5 = <span class="built_in">tplus</span>(<span class="built_in">tmul</span>(t1, t2), <span class="built_in">tmul</span>(t3, t4));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %llu\n&quot;</span>, a, c, t5.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> prt = [](V&amp; v) &#123; <span class="built_in">For</span>(i, <span class="number">1</span>, v.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); &#125;;</span><br><span class="line">        <span class="built_in">prt</span>(t1), <span class="built_in">prt</span>(t3), <span class="built_in">prt</span>(t5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p><code>Special judge</code>：假设保存为 <code>checker.cpp</code>，编译后在命令行中使用：<code>checker &lt;input-file&gt; &lt;output-file&gt;</code>，答案正确返回值为 <span class="math inline">\(0\)</span>，否则返回值为 <span class="math inline">\(1\)</span>，输出为第一组出错的数据。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) int((x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc o * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmi(a, b) (a = min(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cma(a, b) (a = max(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ub upper_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs binary_search</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop __builtin_popcount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpop __builtin_popcountll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ctz __builtin_ctz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llctz __builtin_ctzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clz __builtin_clz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llclz __builtin_clzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> par __builtin_parity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpar __builtin_parityll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lf = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> V = vector&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="comment">// using cmp = complex&lt;lf&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">1299709</span>;</span><br><span class="line"><span class="keyword">int</span> f[M + <span class="number">5</span>], pid, prm[N];</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">tmul</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>, su = n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? i : b[j] + su - <span class="number">1</span>);</span><br><span class="line">        su += m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">tplus</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? <span class="number">1</span> : b[j] + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> V G[])</span> </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">re</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [h, sz] = <span class="built_in">dfs</span>(v, G);</span><br><span class="line">        re.fi = (re.fi + (ll)h * prm[sz]) % <span class="number">999999937</span>;</span><br><span class="line">        re.se += sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> V&amp; t)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">1</span>, t.<span class="built_in">size</span>()) G[t[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, G).fi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(FILE* f)</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">fscanf</span>(f, <span class="string">&quot;%d&quot;</span>, &amp;x) == <span class="number">1</span> ? x : <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, M) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) prm[++pid] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i * prm[j] &lt;= M; j++) &#123;</span><br><span class="line">            f[i * prm[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prm[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *in = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>), *out = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> T = <span class="built_in">read</span>(in); T--;) &#123;</span><br><span class="line">        V t1&#123;<span class="number">0</span>&#125;, t2&#123;<span class="number">0</span>&#125;, t3&#123;<span class="number">0</span>&#125;, t4&#123;<span class="number">0</span>&#125;, t5&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> get = [](FILE* f, V&amp; t, <span class="keyword">int</span> n) &#123; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) t.<span class="built_in">pb</span>(<span class="built_in">read</span>(f)); &#125;;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">read</span>(in), b = <span class="built_in">read</span>(in), c = <span class="built_in">read</span>(in);</span><br><span class="line">        <span class="built_in">get</span>(in, t1, a), <span class="built_in">get</span>(in, t3, b), <span class="built_in">get</span>(in, t5, c);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="built_in">read</span>(out), e = <span class="built_in">read</span>(out);</span><br><span class="line">        <span class="keyword">auto</span> err = [&amp;]() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n%d %d %d\n&quot;</span>, a, b, c);</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t1[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, b) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t3[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, c) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t5[i]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!~d) <span class="built_in">err</span>();</span><br><span class="line">        <span class="built_in">get</span>(out, t2, d), <span class="built_in">get</span>(out, t4, e);</span><br><span class="line">        <span class="keyword">if</span>((ll)a * d + (ll)b * e != c &amp;&amp; <span class="built_in">Hash</span>(<span class="built_in">tplus</span>(<span class="built_in">tmul</span>(t1, t2), <span class="built_in">tmul</span>(t3, t4))) != <span class="built_in">Hash</span>(t5)) <span class="built_in">err</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="izho-2020-d1t3">IZhO 2020 D1T3</h3>
<blockquote>
<p><a href="codeforces.com/group/Uo1lq8ZyWf/contest/265564">题目链接</a></p>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span>，问有多少三元组 <span class="math inline">\((i,j,k)\)</span> 满足 <span class="math inline">\(i\le j&lt;k\)</span> 且 <span class="math inline">\([i,j]\)</span> 和 <span class="math inline">\([j+1,k]\)</span> 两个区间中数的集合相同。</p>
<p><span class="math inline">\(n \le 2\cdot 10^5\)</span></p>
</blockquote>
<p>记 <span class="math inline">\(prev_i\)</span> 表示 <span class="math inline">\(A_i\)</span> 上一次出现的位置，<span class="math inline">\(next_i\)</span> 表示 <span class="math inline">\(A_i\)</span> 下一次出现的位置。</p>
<p>三元组 <span class="math inline">\((i,j,k)\)</span> 合法的充要条件为：</p>
<ul>
<li>区间 <span class="math inline">\([j+1,k]\)</span> 中的数都在 <span class="math inline">\([i,j]\)</span> 中出现，即 <span class="math inline">\(i \le \min prev_{j+1\cdots i}\)</span>，相当于 <span class="math inline">\(i\)</span> 有个上界 <span class="math inline">\(R_{j,k}=\min prev_{j+1\cdots k}\)</span>。</li>
<li>区间 <span class="math inline">\([i,j]\)</span> 中的数都在 <span class="math inline">\([j+1,k]\)</span> 中出现，即 <span class="math inline">\(\max next_{i\cdots j}\le k\)</span>，相当于 <span class="math inline">\(i\)</span> 有个下界 <span class="math inline">\(L_{j,k}\)</span>，其中 <span class="math inline">\(L_{j,k}\)</span> 是最小的 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(\max next_{i\cdots j}\le k\)</span>。</li>
</ul>
<p>那么 <span class="math inline">\((j,k)\)</span> 的贡献就是 <span class="math inline">\(\max(R_{j,k}-L_{j,k}+1,0)\)</span>，考虑只枚举 <span class="math inline">\(k\)</span>，用数据结构动态维护 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span>。</p>
<p>先考虑 <span class="math inline">\(L_{j,k}\)</span> 和 <span class="math inline">\(R_{j,k}\)</span> 分别怎么维护。</p>
<p>对于 <span class="math inline">\(R_{j,k}=\min prev_{j+1\cdots k}\)</span>，这是 <span class="math inline">\(prev\)</span> 数组上的后缀 <span class="math inline">\(\min\)</span>，当 <span class="math inline">\(k\rightarrow k+1\)</span> 时，<span class="math inline">\(R_{j,k}\)</span> 发生的改变是一个后缀变成了 <span class="math inline">\(prev_{k+1}\)</span>，具体可以用单调栈求出这个后缀，然后区间赋值。</p>
<p>对于 <span class="math inline">\(L_{j,k}\)</span>，直接分析 <span class="math inline">\(k\rightarrow k+1\)</span> 不太行，换一个角度考虑对于一个 <span class="math inline">\(j\)</span>，<span class="math inline">\(L_{j,k}\)</span> 和 <span class="math inline">\(k\)</span> 的关系，<span class="math inline">\(\max next_{i\cdots j}\)</span> 是 <span class="math inline">\(next\)</span> 数组上的后缀 <span class="math inline">\(\max\)</span>，将 <span class="math inline">\(next_{1\cdots j}\)</span> 依次插入单调栈，设单调栈中元素分别为 <span class="math inline">\(next_{i_1},next_{i_2},next_{i_3},\cdots,next_{i_k}\)</span>：</p>
<ul>
<li>当 <span class="math inline">\(k\in[j+1,next_{i_k}-1]\)</span> 时，<span class="math inline">\(L_{j,k}=\infty\)</span>。</li>
<li>当 <span class="math inline">\(k\in [next_{i_k},next_{i_{k-1}-1}]\)</span>，<span class="math inline">\(L_{j,k}=i_{k-1}+1\)</span>。</li>
<li><span class="math inline">\(\cdots\)</span></li>
<li>当 <span class="math inline">\(k\in [next_{i_1},n]\)</span>，<span class="math inline">\(L_{j,k}=1\)</span>。</li>
</ul>
<p>综上，单调栈元素 <span class="math inline">\(i_x\)</span> 意味着当 <span class="math inline">\(k\in [next_{i_x},next_{i_{x-1}}-1]\)</span>，<span class="math inline">\(L_{j,k}=i_{x-1}+1\)</span>，假设插入 <span class="math inline">\(next_y\)</span> 后 <span class="math inline">\(next_{i_x}\)</span> 被弹掉了，那么当 <span class="math inline">\(j\in [i_x,y-1],k\in [next_{i_x},next_{i_{x-1}}-1]\)</span> 时，<span class="math inline">\(L_{j,k}=i_{x-1}+1\)</span>，相当于 <span class="math inline">\(k\)</span> 从 <span class="math inline">\(next_{i_x}-1\rightarrow next_{i_x}\)</span> 时，对 <span class="math inline">\(L_{i_x\cdots y-1,k}\)</span> 进行区间赋值为 <span class="math inline">\(i_x+1\)</span>。每个单调栈元素意味着一次区间赋值，所以只需要 <span class="math inline">\(n\)</span> 次区间赋值就可以维护 <span class="math inline">\(L_{j,k}\)</span>。</p>
<p>但维护的是 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span>，相当于夹在两条递增折线之间的面积。由于 <span class="math inline">\(L_{j,k}\)</span> 和 <span class="math inline">\(R_{j,k}\)</span> 都是随着 <span class="math inline">\(k\)</span> 增大而减小的，所以每次赋值都是减小。比如将 <span class="math inline">\(R_{l\cdots r,k}\)</span> 改为 <span class="math inline">\(v\)</span>，如果 <span class="math inline">\(v \le \min L_{l\cdots r,k}\)</span>，这一段的面积就是 <span class="math inline">\(0\)</span>，如果 <span class="math inline">\(v \ge \max L_{l\cdots r,k}\)</span>，这一段的面积就是 <span class="math inline">\(\sum_{j=l}^rR_{j,k}-\sum_{j=l}^rL_{j,k}+(r-l+1)\)</span>，否则可以二分一个分界点 <span class="math inline">\(x\)</span>，使得 <span class="math inline">\(\forall j \in[l,x], v\ge L_{j,k},\forall j\in[x+1,r],v\le L_{j,k}\)</span>，分界点左右两段分别对应上述两种情况。所以只要维护了 <span class="math inline">\(L_{j,k},R_{j,k}\)</span> 的区间 <span class="math inline">\(\min,\max\)</span> 和 <span class="math inline">\(sum\)</span> 就可以维护 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span> 了。</p>
<p>在实现上并不需要求 <span class="math inline">\(x\)</span>，假设当前要将 <span class="math inline">\(L_{ql\cdots qr,k}\)</span> 赋值为 <span class="math inline">\(v\)</span>，当前线段树结点区间为 <span class="math inline">\([l,r]\)</span>，一般区间赋值是在 <span class="math inline">\(ql\le l\land r \le qr\)</span> 时停止递归，这里把条件改成 <span class="math inline">\(ql\le l\land r \le qr \land (v \le \min L_{l\cdots r,k}\lor v \ge \max L_{l\cdots r,k})\)</span> 才可以方便地维护 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span>，由于只有一个分界点，所以复杂度不变。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>，实现难度较大，附上代码：</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc o * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, rc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], pre[N], nxt[N], L[N];</span><br><span class="line">vector&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vl[N], vr[N];</span><br><span class="line"><span class="keyword">int</span> tagL[N * <span class="number">4</span>], minL[N * <span class="number">4</span>], maxL[N * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> tagR[N * <span class="number">4</span>], minR[N * <span class="number">4</span>], maxR[N * <span class="number">4</span>];</span><br><span class="line">ll sum[N * <span class="number">4</span>], sumL[N * <span class="number">4</span>], sumR[N * <span class="number">4</span>], as;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    sum[o] = sum[lc] + sum[rc];</span><br><span class="line">    sumL[o] = sumL[lc] + sumL[rc];</span><br><span class="line">    sumR[o] = sumR[lc] + sumR[rc];</span><br><span class="line">    minL[o] = <span class="built_in">min</span>(minL[lc], minL[rc]);</span><br><span class="line">    minR[o] = <span class="built_in">min</span>(minR[lc], minR[rc]);</span><br><span class="line">    maxL[o] = <span class="built_in">max</span>(maxL[lc], maxL[rc]);</span><br><span class="line">    maxR[o] = <span class="built_in">max</span>(maxR[lc], maxR[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushL</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    tagL[o] = minL[o] = maxL[o] = v, sumL[o] = v * (r - l + <span class="number">1ll</span>);</span><br><span class="line">    sum[o] = <span class="built_in">max</span>(sumR[o] - sumL[o], <span class="number">0ll</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushR</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    tagR[o] = minR[o] = maxR[o] = v, sumR[o] = v * (r - l + <span class="number">1ll</span>);</span><br><span class="line">    sum[o] = <span class="built_in">max</span>(sumR[o] - sumL[o], <span class="number">0ll</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~tagL[o]) <span class="built_in">pushL</span>(tagL[o], lch), <span class="built_in">pushL</span>(tagL[o], rch), tagL[o] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(~tagR[o]) <span class="built_in">pushR</span>(tagR[o], lch), <span class="built_in">pushR</span>(tagR[o], rch), tagR[o] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updL</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; (v &lt;= minR[o] || v &gt;= maxR[o])) <span class="keyword">return</span> <span class="built_in">pushL</span>(v, l, r, o);</span><br><span class="line">    <span class="built_in">pushDown</span>(l, r, o);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">updL</span>(L, R, v, lch);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">updL</span>(L, R, v, rch);</span><br><span class="line">    <span class="built_in">pushUp</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updR</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; (v &gt;= maxL[o] || v &lt;= minL[o])) <span class="keyword">return</span> <span class="built_in">pushR</span>(v, l, r, o);</span><br><span class="line">    <span class="built_in">pushDown</span>(l, r, o);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">updR</span>(L, R, v, lch);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">updR</span>(L, R, v, rch);</span><br><span class="line">    <span class="built_in">pushUp</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) L[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) pre[i] = L[a[i]], L[a[i]] = i;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) L[i] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) nxt[i] = L[a[i]], L[a[i]] = i;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; j = L[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &amp;&amp; pre[j] &gt;= pre[i]; j = L[j]);</span><br><span class="line">        vr[i].<span class="built_in">eb</span>(<span class="built_in">max</span>(j, <span class="number">1</span>), i - <span class="number">1</span>, pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; j = L[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &amp;&amp; nxt[j] &lt;= nxt[i]; j = L[j])</span><br><span class="line">            vl[nxt[j]].<span class="built_in">eb</span>(<span class="built_in">max</span>(j, <span class="number">1</span>), i - <span class="number">1</span>, L[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mem</span>(tagL, <span class="number">63</span>), <span class="built_in">mem</span>(tagR, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [l, r, v] : vl[i]) <span class="built_in">updL</span>(l, r, v, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [l, r, v] : vr[i]) <span class="built_in">updR</span>(l, r, v, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        as += sum[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; as;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="cf566c">CF566C</h3>
<blockquote>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的带权树，每个点住了 <span class="math inline">\(w_i\)</span> 个人，一个人从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的花费为距离的 <span class="math inline">\(1.5\)</span> 次方。</p>
<p>定义 <span class="math inline">\(f(u)\)</span> 表示所有人到点 <span class="math inline">\(u\)</span> 的总花费，求 <span class="math inline">\(f(u)\)</span> 最小的点。</p>
<p><span class="math inline">\(n \le 2\cdot 10^5\)</span></p>
</blockquote>
<p>首先研究 <span class="math inline">\(f(u)\)</span> 有什么性质，假设花费等于距离的话 <span class="math inline">\(f(u)\)</span> 就是单峰的，因此猜想 <span class="math inline">\(f(u)\)</span> 是单蜂的。</p>
<p>证明：由于 <span class="math inline">\(w_v\text{dis}^{1.5}_v(u)\)</span> 是下凸函数，所以它们加起来也是下凸函数。</p>
<p>回忆实数上的单蜂函数是怎么求最值的：当前确定最优点在 <span class="math inline">\([l,r]\)</span> 中，在 <span class="math inline">\(\frac {l+r}2\)</span> 处求导来确定最远点在 <span class="math inline">\(\frac {l+r}2\)</span> 左边还是右边，然后将范围减半。</p>
<p>考虑怎么在树上实现这个过程：求出整棵树的重心，通过确定最优解在重心的哪个子树来将范围减半。</p>
<p>怎么确定最优解在哪棵子树？把 <span class="math inline">\(f(u)\)</span> 的定义域扩大，<span class="math inline">\(u\)</span> 可以是一条边上的位置。求出重心向各个方向的导数，由于 <span class="math inline">\(f(u)\)</span> 单峰，所以最多有一个导数小于 <span class="math inline">\(0\)</span>，这是最优解的方向。假设最优解的方向沿着边 <span class="math inline">\((u,v)\)</span>，由于 <span class="math inline">\(f(u)\)</span> 的最优点可能在 <span class="math inline">\((u,v)\)</span> 上，所以 <span class="math inline">\(v\)</span> 不一定比 <span class="math inline">\(u\)</span> 优，应该把经过的所有点取个最小值作为答案。</p>
<p>根 <span class="math inline">\(u\)</span> 向儿子 <span class="math inline">\(v\)</span> 方向的导数为： <span class="math display">\[
\frac 32\left(\sum_{i=1}^nw_i\sqrt{\text{dis}(i,u)}-2\sum_{i\in \text{subree}(v)}w_i\sqrt{\text{dis}(i,u)}\right)
\]</span> 可以 <span class="math inline">\(O(n)\)</span> 求出 <span class="math inline">\(u\)</span> 向每个儿子的导数，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
]]></content>
  </entry>
  <entry>
    <title>一道题 4</title>
    <url>/problem4/</url>
    <content><![CDATA[<blockquote>
<p>有 <span class="math inline">\(n\)</span> 个数，每个数都是不超过 <span class="math inline">\(m\)</span> 的质数，问有多少种情况它们的异或和等于 <span class="math inline">\(0\)</span>。</p>
<p>答案对给定的模数 <span class="math inline">\(p\)</span> 取模。</p>
<p><span class="math inline">\(n \le 10^9, m \le 3 \cdot 10^6\)</span>，保证 <span class="math inline">\(p\)</span> 是奇数。</p>
</blockquote>
<p>定义一个位向量 <span class="math inline">\(A\)</span>，满足 <span class="math display">\[
A_i =
\begin{cases}
1 &amp;(i \le m \land i \in \text{Prime})\\
0 &amp;(otherwise)
\end{cases}
\]</span> 定义乘法为异或卷积，那么 <span class="math inline">\((A^n)_0\)</span> 就是答案。</p>
<p>用 <code>FWT</code> + 快速幂可以做到 <span class="math inline">\(O(m \log m\log n)\)</span>。</p>
<p>但如果先 <code>FWT</code>，再把每个位置上的值变成它的 <span class="math inline">\(n\)</span> 次方，最后 <code>IFWT</code>，复杂度 <span class="math inline">\(O(m(\log n + \log m))\)</span>。</p>
<p>但还不足以通过此题，因为模数是变量，快速幂极慢，调用 <span class="math inline">\(O(m)\)</span> 次会 <code>TLE</code>。</p>
<p>考虑 <code>FWT</code> 的定义： <span class="math display">\[
FWT(A)_i = \sum_{2\ |\ pop(j \&amp; i)}A_j - \sum_{2\ \not|\ pop(j \&amp; i)}A_j
\]</span> 可以知道 <span class="math inline">\(|FWT(A)_i| \le \sum_iA_i\)</span>，以及 <span class="math inline">\(FWT(A)_0 = \sum_iA_i\)</span>。</p>
<p><span class="math inline">\(\sum_iA_i\)</span> 即 <span class="math inline">\(m\)</span> 以内质数个数，是 <span class="math inline">\(O(\frac m {\log m})\)</span> 级别的，可以预处理这 <span class="math inline">\(O(\frac m {\log m})\)</span> 个值的 <span class="math inline">\(n\)</span> 次方。</p>
<p>这样就只需要做 <span class="math inline">\(O(\frac m {\log m})\)</span> 次快速幂。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; ll P;</span><br><span class="line"><span class="keyword">int</span> pid, f[N], g[N], prm[<span class="number">216900</span>], b, lim = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll a, <span class="keyword">int</span> n, ll r = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; n; n /= <span class="number">2</span>, a = a * a % P)</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) r = r * a % P;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, b) <span class="built_in">For</span>(S, <span class="number">0</span>, lim) <span class="keyword">if</span>(S &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; x = a[S ^ <span class="number">1</span> &lt;&lt; i], y = a[S];</span><br><span class="line">        a[S] = x - y, x += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; P;</span><br><span class="line">    <span class="keyword">if</span>(P == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(lim &lt;= m) lim *= <span class="number">2</span>, b++;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) prm[++pid] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i * prm[j] &lt;= m; j++) &#123;</span><br><span class="line">            f[i * prm[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prm[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mem</span>(f, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, pid) f[prm[i]]++, g[i] = <span class="built_in">Pow</span>(i, n);</span><br><span class="line">    <span class="built_in">FWT</span>(f);</span><br><span class="line">    <span class="keyword">int</span> as = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(S, <span class="number">0</span>, lim) (as += (f[S] &lt; <span class="number">0</span> &amp;&amp; n % <span class="number">2</span> ? <span class="number">-1</span> : <span class="number">1</span>) * g[<span class="built_in">abs</span>(f[S])]) %= P;</span><br><span class="line">    cout &lt;&lt; (as + P) * <span class="built_in">Pow</span>(P / <span class="number">2</span> + <span class="number">1</span>, b) % P;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
  </entry>
  <entry>
    <title>精准预测 | JSOI2019</title>
    <url>/jing-zhun-yu-ce-or-jsoi2019/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://loj.ac/p/3101">题目链接</a></p>
<p>有 <span class="math inline">\(n\)</span> 个人和 <span class="math inline">\(m\)</span> 个限制，以及 <span class="math inline">\(T +1\)</span> 个时刻。限制分两种：</p>
<ul>
<li>如果 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(t\)</span> 时刻是死亡状态，则 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(t+1\)</span> 时刻是死亡状态。</li>
<li>如果 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(t\)</span> 时刻是生存状态，则 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(t\)</span> 时刻是死亡状态。</li>
</ul>
<p>对于每个人 <span class="math inline">\(i\)</span>，求出其他人中有多少个人 <span class="math inline">\(j\)</span> 满足 <strong><span class="math inline">\(i\)</span> 与 <span class="math inline">\(j\)</span> 能够同时存活到最后</strong>。</p>
<p><span class="math inline">\(n \le 5 \cdot 10^4,m \le 10^5,t \le T \le 10^6\)</span></p>
</blockquote>
<p>对于每个人每个时刻，建生死两个点。</p>
<p>对于第一种限制，连有向边 <span class="math inline">\(Dead(x,t) \rightarrow Dead(y,t+1),Alive(y,t+1) \rightarrow Alive(x,t)\)</span>。</p>
<p>对于第二种限制，连有向边 <span class="math inline">\(Alive(x,t) \rightarrow Dead(y,t),Alive(y,t) \rightarrow Dead(x,t)\)</span>。</p>
<p>另外，由于每个人不能复活，连有向边 <span class="math inline">\(Dead(x,t) \rightarrow Dead(x,t+1),Alive(x,t+1) \rightarrow Alive(x,t)\)</span>。</p>
<p>首先有一些 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(Alive(x,T+1)\)</span> 能到 <span class="math inline">\(Dead(x, T+1)\)</span>，删除 <span class="math inline">\(Alive(x,T+1)\)</span> 和 <span class="math inline">\(Dead(x, T+1)\)</span>。</p>
<p>如果从 <span class="math inline">\(Dead(x,T+1)\)</span> 不能到达 <span class="math inline">\(Dead(y,T+1)\)</span>，则 <span class="math inline">\(y\)</span> 对 <span class="math inline">\(x\)</span> 造成贡献。</p>
<p>建图时其实只有所有的 <span class="math inline">\((x,t)\)</span> 和所有 <span class="math inline">\((x,T+1)\)</span> 有用，<span class="math inline">\((x,t)\)</span> 向 <span class="math inline">\((y,t&#39;)\)</span> 连边，其中 <span class="math inline">\((y,t&#39;)\)</span> 是横坐标为 <span class="math inline">\(y\)</span> 的点中第一个纵坐标大于（等于）的点，取决于是哪种限制，然后 <span class="math inline">\(Dead(x,t)\)</span> 向后继连边，<span class="math inline">\(Alive(x,t)\)</span> 向前驱连边。</p>
<p>求 <span class="math inline">\(Dead(x,T+1)\)</span> 能到达多少 <span class="math inline">\(Dead(y,T+1)\)</span> 可以用 <code>bitset</code> 优化 <code>DP</code>。</p>
<p>但空间开不下，<code>bitset</code> 只能开 <span class="math inline">\(10000\)</span>，因此需要每 <span class="math inline">\(10000\)</span> 个点做一次 <code>DP</code>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, K, c[N], t[N], x[N], y[N];</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N * <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ed[N], vis[N * <span class="number">3</span>], as[N];</span><br><span class="line">bitset&lt;10000&gt; ban, s[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    G[u + c].<span class="built_in">push_back</span>(v), G[v + <span class="number">1</span>].<span class="built_in">push_back</span>(u + !c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) <span class="built_in">dfs</span>(v), s[u] |= s[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, K) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;c[i], &amp;t[i], &amp;x[i], &amp;y[i]), m[x[i]][t[i]] = p += <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) ed[i] = m[i][T + <span class="number">1</span>] = p += <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, K) <span class="built_in">add</span>(c[i], m[x[i]][t[i]], m[y[i]].<span class="built_in">lower_bound</span>(t[i] + !c[i]) -&gt; second);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [t, j] : m[i]) &#123; <span class="keyword">if</span>(lst) <span class="built_in">add</span>(<span class="number">0</span>, lst, j); lst = j; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l += <span class="number">10000</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(l + <span class="number">9999</span>, n), ban.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, p + <span class="number">1</span>) s[i].<span class="built_in">reset</span>(), vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, l, r) s[ed[i]][i - l] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, p + <span class="number">1</span>) <span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="built_in">rep</span>(i, l, r) <span class="keyword">if</span>(s[ed[i] + <span class="number">1</span>][i - l]) ban[i - l] = <span class="number">1</span>, as[i] = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) as[i] += r - l + <span class="number">1</span> - (s[ed[i] + <span class="number">1</span>] | ban).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">max</span>(as[i] - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>省选</category>
      </categories>
  </entry>
  <entry>
    <title>(False)faces | Cerc2009</title>
    <url>/cerc2009/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://darkbzoj.tk/problem/2586">题目链接</a></p>
<p>给定一个两边各有 <span class="math inline">\(n\)</span> 个点的二分图，判断完美匹配的个数是否是 <span class="math inline">\(4\)</span> 的倍数。</p>
<p><span class="math inline">\(n \le 300\)</span></p>
</blockquote>
<p>完美匹配的个数即积和式。</p>
<p>来自论文的算法：求积和式模 <span class="math inline">\(4\)</span> 的余数。</p>
<p>积和式定义 <span class="math display">\[
\text{perm }A = \sum_{p}A_{i,p_i}
\]</span> 当 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(01\)</span> 矩阵时，有 <span class="math display">\[
\text{prem} A = (-1)^n\sum_{x_i \in \{0,1\}}(-1)^{x1+x2+\cdots+x_n}\prod_{i=1}^n(Ax)_i
\]</span> 证明可以考虑容斥：枚举哪些行=列一定没有被选。</p>
<p>观察到式子中间有一个 <span class="math inline">\(\prod\)</span> ，由于我们要求这个东西模 <span class="math inline">\(4\)</span> 的余数，因此 <span class="math inline">\((Ax)_i\)</span> 至多只能有一个位置模 <span class="math inline">\(2\)</span> 为 <span class="math inline">\(0\)</span>。</p>
<p>考虑 <span class="math inline">\((Ax)_i\)</span> 每一项模 <span class="math inline">\(2\)</span> 的余数，由于至多只能有一个 <span class="math inline">\(0\)</span>，因此可以枚举这个东西的取值，它只有 <span class="math inline">\(n+1\)</span> 种。</p>
<p>对于每种取值，通过高斯消元解出满足条件的所有 <span class="math inline">\(x\)</span>，再将每一组 <span class="math inline">\(x\)</span> 代入刚刚的式子中求出答案。</p>
<p>问题是，合法的 <span class="math inline">\(x\)</span> 的个数可能很大，因为需要枚举自由元的取值。</p>
<p>对这个矩阵做一些变换。 <span class="math display">\[
\begin{bmatrix}
A_{1,1}&amp;A_{1,2}&amp;\cdots &amp;A_{1,n}&amp;v_1\\
A_{2,1}&amp;A_{2,2}&amp;\cdots &amp;A_{2,n}&amp;v_2\\
\vdots&amp;&amp;&amp;&amp;\vdots\\
A_{n,1}&amp;A_{n,2}&amp;\cdots &amp;A_{n,n}&amp;v_n\\
0&amp;0&amp;\cdots&amp;0&amp;1
\end{bmatrix}
\]</span> 这个矩阵的积和式等于原矩阵的积和式。</p>
<p>随机选取 <span class="math inline">\(v\)</span>，则期望 <span class="math inline">\(O(1)\)</span> 组解。</p>
<p>复杂度 <span class="math inline">\(O(n^4)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, as;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">bitset &lt;302&gt; A[N], bas[N];</span><br><span class="line"><span class="keyword">int</span> x[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> su = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">0</span>, n) su += A[i][k] &amp; x[k];</span><br><span class="line">            (mul *= su) %= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n) <span class="keyword">if</span>(x[i]) mul *= <span class="number">-1</span>;</span><br><span class="line">        (as += mul) %= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!bas[i][i]) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        x[i] = j, <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">0</span>, n) <span class="keyword">if</span>(bas[k][i]) x[k] ^= <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) bas[i].<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        bitset &lt;302&gt; nw = A[i];</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, n) <span class="keyword">if</span>(nw[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bas[j][j]) nw ^= bas[j];</span><br><span class="line">            <span class="keyword">else</span> &#123; bas[j] = nw; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nw[n + <span class="number">1</span>] &amp;&amp; nw.<span class="built_in">count</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">0</span>) <span class="keyword">if</span>(bas[i][i]) <span class="built_in">rep</span>(j, i + <span class="number">1</span>, n) <span class="keyword">if</span>(bas[j][j] &amp;&amp; bas[i][j]) bas[i] ^= bas[j];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) x[i] = bas[i][n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(cin &gt;&gt; T; T--;) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), as = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n) A[i].<span class="built_in">reset</span>();</span><br><span class="line">        <span class="built_in">For</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s), A[i][n] = <span class="built_in">rand</span>() &amp; <span class="number">1</span>, A[i][n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">For</span>(j, <span class="number">0</span>, n) A[i][j] = s[j] - <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A[n][n] = A[n][n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n) A[i][n + <span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">solve</span>(), A[i][n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">puts</span>(as ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cerc</category>
      </categories>
  </entry>
  <entry>
    <title>从 C++11 到 C++17</title>
    <url>/cong-c11-dao-c17/</url>
    <content><![CDATA[<p>建议在编程中尝试使用 <code>C++17</code>，可以一定程度上简化代码编写，提高编程效率。</p>
<p>从 <code>C++11</code> 到 <code>C++14</code> 和 <code>C++17</code> 的部分实用特性：</p>
<h3 id="lambda-的泛型参数和捕获的增强">lambda 的泛型参数和捕获的增强。</h3>
<p>允许 lambda 函数的形式参数声明中使用 <code>auto</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">// since C++14</span></span><br></pre></td></tr></table></figure>
<p>允许 lambda 函数的捕获部分中定义变量同时初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [value = a + b] &#123; <span class="keyword">return</span> value + c; &#125;;</span><br><span class="line"><span class="comment">// since C++14</span></span><br></pre></td></tr></table></figure>
<p>允许成员函数中的 lambda 函数以拷贝的方式捕获 <code>*this</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> value; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">node::func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> ++value; &#125;; <span class="comment">// by reference</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lambda</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// since C++11</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> value; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">node::func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [*<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> ++value; &#125;; <span class="comment">// by copy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lambda</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// since C++17</span></span><br></pre></td></tr></table></figure>
<h3 id="函数返回类型推导">函数返回类型推导。</h3>
<p><code>C++11</code> 允许 lambda 函数返回值使用 <code>auto</code>，<code>C++14</code> 允许一般函数也可以这样做，甚至可以递归，但递归调用必须在函数定义中的至少一个 <code>return</code> 语句之后。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorial</span>(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// since C++14</span></span><br></pre></td></tr></table></figure>
<p>错误示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n) <span class="keyword">return</span> <span class="built_in">factorial</span>(n - <span class="number">1</span>) * n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数模板推导">构造函数模板推导</h3>
<p>构造一个模板类对象不需要指明模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2.2</span>)</span></span>;</span><br><span class="line">vector b&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">set c&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">tuple <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2.2</span>, a)</span></span>;</span><br><span class="line"><span class="comment">// since C++17</span></span><br></pre></td></tr></table></figure>
<h3 id="结构化绑定">结构化绑定</h3>
<p>将结构体拆包，相当于 <code>C++11</code> 中 <code>tie</code> 函数的增强。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector a&#123;<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">pair</span>(<span class="number">2</span>, <span class="number">3</span>)&#125;;</span><br><span class="line"><span class="keyword">auto</span> [first, second] = a[<span class="number">0</span>];</span><br><span class="line">cout &lt;&lt; first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [first, second] : a) first++, second++; <span class="comment">// by reference</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [first, second] : a) cout &lt;&lt; first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; second &lt;&lt; endl; <span class="comment">// by copy</span></span><br><span class="line"><span class="comment">// since C++17</span></span><br></pre></td></tr></table></figure>
<h3 id="if-语句初始化"><code>if</code> 语句初始化</h3>
<p><code>if</code> 可以像 <code>for</code> 循环一样有一条初始化语句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">int</span> value = <span class="built_in">func</span>(); value &lt; <span class="number">100</span>) cout &lt;&lt; value;</span><br><span class="line"><span class="comment">// since C++17</span></span><br></pre></td></tr></table></figure>
<h3 id="二进制字面量和其他新增标准字面量">二进制字面量和其他新增标准字面量</h3>
<p>数字可以使用二进制形式指定，其格式使用前缀 <code>0b</code> 或 <code>0B</code>。</p>
<p>在一个字符串后加 <code>s</code>，表示 <code>string</code> 类型。</p>
<p>在一个数字后加 <code>i</code>，<code>if</code>，<code>il</code> 分别表示 <code>complex&lt;double&gt;</code>、<code>complex&lt;float&gt;</code> 和 <code>complex&lt;long double&gt;</code> 复数类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> str = <span class="string">&quot;hello world&quot;</span>s; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">auto</span> value = <span class="number">0b1010</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="number">1</span>i; <span class="comment">// complex&lt;double&gt;</span></span><br><span class="line"><span class="comment">// since C++14</span></span><br></pre></td></tr></table></figure>
<h3 id="折叠表达式">折叠表达式</h3>
<p>可以用来方便的定义参数个数不定的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class ...T&gt; <span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ...value)</span> </span>&#123; <span class="keyword">return</span> value + ...; &#125;</span><br><span class="line"><span class="comment">// since C++17</span></span><br></pre></td></tr></table></figure>
<h3 id="namespace-嵌套">namespace 嵌套</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">100</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// since C++17</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串转化">字符串转化</h3>
<p><code>from_chars</code> 是把 <code>const char*</code> 转化成整数或浮点数。</p>
<p><code>to_chars</code> 是把整数或浮点数转化成 <code>const char*</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>杂项</title>
    <url>/za-xiang/</url>
    <content><![CDATA[<h3 id="barrett-reduction-取模优化">Barrett reduction 取模优化</h3>
<blockquote>
<p>计算 <span class="math inline">\(ab\bmod m(0\le a,b&lt;m&lt;2^{31})\)</span>。</p>
</blockquote>
<p>如果 <span class="math inline">\(m\)</span> 在编译时已知，那么编译器就会帮你完成这个优化，否则你可以自己实现。</p>
<p>首先，设 <span class="math inline">\(m^{-1}\)</span> 表示浮点数形式的 <span class="math inline">\(\frac 1m\)</span>。 <span class="math display">\[
ab\bmod m=ab-\lfloor ab\cdot m^{-1}\rfloor m
\]</span> 即使预处理了 <span class="math inline">\(m^{-1}\)</span>，由于浮点数乘法比整数除法快不了多少，考虑进一步优化，取 <span class="math inline">\(\frac {m&#39;}{2^k}\approx m^{-1}\)</span>，然后 <span class="math display">\[
\lfloor ab\cdot m^{-1}\rfloor \approx \lfloor \frac{abm&#39;}{2^k}\rfloor
\]</span> 计算右边就快多了，因为只有整数乘法和右移，如何合理选取 <span class="math inline">\(m&#39;\)</span> 和 <span class="math inline">\(k\)</span>？</p>
<p>令 <span class="math inline">\(k=2\lceil \log_2 m\rceil,m&#39;=\lceil \frac{2^k}m\rceil\)</span>，下面分析误差：</p>
<ul>
<li>设 <span class="math inline">\(m&#39;m=2^k+r(0\le r&lt;m)\)</span></li>
<li>设 <span class="math inline">\(ab=cm+d(0\le c,d&lt;m)\)</span></li>
<li><span class="math inline">\(abm&#39;=(cm+d)m&#39;=cm&#39;m+dm&#39;=c2^k+cr+dm&#39;\)</span></li>
<li><span class="math inline">\(cr+dm&#39;&lt;(m-1)^2+m&#39;m&lt;(m-1)^2+2^k+(m-1)=2^k+m(m-1)&lt;2^k\cdot 2\)</span></li>
<li><span class="math inline">\(\lfloor \frac{abm&#39;}{2^k}\rfloor=c\ \text{or}\ c+1\)</span></li>
</ul>
<p>设真实答案为 <span class="math inline">\(ans\)</span>，那么 <span class="math inline">\(ab-\lfloor \frac{abm&#39;}{2^k}\rfloor m=ans\ \text{or}\ ans-m\)</span>。</p>
<p>更一般的结论是只要 <span class="math inline">\(c \ge \max(a, b^2)\)</span>，<span class="math inline">\(\lfloor \frac{a\lfloor \frac cb\rfloor}c\rfloor=\lfloor \frac ab\rfloor\ \text{or}\ \lfloor \frac ab\rfloor+1\)</span> 成立。</p>
<p>实践中可以令 <span class="math inline">\(k=64\)</span>，可以用 <code>~0ull / m + 1</code> 来计算 <span class="math inline">\(m&#39;\)</span>。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">barrett</span> &#123;</span></span><br><span class="line">    uint m; ull im;</span><br><span class="line">    <span class="built_in">barrett</span>(uint m) :<span class="built_in">m</span>(m), <span class="built_in">im</span>(~<span class="number">0ull</span> / m + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function">uint <span class="title">mul</span><span class="params">(uint a, uint b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        ull z = (ull)a * b;</span><br><span class="line">        ull x = (<span class="keyword">unsigned</span> __int128)z * im &gt;&gt; <span class="number">64</span>;</span><br><span class="line">        uint v = z - x * m;</span><br><span class="line">        <span class="keyword">return</span> m &lt;= v ? v + m : v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>
<p>速度比较：先在 <span class="math inline">\([0, m)\)</span> 中随机生成 <span class="math inline">\(10^5\)</span> 个数，然后计算两两乘积模 <span class="math inline">\(m\)</span> 的异或和。</p>
<p>测试系统 <code>ubuntu-21.04</code>（因为 <code>Linux</code> 比较稳定），每个格子前者为直接取模的时间，后者为 <code>Barrett reduction</code> 取模的时间。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">编译选项</th>
<th style="text-align: center;">998244353</th>
<th style="text-align: center;">1000000007</th>
<th style="text-align: center;">1000000009</th>
<th style="text-align: center;">19260817</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">无</td>
<td style="text-align: center;">47.1s/29.6s</td>
<td style="text-align: center;">45.7s/30.2s</td>
<td style="text-align: center;">46.6s/30.4s</td>
<td style="text-align: center;">45.8s/29.2s</td>
</tr>
<tr class="even">
<td style="text-align: center;">-O2</td>
<td style="text-align: center;">35.8s/6.4s</td>
<td style="text-align: center;">35.2s/6.1s</td>
<td style="text-align: center;">35.0s/6.3s</td>
<td style="text-align: center;">35.4s/6.3s</td>
</tr>
</tbody>
</table>
<p>另外，笔者想到了两个可以应用的地方。</p>
<ul>
<li><p>高精度计算 <span class="math inline">\(ab\bmod m\)</span>，高精度乘法是可以用 <code>FFT</code> 优化到 <span class="math inline">\(O(\log m\log\log m)\)</span> 的（严格来讲，如果 <span class="math inline">\(m\)</span> 位数过于巨大，以致于直接求卷积会溢出时，需要用到 <code>Schönhage-Strassen</code> 算法，复杂度 <span class="math inline">\(O(\log m\log\log m\log \log \log m)\)</span>，这里粗略地分析为 <span class="math inline">\(O(\log m\log\log m)\)</span>，后面的复杂度分析也是如此），而取模只能 <span class="math inline">\(O(\log^2 m)\)</span>。当 <span class="math inline">\(m\)</span> 固定时，可以事先 <span class="math inline">\(O(\log^2 m)\)</span> 计算出 <span class="math inline">\(m&#39;\)</span>，然后就可以 <span class="math inline">\(O(\log m\log\log m)\)</span> 地取模了。将此应用于 <code>Miller Rabin</code> 素性检验可以将复杂度优化到 <span class="math inline">\(O(k\log^2n\log\log n)\)</span>。</p></li>
<li><p>加速计算 <span class="math inline">\(\gcd(a,b)\)</span>。如果 <span class="math inline">\(a,b\)</span> 都比较小，而次数很多，比如 <span class="math inline">\(a,b\le 10^7\)</span>，要求 <span class="math inline">\(5\cdot 10^7\)</span> 次 <span class="math inline">\(\gcd\)</span>。</p>
<p>对于 <span class="math inline">\(m\)</span>，令 <span class="math inline">\(k=\max(24,2\lceil \log_2m\rceil)\)</span>，当 <span class="math inline">\(m=b\)</span> 时，<span class="math inline">\(am&#39;\)</span> 在 <code>long long</code> 范围内，可以很有效地优化。</p></li>
</ul>
<h3 id="卡特兰数的两个扩展">卡特兰数的两个扩展</h3>
<p>本节所有的路径都是指每一步向上或向右走一个单位长度的路径。</p>
<blockquote>
<p>给定一条直线 <span class="math inline">\(l:y=kx+b\)</span>，求从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((a, l(a))\)</span> 且不越过 <span class="math inline">\(l\)</span> 的路径条数。</p>
<p><span class="math inline">\(k,b,a\)</span> 都是正整数。</p>
</blockquote>
<p>记 <span class="math inline">\(G(k,b,a)\)</span> 表示这个路径条数。</p>
<p>考虑从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((a, l(a))\)</span> 的路径条数，它可能不会越过 <span class="math inline">\(l\)</span>，这部分路径条数为 <span class="math inline">\(G(k,b,a)\)</span>，否则可以枚举路径第一次越过 <span class="math inline">\(l\)</span> 时的横坐标 <span class="math inline">\(i\)</span>，得到 <span class="math inline">\((1)\)</span> 式： <span class="math display">\[
\binom {l(a)+a}a=G(k,b,a)+\sum_{i+j=a}G(k,b,i)\binom{kj+j-1}j
\]</span></p>
<p>考虑从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((a-1,l(a))\)</span> 的路径条数，它一定会越过 <span class="math inline">\(l\)</span>，枚举路径第一次越过 <span class="math inline">\(l\)</span> 时的横坐标 <span class="math inline">\(i\)</span>，得到 <span class="math inline">\((2)\)</span> 式： <span class="math display">\[
\binom {l(a)+a}{a-1}=\sum_{i+j=a}G(k,b,i)\binom {kj+j-1}{j-1}
\]</span></p>
<p>注意到 <span class="math display">\[
\frac{\binom{kj+j-1}j}{\binom{kj+j-1}{j-1}}=\frac{kj}j=k
\]</span> <span class="math inline">\((1)-(2)\times k\)</span> 得： <span class="math display">\[
G(k,b,a)=\binom{l(a)+a}a-k\binom{l(a)+a}{a-1}
\]</span></p>
<blockquote>
<p>给定一条直线 <span class="math inline">\(l:y=kx+b\)</span>，求从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((x,y)\)</span> 的所有路径与 <span class="math inline">\(l\)</span> 的交点总数。</p>
<p><span class="math inline">\(k,b,a\)</span> 都是正整数，<span class="math inline">\(l(x) \le y\)</span>。</p>
</blockquote>
<p>记 <span class="math inline">\(F(k,b,x,y)\)</span> 表示这个交点总数。</p>
<p>考虑每个交点的贡献，枚举交点的横坐标 <span class="math inline">\(i\)</span>，得到： <span class="math display">\[
F(k,b,x,y)=\sum_{i+j=x}\binom{l(i)+i}i\binom{y-l(i)+j}j
\]</span> 进一步 <span class="math display">\[
\begin{aligned}
&amp;F(k,b,x,y)-kF(k,b,x-1,y+1)\\
&amp;=\sum_{i+j=x}\binom{l(i)+i}i\binom{y-l(i)+j}j-k\binom{l(i)+i}i\binom{y-l(i)+j}{j-1}\\
&amp;=\sum_{i+j=x}\binom{l(i)+i}i\left(\binom{y-l(i)+j}j-k\binom{y-l(i)+j}{j-1}\right)\\
&amp;=\sum_{i+j=x}\binom{l(i)+i}iG(k,y-l(x),j)
\end{aligned}
\]</span> 注意到 <span class="math inline">\(\binom{l(i)+i}i\)</span> 是从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((i,l(i))\)</span> 的路径条数，而 <span class="math inline">\(G(k,y-l(x),j)\)</span> 是从 <span class="math inline">\((x,y+1)\)</span> <strong>倒着</strong>走到 <span class="math inline">\((i,l(i)+1)\)</span> 且不越过 <span class="math inline">\(l\)</span> 的路径条数，整体求和就是从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((x,y+1)\)</span> 的路径条数，因为 <span class="math inline">\(i\)</span> 就是在枚举最后一次越过 <span class="math inline">\(l\)</span> 时的横坐标。</p>
<p>于是 <span class="math display">\[
F(k,b,x,y)=kF(k,b,x-1,y+1)+\binom{x+y+1}x
\]</span> 因为 <span class="math inline">\(F(k,b,x+y,0)=1\)</span></p>
<p>归纳得到 <span class="math display">\[
F(k,b,x,y)=\sum_{i+j=x}\binom{x+y+1}ik^j
\]</span> 它甚至和 <span class="math inline">\(b\)</span> 无关。</p>
<h3 id="lucaslehmer-素性检验">Lucas–Lehmer 素性检验</h3>
<blockquote>
<p>原理：<span class="math inline">\(M_p=2^p-1(p\in\text{Odd prime})\)</span> 是质数当且仅当 <span class="math inline">\(M_p|(2+\sqrt 3)^{2^{p-2}}+(2-\sqrt 3)^{2^{p-2}}\)</span>。</p>
</blockquote>
<p>后面有证明。</p>
<p>算法：令 <span class="math inline">\(s_n=(2+\sqrt 3)^{2^n}+(2-\sqrt 3)^{2^n}\bmod M_p\)</span>，那么 <span class="math display">\[
s_n=\begin{cases}
4&amp;(i=0)\\
s_{n-1}^2-2\bmod M_p&amp;(i&gt;1)
\end{cases}
\]</span> 计算平方可以用 <code>FFT</code> 做到 <span class="math inline">\(O(p\log p)\)</span>，由于模数很特殊，取模可以做到线性：</p>
<p><span class="math inline">\(a \bmod M_p=(a_0\cdot 2^p+a_1)\bmod M_p=(a_0+a_1)\bmod M_p\)</span></p>
<p><span class="math inline">\(s_{n-1}^2-2\)</span> 最多展开两遍就行了，复杂度 <span class="math inline">\(O(p^2\log p)\)</span>。</p>
<h4 id="充分性">充分性</h4>
<p>反证法：假设 <span class="math inline">\(M_p\)</span> 是合数，它的最小质因子为 <span class="math inline">\(q\)</span>，定义一个 <span class="math inline">\(q^2\)</span> 个元素的集合 <span class="math inline">\(X=\{a+b\sqrt 3|a,b\in\mathbb Z_q\}\)</span>，其中 <span class="math inline">\(\mathbb Z_q\)</span> 表示 <span class="math inline">\(0,1,2\cdots,q-2,q-1\)</span>，定义 <span class="math inline">\(X\)</span> 中的乘法运算为 <span class="math display">\[
(a+b\sqrt 3)(c+d\sqrt 3)=(ac+3bd)\bmod q+(bc+ad)\bmod q\sqrt3
\]</span> <span class="math inline">\(X\)</span> 中任何两个元素的乘积一定也在 <span class="math inline">\(X\)</span> 内，但它不是群，因为不是所有元素都可逆，只保留有逆的元素，就得到了群 <span class="math inline">\(X^*\)</span>。因为 <span class="math inline">\((2+\sqrt 3)(2+(q-1)\sqrt 3)\equiv 1\pmod q\)</span>，所以 <span class="math inline">\(2+\sqrt 3\in X^{*}\)</span>。</p>
<p>考虑 <span class="math display">\[
(2+\sqrt 3)^{2^{p-2}}+(2-\sqrt 3)^{2^{p-2}} \equiv 0\pmod {M_p}\\
(2+\sqrt 3)^{2^{p-1}}+[(2+\sqrt 3)(2-\sqrt 3)]^{2^{p-2}} \equiv 0\pmod {M_p}\\
(2+\sqrt 3)^{2^{p-1}}\equiv -1\pmod {M_p}
\]</span> 这说明了 <span class="math inline">\(2 + \sqrt 3\)</span> 的阶为 <span class="math inline">\(2^p\)</span>，即 <span class="math inline">\((2 + \sqrt 3)^0,(2 + \sqrt 3)^1,(2 + \sqrt 3)^2,\cdots,(2+\sqrt 3)^{2^p-1}\)</span> 两两不同。</p>
<p>于是有 <span class="math inline">\(2^p \le |X*| \le q^2 \le M_p\)</span>，得出矛盾 <span class="math inline">\(2^p \le M_p\)</span>，故 <span class="math inline">\(M_p\)</span> 为质数。</p>
<h4 id="必要性">必要性</h4>
<p>现在已知 <span class="math inline">\(M_p\)</span> 是质数，要说明 <span class="math inline">\(M_p|(2+\sqrt 3)^{2^{p-2}}+(2-\sqrt 3)^{2^{p-2}}\)</span>。</p>
<p>可以归纳证明，对于奇数 <span class="math inline">\(p\ge 3\)</span>，有 <span class="math inline">\(2^p-1\equiv 7\pmod 8\)</span> 和 <span class="math inline">\(2^p-1\equiv 7\pmod {12}\)</span>。</p>
<p>对于奇质数 <span class="math inline">\(p\)</span>：</p>
<ul>
<li><span class="math inline">\(2^p-1\equiv 7\pmod 8\Rightarrow \left(\dfrac 2p\right)=1\Rightarrow 2^{\frac{M_p-1}2}\equiv 1\pmod {M_p}\)</span></li>
<li><span class="math inline">\(2^p-1\equiv 7\pmod {12}\Rightarrow \left(\dfrac 3p\right)=-1\Rightarrow 3^{\frac{M_p-1}2}\equiv -1\pmod {M_p}\)</span></li>
</ul>
<p>第一步的原理都是二次互反律及其补充，第二步的原理都是欧拉准则。</p>
<p>像前面一样，定义 <span class="math inline">\(X=\{a+b\sqrt 3|a,b\in\mathbb Z_{M_p}\}\)</span>，保留有逆的元素得到群 <span class="math inline">\(X^*\)</span>。</p>
<blockquote>
<p>引理：<span class="math inline">\(\forall x,y\in X^*,(x+y)^{M_p}\equiv x^{M_p}+y^{M_p}\pmod{M_p}\)</span>。</p>
</blockquote>
<p>根据 <span class="math inline">\(M_p|\binom{M_p}i\)</span>。</p>
<p>那么，我们有： <span class="math display">\[
\begin{aligned}
(6+2\sqrt 3)^{M_p}&amp;=6^{M_p}+2^{M_p}(\sqrt 3)^{M_p}\\
&amp;=6+2\sqrt 3\cdot 3^{\frac{M_p-1}2}\\
&amp;=6-2\sqrt 3
\end{aligned}
\]</span> 由于 <span class="math inline">\(2+\sqrt 3=\frac{(6+2\sqrt 3)^2}{24}\)</span>，进一步 <span class="math display">\[
\begin{aligned}
(2+\sqrt 3)^{\frac{M_p+1}2}&amp;=\frac{(6+2\sqrt 3)^{M_p+1}}{24^{\frac{M_p+1}2}}\\
&amp;=\frac{(6+2\sqrt 3)(6-2\sqrt 3)}{24\cdot (2^{\frac{M_p-1}2})^3\cdot 3^{\frac{M_p-1}2}}\\
&amp;=-1
\end{aligned}
\]</span> 最后，在两边同乘 <span class="math inline">\((2-\sqrt 3)^{\frac{M_p+1}4}\)</span>，并利用 <span class="math inline">\((2+\sqrt 3)(2-\sqrt 3)=1\)</span> <span class="math display">\[
\begin{aligned}
(2+\sqrt 3)^{\frac{M_p+1}2}(2-\sqrt 3)^{\frac{M_p+1}4}&amp;=-(2-\sqrt 3)^{\frac{M_p+1}4}\\
(2+\sqrt 3)^{\frac{M_p+1}4}+(2-\sqrt 3)^{\frac{M_p+1}4}&amp;=0\\
(2+\sqrt 3)^{2^{p-2}}+(2-\sqrt 3)^{2^{p-2}}&amp;=0
\end{aligned}
\]</span></p>
<h3 id="一个非常简单的问题">一个非常简单的问题</h3>
<blockquote>
<p>求 <span class="math inline">\(2^n\)</span> 内所有奇数的乘积 <span class="math inline">\(\bmod 2^n\)</span>。</p>
<p><span class="math inline">\(n \le 10^4\)</span></p>
</blockquote>
<p>设 <span class="math inline">\(f_n=\prod_{i=1}^{2^{n-1}}2i-1\bmod 2^n\)</span>，对于 <span class="math inline">\(n\ge 2\)</span>，有 <span class="math display">\[
\begin{aligned}
f_{n+1}&amp;=(\prod_{i=1}^{2^{n-1}}2i-1\bmod 2^{n+1})(\prod_{i=1}^{2^{n-1}}2i-1+2^n\bmod 2^{n+1})\bmod 2^{n+1}\\
&amp;=(\prod_{i=1}^{2^{n-1}}2i-1\bmod 2^{n+1})^2\bmod 2^{n+1}\\
\end{aligned}
\]</span> 设 <span class="math inline">\(\prod_{i=1}^{2^{n-1}}2i-1\bmod 2^{n+1}=f_n+k2^n(k\in\{0,1\})\)</span>，继续推。 <span class="math display">\[
\begin{aligned}
f_{n+1}&amp;=(f_n+k2^n)^2\bmod 2^{n+1}\\
&amp;=f_n^2+k2^{n+1}+k^22^{2n}\bmod 2^{n+1}\\
&amp;=f_n^2\bmod 2^{n+1}
\end{aligned}
\]</span> 计算平方可以用 <code>FFT</code> 做到 <span class="math inline">\(O(n\log n)\)</span>，总复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p>
<h3 id="一个非常困难的问题">一个非常困难的问题</h3>
<blockquote>
<p>求 <span class="math inline">\(\frac {p-1}2!\bmod p\)</span>，<span class="math inline">\(p\)</span> 是质数且 <span class="math inline">\(p\equiv 3\pmod 4\)</span>。</p>
<p><span class="math inline">\(p \le ???\)</span></p>
</blockquote>
<p>快速阶乘算法 <span class="math inline">\(O(\sqrt p\log p)\)</span>。</p>
<p>其他做法：根据 Wilson 定理，<span class="math inline">\((p-1)!\equiv -1\pmod p\)</span>，那么 <span class="math inline">\(\frac {p-1}2!\equiv \pm 1\pmod p\)</span>。准确地，<span class="math inline">\(\frac {p-1}2!\equiv 1\pmod p\)</span> 当且仅当以下之一成立：</p>
<ul>
<li><p><span class="math inline">\(p\equiv 3\pmod 8 \land h(-p)\equiv 1\pmod 4\)</span></p></li>
<li><p><span class="math inline">\(p\equiv 7\pmod 8\land h(-p)\equiv 3\pmod 4\)</span></p></li>
</ul>
<p><span class="math inline">\(h(-p) \bmod 4\)</span> 怎么快速算？不会。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Phoenix and Odometers | Codeforces 1515G</title>
    <url>/CF1515G/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/problemset/problem/1515/G">题目链接</a></p>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的带权有向图。</p>
<p>有 <span class="math inline">\(q\)</span> 次询问，每次给定 <span class="math inline">\(v,s,t\)</span>，问是否存在一条起点终点都为 <span class="math inline">\(v\)</span> 的路径满足 <span class="math inline">\(t | (s+l)\)</span>，其中 <span class="math inline">\(l\)</span> 是路径的总长。</p>
<p><span class="math inline">\(n, m,q \le 2 \cdot 10^5,s&lt;t\le 10^9\)</span>，边权均不超过 <span class="math inline">\(10^9\)</span>。</p>
</blockquote>
<p>首先这条路径只能在 <span class="math inline">\(v\)</span> 所在强连通分量的内部。</p>
<p>以下所有的路径长度都是在模 <span class="math inline">\(t\)</span> 意义下的。</p>
<blockquote>
<p>引理：在同一个强连通分量，如果 <span class="math inline">\(u\rightarrow v\)</span> 存在一条长度为 <span class="math inline">\(l\)</span> 的路径，那么 <span class="math inline">\(v\rightarrow u\)</span> 存在一条长度为 <span class="math inline">\(-l\)</span> 的路径。</p>
</blockquote>
<p>构造：假设 <span class="math inline">\(v\rightarrow u\)</span> 存在一条长度为 <span class="math inline">\(w\)</span> 的路径，先走 <span class="math inline">\(v\rightarrow u\)</span>，长度为 <span class="math inline">\(w\)</span>，再走 <span class="math inline">\(t-1\)</span> 次 <span class="math inline">\(u\rightarrow v\rightarrow u\)</span>，长度为 <span class="math inline">\((t-1)(l+w)\)</span>，总长度 <span class="math inline">\(-w\)</span>。</p>
<p>在强连通分量的内部，对于一个长度为 <span class="math inline">\(w\)</span> 的环，从环上一个点 <span class="math inline">\(u\)</span> 出发绕若干圈再回到 <span class="math inline">\(u\)</span>，所有可能的路径长度为 <span class="math inline">\(\gcd(w,t)\)</span> 的倍数。根据引理，<span class="math inline">\(v\rightarrow u\)</span> 有一条长度为 <span class="math inline">\(w\)</span> 的路径，<span class="math inline">\(u\rightarrow v\)</span> 有一条长度为 <span class="math inline">\(-w\)</span> 的路径，先走 <span class="math inline">\(v\rightarrow u\)</span>，再绕若干圈，最后走 <span class="math inline">\(u\rightarrow v\)</span>，就可以凑出所有长度为 <span class="math inline">\(\gcd(w,t)\)</span> 倍数的环。</p>
<p>以 <span class="math inline">\(r\)</span> 为根建出 <code>DFS</code> 树，设 <span class="math inline">\(\phi(u)\)</span> 表示从 <span class="math inline">\(r\)</span> 沿着树边走到 <span class="math inline">\(u\)</span> 的路径长度，对于每条非树边 <span class="math inline">\((u,v,w)\)</span>，意味着存在一个长度为 <span class="math inline">\(\phi(u)+w-\phi(v)\)</span> 的环。设 <span class="math inline">\(x=\gcd_{(u,v,w)}\phi(u)+w-\phi(v)\)</span>，那么所有的可能环长分别为 <span class="math inline">\(0,x,2x,3x,\cdots\)</span>。这些环长显然能取到，也可以归纳证明对于任何 <span class="math inline">\(r\rightarrow u\)</span> 的路径，都有长度 <span class="math inline">\(\equiv \phi(u)\pmod x\)</span>。结论：存在合法路径当且仅当 <span class="math inline">\(x|s\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd(a, b) (a = min(a, b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> idx, dfn[N], scc[N], stk[N], tp, sid;</span><br><span class="line">ll g[N], d[N], gg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = dfn[u] = ++idx; stk[++tp] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w] : G[u]) <span class="keyword">if</span>(!dfn[v]) d[v] = d[u] + w, <span class="built_in">upd</span>(low, <span class="built_in">dfs</span>(v));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!scc[v]) <span class="built_in">upd</span>(low, dfn[v]), g[u] = <span class="built_in">gcd</span>(g[u], d[u] - d[v] + w);</span><br><span class="line">    <span class="keyword">if</span>(low == dfn[u]) <span class="keyword">for</span>(<span class="keyword">int</span> v = (sid++, <span class="number">0</span>); v ^ u;)</span><br><span class="line">        v = stk[tp--], scc[v] = sid, gg[sid] = <span class="built_in">gcd</span>(gg[sid], g[v]);</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w), G[u].<span class="built_in">emplace_back</span>(v, w);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(cin &gt;&gt; q; q--; <span class="built_in">puts</span>(v % <span class="built_in">gcd</span>(gg[scc[u]], (ll)w) ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>))</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的数学题 | 51nod1847</title>
    <url>/51nod1847/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=1847">题目链接</a></p>
<p>给定 <span class="math inline">\(n,k\)</span>，求 <span class="math inline">\(\sum\limits_{i=1}^n\sum\limits_{j=1}^n\text{sgcd}(i,j)^k\)</span>。</p>
<p>其中 <span class="math inline">\(\text{sgcd}(i,j)\)</span> 表示 <span class="math inline">\(i,j\)</span> 的次大公约数。特别地，如果 <span class="math inline">\(\text{gcd}(i,j)=1\)</span>，则 <span class="math inline">\(\text{sgcd}(i,j)=0\)</span>。</p>
<p>答案对 <span class="math inline">\(2^{32}\)</span> 取模。</p>
<p><span class="math inline">\(n \le 10^9,k \le 50\)</span></p>
</blockquote>
<p><span class="math inline">\(p_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个质数，<span class="math inline">\(d_i\)</span> 表示 <span class="math inline">\(i\)</span> 的最小质因子。</p>
<p>有 <span class="math inline">\(\text{sgcd}(i,j)=\dfrac{\gcd(i,j)}{d_{\gcd(i,j)}}\)</span>。</p>
<p>考虑枚举 <span class="math inline">\(\gcd\)</span>。 <span class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=1}^n\text{sgcd}(i,j)^k\\
&amp;=\sum_{c=2}^n(\frac c{d_c})^k\sum_{i=1}^{\lfloor\frac nc\rfloor}\sum_{j=1}^{\lfloor\frac nc\rfloor}[gcd(i,j)=1]\\
&amp;=\sum_{c=2}^n(\frac c{d_c})^k(2\sum_{i=1}^{\lfloor\frac nc\rfloor}\varphi(i)-1)
\end{aligned}
\]</span> 现在的问题是算 <span class="math inline">\((\frac x{d_x})^k\)</span> 和 <span class="math inline">\(\varphi(x)\)</span> 在 <span class="math inline">\(\lfloor \frac nc \rfloor\)</span> 处的前缀和，后者直接<a href="http://coding-pages-bucket-3532178-8430896-13917-522304-1305159063.cos-website.ap-hongkong.myqcloud.com/du-jiao-shai-and-min-25-shai-and-powerful-number-shai/#%E6%9D%9C%E6%95%99%E7%AD%9B">杜教筛</a>即可。</p>
<p>对于前者，由于涉及到 <span class="math inline">\(d_x\)</span> 考虑 <a href="http://coding-pages-bucket-3532178-8430896-13917-522304-1305159063.cos-website.ap-hongkong.myqcloud.com/du-jiao-shai-and-min-25-shai-and-powerful-number-shai/#min-25-%E7%AD%9B">Min-25 筛</a>。</p>
<p>设 <span class="math display">\[
g(n,i) = \sum_{j=2}^n [j \in P \lor d_j &gt; p_i]j^k\\
f(n,i) = \sum_{j=2}^n [j \not\in P \land d_j \le p_i](\frac j{d_j})^k\\
h(h,i) = \sum_{j=2}^n [j \in P \lor d_j &gt; p_i]
\]</span> 有递推 <span class="math display">\[
g(n, i) = g(n, i - 1) - p_i^k(g(\lfloor\frac n {p_i} \rfloor, i - 1) - g(p_i-1,i))\\
f(n,i) = f(n,i-1)+g(\lfloor\frac n {p_i} \rfloor,i-1) - g(p_i-1,i)\\
h(n,i)=h(n,i-1)-h(\lfloor\frac n {p_i} \rfloor, i - 1) + h(p_i-1,i)
\]</span> 初始化 <span class="math display">\[
g(n,0)=\sum_{i=2}^ni^k\\
f(n,0)=0\\
h(n,0)=n-1
\]</span> 这里需要求<a href="http://coding-pages-bucket-3532178-8430896-13917-522304-1305159063.cos-website.ap-hongkong.myqcloud.com/zi-ran-shu-deng-mi-qiu-he/">自然数等幂和</a>。</p>
<p>当 <span class="math inline">\(n &lt; p_i^2\)</span> 时都不需要转移，因此这是一个标准的 Min-25 筛。</p>
<p>复杂度 <span class="math inline">\(O(\frac {n^{\frac 34}}{\log n}+n^{\frac 23})\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> U;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">namespace</span> Sum &#123;</span><br><span class="line">    U S[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, K) <span class="built_in">rep</span>(j, <span class="number">1</span>, i) S[i][j] = S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (U)j * S[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">U <span class="title">qry</span><span class="params">(<span class="keyword">int</span> n, U re = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, K) &#123;</span><br><span class="line">            U t = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, n + <span class="number">1</span> - i, n + <span class="number">1</span>) <span class="keyword">if</span>(j % (i + <span class="number">1</span>)) t *= j;</span><br><span class="line">            <span class="keyword">else</span> t *= j / (i + <span class="number">1</span>);</span><br><span class="line">            re += t * S[K][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re - <span class="number">1u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Du &#123;</span><br><span class="line">    <span class="keyword">int</span> m, pid, prm[<span class="number">100000</span>];</span><br><span class="line">    U phi[<span class="number">1000005</span>], S[<span class="number">1005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m = <span class="built_in">pow</span>(n, <span class="number">2.</span> / <span class="number">3</span>);</span><br><span class="line">        phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!phi[i]) phi[i] = i - <span class="number">1</span>, prm[++pid] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i * prm[j] &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span>(i % prm[j]) phi[i * prm[j]] = phi[i] * phi[prm[j]];</span><br><span class="line">            <span class="keyword">else</span> &#123; phi[i * prm[j]] = phi[i] * prm[j]; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) phi[i] += phi[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">U <span class="title">qry</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= m) <span class="keyword">return</span> phi[i];</span><br><span class="line">        <span class="keyword">if</span>(S[n / i]) <span class="keyword">return</span> S[n / i];</span><br><span class="line">        U res = i * (i + <span class="number">1ll</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            res -= <span class="built_in">qry</span>(i / l) * (r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S[n / i] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> M25 &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="built_in">sqrt</span>(<span class="number">1e9</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    U g1[N], g2[N], f1[N], f2[N], h1[N], h2[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            g1[i] = Sum::<span class="built_in">qry</span>(i), g2[i] = Sum::<span class="built_in">qry</span>(n / i);</span><br><span class="line">            h1[i] = i - <span class="number">1</span>, h2[i] = n / i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(p, <span class="number">2</span>, m) <span class="keyword">if</span>(h1[p] ^ h1[p - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> w1 = m / p, w3 = p * p, w2 = <span class="built_in">min</span>(m, n / w3);</span><br><span class="line">            <span class="keyword">int</span> j, d = n / p;</span><br><span class="line">            U x = <span class="number">1</span>, gx = g1[p - <span class="number">1</span>], hx = h1[p - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, K) x *= p;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, w1) &#123;</span><br><span class="line">                j = i * p, h2[i] -= h2[j] - hx;</span><br><span class="line">                f2[i] += g2[j] - gx, g2[i] -= x * (g2[j] - gx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">rep</span>(i, w1 + <span class="number">1</span>, w2) &#123;</span><br><span class="line">                j = d / i, h2[i] -= h1[j] - hx;</span><br><span class="line">                f2[i] += g1[j] - gx, g2[i] -= x * (g1[j] - gx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">per</span>(i, m, w3) &#123;</span><br><span class="line">                j = i / p, h1[i] -= h1[j] - hx;</span><br><span class="line">                f1[i] += g1[j] - gx, g1[i] -= x * (g1[j] - gx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">U <span class="title">qry</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> i &lt;= m ? f1[i] + h1[i] : f2[n / i] + h2[n / i]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    Sum::<span class="built_in">pre</span>(), Du::<span class="built_in">pre</span>(), M25::<span class="built_in">pre</span>();</span><br><span class="line">    U as = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        as += (<span class="number">2u</span> * Du::<span class="built_in">qry</span>(n / l) - <span class="number">1u</span>) * (M25::<span class="built_in">qry</span>(r) - M25::<span class="built_in">qry</span>(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; as;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>51nod</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>自然数等幂求和</tag>
        <tag>Min-25 筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>Phoenix and Earthquake | Codeforces 1515F</title>
    <url>/CF1515F/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/problemset/problem/1515/F">题目链接</a></p>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向连通图和正整数 <span class="math inline">\(x\)</span>，点有非负权值 <span class="math inline">\(a_i\)</span>。</p>
<p>如果一条边 <span class="math inline">\((u,v)\)</span> 满足 <span class="math inline">\(a_u+a_v \ge x\)</span>，可以将 <span class="math inline">\(u,v\)</span> 缩起来，新点的点权为 <span class="math inline">\(a_u+a_v-x\)</span>。</p>
<p>判断这张图是否可以缩成一个点并给出方案。</p>
<p><span class="math inline">\(n,m \le 3 \cdot 10^5,x,a_i \le 10^9\)</span></p>
</blockquote>
<p>首先将每个点的点权减去 <span class="math inline">\(x\)</span>，则合并条件变为 <span class="math inline">\(a_u + a_v \ge -x\)</span>，每次合并后新点的点权为 <span class="math inline">\(a_u + a_v\)</span>。</p>
<blockquote>
<p>结论：这张图可以缩成一个点的充要条件是点权和大于等于 <span class="math inline">\(-x\)</span>。</p>
</blockquote>
<p>必要性显然，充分性可以考虑这个构造：每次选择点权最大的点 <span class="math inline">\(u\)</span> 的任意一条边。</p>
<p>构造的正确性可以考虑反证法，设这条边为 <span class="math inline">\((u,v)\)</span>，假设这条边不行，即 <span class="math inline">\(a_u+a_v&lt;-x\)</span>。</p>
<p>进一步 <span class="math inline">\(\because a_v \ge -x,\therefore a_u &lt; 0\)</span></p>
<p>由于 <span class="math inline">\(a_u\)</span> 是最大值，因此所有点的点权都是负数，那么 <span class="math inline">\(a_u+a_v \ge \sum a_i \ge -x\)</span>，推出矛盾！</p>
<p>至此，已经得到一个做法。</p>
<p>但还有更简单的做法，根据上面结论，任意求一棵生成树都有可行方案。</p>
<p>先从叶子向根依次考虑每个结点，如果这个结点权值非负，则选择它和它父亲的连边，再从根向叶子依次考虑每个结点，如果它和它父亲的连边还没选，则选择这条边。</p>
<p>证明考虑数学归纳法即可。</p>
<p>在实现中不必 <code>DFS</code> 两遍，<code>DFS</code> 过程中把没选的边压栈即可。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x, vis[N], as[N], L, R;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N], su;</span><br><span class="line">vector &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, i] : G[u]) <span class="keyword">if</span>(!vis[v])</span><br><span class="line">        <span class="built_in">dfs</span>(v), a[v] &gt;= <span class="number">0</span> ? a[u] += a[v], as[L++] = i : as[R--] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]), su += a[i] -= x;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v), G[u].<span class="built_in">eb</span>(v, i), G[v].<span class="built_in">eb</span>(u, i);</span><br><span class="line">    <span class="keyword">if</span>(su + x &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>), L = <span class="number">2</span>, R = n, <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, as[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>salesman | IOI2009</title>
    <url>/IOI2009/</url>
    <content><![CDATA[<blockquote>
<p>坐标轴上有 <span class="math inline">\(N\)</span> 场展览会，每场展览会有一个举行时间 <span class="math inline">\(T_i\)</span> ，举行地点 <span class="math inline">\(L_i\)</span> 和获利 <span class="math inline">\(M_i\)</span>。</p>
<p>坐标向大移动 <span class="math inline">\(1\)</span> 的代价是 <span class="math inline">\(D\)</span>，向小移动 <span class="math inline">\(1\)</span> 的代价是 <span class="math inline">\(U\)</span>，速度为任意大。</p>
<p>每场展览会只能参加一次，问从 <span class="math inline">\(S\)</span> 出发最后再回到 <span class="math inline">\(S\)</span> 的最大获利。</p>
<p><span class="math inline">\(N,T_i \le 5 \cdot 10^5,L_i \le 5 \cdot 10^5+1\)</span></p>
</blockquote>
<p>先考虑一个弱化版的问题：<span class="math inline">\(T_i\)</span> 互不相同。</p>
<p>设 <span class="math inline">\(f_i\)</span>表示刚参加第 <span class="math inline">\(i\)</span> 场展览会后的最大获利。</p>
<p>有转移方程 <span class="math inline">\(f_i = \max\limits_{T_j &lt; T_i}f_j-cost(j,i)\)</span>。</p>
<p>其中 <span class="math display">\[
cost(i,j)=\begin{cases}
D(L_j-L_i) &amp;(L_i&lt;L_j)\\
U(L_i-L_j) &amp;(L_i&gt;L_j)
\end{cases}
\]</span> 两种情况分别用树状数组维护前缀（后缀）最大值即可实现 <span class="math inline">\(O(\log n)\)</span> 转移。</p>
<p>再考虑同一天的多场展览会怎么处理。</p>
<p>记 <span class="math inline">\(f_{i,0/1}\)</span> 表示从左/右到达第 <span class="math inline">\(i\)</span> 场展览会后的最大获利。</p>
<p>然后正反两遍 <code>DP</code>，每次用临时变量存由同一天的展览会转移来最优解，和树状数组中的最优解取个较优，计算出 <code>DP</code> 值后再把这一天所有展览会插入树状数组。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd(a, b) (a = max(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">getchar</span>(), r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="number">48</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="number">47</span>) r = r * <span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, U, D, s, L[N], M[N], f[N][<span class="number">2</span>];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; id[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="built_in">BIT</span>() &#123; <span class="built_in">rep</span>(i, <span class="number">1</span>, N - <span class="number">4</span>) c[i] = INT_MIN; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">for</span>(; i &lt;= N - <span class="number">4</span>; i += i &amp; -i) <span class="built_in">upd</span>(c[i], v); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> r = INT_MIN)</span> </span>&#123; <span class="keyword">for</span>(; i; i &amp;= i - <span class="number">1</span>) <span class="built_in">upd</span>(r, c[i]); <span class="keyword">return</span> r; &#125;</span><br><span class="line">&#125; Td, Tu;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    Td.<span class="built_in">ins</span>(i, v - (N - i) * D), Tu.<span class="built_in">ins</span>(N - <span class="number">3</span> - i, v - i * U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(Td.<span class="built_in">qry</span>(i) + (N - i) * D, Tu.<span class="built_in">qry</span>(N - <span class="number">3</span> - i) + i * U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; U &gt;&gt; D &gt;&gt; s;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) id[<span class="built_in">read</span>()].<span class="built_in">pb</span>(i), L[i] = <span class="built_in">read</span>(), M[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">ins</span>(s, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, N - <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(id[i].<span class="built_in">begin</span>(), id[i].<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> L[a] &lt; L[b]; &#125;);</span><br><span class="line">        <span class="keyword">int</span> pre = INT_MIN, suf = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j : id[i])</span><br><span class="line">            <span class="built_in">upd</span>(pre, (f[j][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">qry</span>(L[j]), pre + (N - L[j]) * D) + M[j]) - (N - L[j]) * D);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j = id[i].<span class="built_in">rbegin</span>(); j != id[i].<span class="built_in">rend</span>(); j++)</span><br><span class="line">            <span class="built_in">upd</span>(suf, (f[*j][<span class="number">1</span>] = <span class="built_in">max</span>(<span class="built_in">qry</span>(L[*j]), suf + L[*j] * U) + M[*j]) - L[*j] * U);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j : id[i]) <span class="built_in">ins</span>(L[j], <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qry</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Baby Ehab Plays with Permutations | Codeforces 1516E</title>
    <url>/CF1515E/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/problemset/problem/1516/E">题目链接</a></p>
<p>给定 <span class="math inline">\(n,k\)</span>，对于每个 <span class="math inline">\(i \in [1,k]\)</span>，你需要求出有多少个长度为 <span class="math inline">\(n\)</span> 的排列能通过恰好 <span class="math inline">\(i\)</span> 次交换操作变成 <span class="math inline">\(\{1,2,\cdots,n\}\)</span>。</p>
<p>答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(n \le 10^9,k \le 200\)</span></p>
</blockquote>
<p>先考虑这样一个问题：给定一个排列 <span class="math inline">\(P\)</span>，最少交换几次才能变成 <span class="math inline">\(\{1,2,\cdots,n\}\)</span>。</p>
<p>把排列 <span class="math inline">\(P\)</span> 理解成一个置换，并分解成循环，不难发现 <span class="math inline">\(i\)</span> 个元素的循环需要交换 <span class="math inline">\(i-1\)</span> 次。</p>
<p>这样，如果 <span class="math inline">\(P\)</span> 的循环节为 <span class="math inline">\(x\)</span>，则总的交换次数为 <span class="math inline">\(n-x\)</span>。</p>
<p>涉及到点数和循环数不难想到<strong>第一类斯特林数</strong>。</p>
<p><span class="math inline">\(i\)</span> 的答案即 <span class="math inline">\({n \brack n-i}+{n \brack n-i+2}+{n \brack n-i+4} + \cdots\)</span>。</p>
<p>问题是 <span class="math inline">\(n\)</span> 太大了，不能递推求出第一类斯特林数。</p>
<p>由于 <span class="math inline">\(i\)</span> 次交换最多影响 <span class="math inline">\(2i\)</span> 个元素，一个合法的排列 <span class="math inline">\(P\)</span> 至多有 <span class="math inline">\(2i\)</span> 个位置 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(j \ne P_j\)</span>。</p>
<p>可以枚举有多少个 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(j \ne P_j\)</span>，如果有 <span class="math inline">\(x\)</span> 个，对答案的贡献为 <span class="math inline">\(\binom nxf_{x,x-i}\)</span>。</p>
<p>其中 <span class="math inline">\(f_{i,j}\)</span> 表示有多少个长度为 <span class="math inline">\(i\)</span> 的<strong>错排</strong>循环节为 <span class="math inline">\(j\)</span>，它可以通过第一类斯特林数容斥得到： <span class="math display">\[
f_{i,j}={i \brack j}-\sum_{k=1}^j\binom ikf_{i-k,j-k}
\]</span> 复杂度 <span class="math inline">\(O(k^3)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, C[N * <span class="number">2</span>][N * <span class="number">2</span>];</span><br><span class="line">ll f[N * <span class="number">2</span>][N], as[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll a, <span class="keyword">int</span> n, ll r = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; n; n /= <span class="number">2</span>, a = a * a % P)</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) r = r * a % P;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) b = b * x-- % P, a = a * (n - x) % P;</span><br><span class="line">    <span class="keyword">return</span> a * <span class="built_in">Pow</span>(b, P - <span class="number">2</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, K * <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">1</span>, K)</span><br><span class="line">        f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (i - <span class="number">1</span>) * f[i - <span class="number">1</span>][j]) % P;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, K * <span class="number">2</span>) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, i) C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, K * <span class="number">2</span>) <span class="built_in">rep</span>(j, <span class="number">1</span>, i) <span class="built_in">rep</span>(k, <span class="number">1</span>, j)</span><br><span class="line">        (f[i][j] -= C[i][k] * f[i - k][j - k]) %= P;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, K) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, i, i * <span class="number">2</span>) (as[i] += f[j][j - i] * <span class="built_in">calc</span>(j)) %= P;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) (as[i] += as[i - <span class="number">2</span>]) %= P;</span><br><span class="line">        <span class="keyword">if</span>(i) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (as[i] + P) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>置换</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Off by One | Codeforces 1519E</title>
    <url>/CF1519E/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/problemset/problem/1519/E">题目链接</a></p>
<p>给定平面上的 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((\frac {a_i}{b_i},\frac {c_i}{d_i})\)</span>，定义一个点 <span class="math inline">\((x,y)\)</span> 的<strong>派生点</strong>为点 <span class="math inline">\((x+1,y)\)</span> 和点 <span class="math inline">\((x,y+1)\)</span>。</p>
<p>两个点 <span class="math inline">\(A,B\)</span> 能够匹配当且仅当 <span class="math inline">\(A\)</span> 的一个派生点和 <span class="math inline">\(B\)</span> 的一个派生点在同一条过原点的直线上。</p>
<p>求出最大匹配的大小和任意一种方案。</p>
<p><span class="math inline">\(n \le 2 \cdot 10^5,1 \le a_i,b_i,c_i,d_i \le 10^9\)</span></p>
</blockquote>
<p>两个第一象限的点在同一条过原点的直线上等价于两个点的横纵坐标之比相等。</p>
<p>定义一个点 <span class="math inline">\((x,y)\)</span> 的<strong>派生值</strong>为 <span class="math inline">\(\frac {x+1}y\)</span> 和 <span class="math inline">\(\frac x{y+1}\)</span>。</p>
<p>两个点 <span class="math inline">\(A,B\)</span> 能够匹配即拥有同一个派生值。</p>
<p>把所有的派生值抽象成点，给定的点抽象成边，匹配条件进一步转化为<strong>两条边拥有公共顶点</strong>。</p>
<blockquote>
<p>引理：一个<strong>连通</strong>无向图能够给每条边定向使得每个点入度为偶数当且仅当边数为偶数。</p>
<p>证明：边数为奇数显然不行，下面给出边数为偶数时的构造：</p>
<p>先建树 <code>DFS</code> 树，所有反向边都向上，如果两个端点都在点 <span class="math inline">\(u\)</span> 子树内的边的数量为偶数，则 <span class="math inline">\(u\)</span> 与其父亲的连边（如果存在）向上，否则向下。</p>
</blockquote>
<p>通过引理不难推出一个边数为 <span class="math inline">\(m\)</span> 的连通图的答案为 <span class="math inline">\(\lfloor \frac m2 \rfloor\)</span>，求方案可以先给每条边定向，再把每个点的所有入边两两配对。</p>
<p>只需要对每个连通块做一遍即可。</p>
<p>最后一个问题：派生值是分子分母都是 <span class="math inline">\(10^{18}\)</span> 级别的分数，离散化时需要排序，但如何比较。</p>
<p>一种方法是转 <code>__int128</code> 交叉相乘比较大小。其实不一定要按分数值排序，双关键字排序同样能实现离散化，先约分，再以分子、分母为两关键字比较则是另一种更快的方法。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll K1[N], K2[N];</span><br><span class="line"><span class="keyword">int</span> n, ord[N], id[N];</span><br><span class="line">vector &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; G[N];</span><br><span class="line">vector &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; as;</span><br><span class="line"><span class="keyword">int</span> idx, dfn[N], sz[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    G[u].<span class="built_in">eb</span>(v, i), G[v].<span class="built_in">eb</span>(u, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> ins = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lst) as.<span class="built_in">eb</span>(lst, x), lst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> lst = x;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w] : G[u]) <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v, w), sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(~sz[v] &amp; <span class="number">1</span>) <span class="built_in">ins</span>(w);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &gt; dfn[u]) <span class="built_in">ins</span>(w);</span><br><span class="line">    <span class="keyword">else</span> sz[v]++;</span><br><span class="line">    <span class="keyword">if</span>(lst &amp;&amp; f) as.<span class="built_in">eb</span>(lst, f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        K1[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="built_in">ll</span>(a + b) * d, K1[i * <span class="number">2</span>] = (ll)a * d;</span><br><span class="line">        K2[i * <span class="number">2</span> - <span class="number">1</span>] = (ll)b * c, K2[i * <span class="number">2</span>] = b * <span class="built_in">ll</span>(c + d);</span><br><span class="line">    &#125;</span><br><span class="line">    n *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ord[i] = i;</span><br><span class="line">        ll g = __gcd(K1[i], K2[i]);</span><br><span class="line">        K1[i] /= g, K2[i] /= g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> K1[x] ^ K1[y] ? K1[x] &lt; K1[y] : K2[x] &lt; K2[y];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(ord + <span class="number">1</span>, ord + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) id[i] = <span class="built_in">lower_bound</span>(ord + <span class="number">1</span>, ord + n + <span class="number">1</span>, i, cmp) - ord;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n / <span class="number">2</span>) <span class="built_in">add</span>(id[i * <span class="number">2</span> - <span class="number">1</span>], id[i * <span class="number">2</span>], i);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; as.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [u, v] : as) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, u, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Yura and Developers | Codeforces 549F</title>
    <url>/CF549F/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/549/problem/F">题目链接</a></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列和数 <span class="math inline">\(k\)</span>，求有多少长度大于 <span class="math inline">\(1\)</span> 的区间满足和减最大值是 <span class="math inline">\(k\)</span> 的倍数。</p>
<p><span class="math inline">\(n \le 3 \cdot 10^5,k \le 10^6,a_i \le 10^9\)</span></p>
</blockquote>
<p>先求出前缀和数组 <span class="math inline">\(pre\)</span>。</p>
<p>则条件可以写成 <span class="math inline">\(pre_r \equiv pre_{l-1} + \max \pmod k\)</span>。</p>
<p>把 <span class="math inline">\(i\)</span> 插入 <span class="math inline">\(\text{vector}[pre_i \bmod k]\)</span>，通过二分可以快速查询区间中有多少前缀和模 <span class="math inline">\(k\)</span> 余 <span class="math inline">\(x\)</span>。</p>
<p>求出整个序列的最大值的位置为 <span class="math inline">\(x\)</span>。</p>
<p>然后枚举 <span class="math inline">\(x\)</span> 左边的前缀和，查询 <span class="math inline">\(x\)</span> 右边有多少个前缀和与之配对。</p>
<p>因为 <span class="math inline">\(x\)</span> 的位置不确定，所以这样是 <span class="math inline">\(O(n^2\log n)\)</span>。</p>
<p>但如果每次枚举左右中较短的一段，则复杂度可降为 <span class="math inline">\(O(n \log^2 n)\)</span>。</p>
<p>其实不用真的分治，只需要单调栈求出每个位置作为最大值的极大区间即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N], L[N], R[N], su[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; v[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    v[<span class="number">0</span>].<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) su[i] = (su[i - <span class="number">1</span>] + a[i]) % K, v[su[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">for</span>(<span class="keyword">int</span>&amp; j = L[i] = i - <span class="number">1</span>; j &amp;&amp; a[j] &lt;= a[i]; j = L[j]);</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span>&amp; j = R[i] = i + <span class="number">1</span>; j &lt;= n &amp;&amp; a[j] &lt; a[i]; j = R[j]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> as = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span>(i - L[i] &lt; R[i] - i) <span class="built_in">For</span>(j, L[i], i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (su[j] + a[i]) % K;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> lb lower_bound</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> all v[t].begin(), v[t].end()</span></span><br><span class="line">        as += <span class="built_in">lb</span>(all, R[i]) - <span class="built_in">lb</span>(all, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">For</span>(j, i, R[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = ((su[j] - a[i]) % K + K) % K;</span><br><span class="line">        as += <span class="built_in">lb</span>(all, i) - <span class="built_in">lb</span>(all, L[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; as - n;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>任意模数 NTT</title>
    <url>/ren-yi-mo-shu-ntt/</url>
    <content><![CDATA[<blockquote>
<p>给定一个 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(A\)</span> 和一个 <span class="math inline">\(m\)</span> 次多项式 <span class="math inline">\(B\)</span>，计算 <span class="math inline">\(A \times B\)</span>，系数对 <span class="math inline">\(p\)</span> 取模。</p>
<p><span class="math inline">\(n,m \le 10^5\)</span></p>
</blockquote>
<p>常见的有两种做法：</p>
<ul>
<li>先做三模数 <code>NTT</code> 再用中国剩余定理合并。</li>
</ul>
<span id="more"></span>
<ul>
<li>取 <span class="math inline">\(M = \lceil \sqrt p \rceil\)</span>，把每个系数 <span class="math inline">\(x\)</span> 拆成 <span class="math inline">\(M \cdot \lfloor \frac Mx \rfloor\)</span> 和 <span class="math inline">\(M \bmod x\)</span> 两部分。</li>
</ul>
<p>这里讲第二种做法及其优化。</p>
<h3 id="做法">做法</h3>
<p>设 <span class="math display">\[
A0_i=\lfloor \frac {A_i}M \rfloor,A1_i=A_i \bmod M\\B0_i=\lfloor \frac {B_i}M \rfloor,B1_i=B_i \bmod M
\]</span> 于是 <span class="math display">\[
A = M \cdot A0 + A1\\B = M \cdot B0  + B1
\]</span> 进一步 <span class="math display">\[
A \times B = M^2 \cdot A0 \times B0 + M(A0 \times B1 + A1 \times B0) + A1 \times B1
\]</span> 先对 <span class="math inline">\(A0,A1,B0,B1\)</span> 做一遍 <code>DFT</code>，求出 <span class="math inline">\(A0 \times B0, A0 \times B1 + A1 \times B0,A1 \times B1\)</span> 的点值表示后再分别 <code>IDFT</code>，共 <span class="math inline">\(7\)</span> 次。</p>
<p>注意系数可能达到 <span class="math inline">\(10^{14}\)</span>，需要用 <span class="math inline">\(w_n^k=\cos \frac {2k\pi}n+i \cdot \sin \frac {2k\pi}n\)</span> 对 <span class="math inline">\(w_n^k\)</span> 进行预处理保证精度。</p>
<h3 id="优化">优化</h3>
<p>下面考虑这样两件事：</p>
<ul>
<li><p>现在要对<strong>实系数</strong>多项式 <span class="math inline">\(A,B\)</span> 进行 <code>DFT</code>。</p>
<p>我们定义 <span class="math display">\[
P = A + iB\\
Q = A - iB
\]</span> 推导可以得到一个很优美的结论： <span class="math display">\[
\text {conj}(Q(w_n^k))=P(\text{conj}({w_n^{k}}))
\]</span> 于是只需一次 <code>DFT</code> 就可以求出 <span class="math inline">\(A,B\)</span> 的点值表示。</p></li>
<li><p>现在已知<strong>实系数</strong>多项式 <span class="math inline">\(A,B\)</span> 的点值表示 <span class="math inline">\(A&#39;,B&#39;\)</span>，要求 <span class="math inline">\(A,B\)</span>。</p>
<p>我们定义 <span class="math display">\[
P = A&#39; + iB&#39;
\]</span> 对 <span class="math inline">\(P\)</span> 进行 <code>IDFT</code> 得到 <span class="math inline">\(P&#39;\)</span>，于是 <span class="math display">\[
P&#39; = A + iB
\]</span> 因此 <span class="math inline">\(P&#39;\)</span> 的实数部分就是 <span class="math inline">\(A\)</span>, 虚数部分就是 <span class="math inline">\(B\)</span>。</p>
<p>于是只需一次 <code>IDFT</code> 就可以达到对 <span class="math inline">\(A&#39;,B&#39;\)</span> 分别做 <code>IDFT</code> 的效果.</p></li>
</ul>
<p>将 <span class="math inline">\(7\)</span> 次 <code>DFT</code> 两两配对可以合并成 <span class="math inline">\(4\)</span> 次 <code>DFT</code>。</p>
<p>定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> complex &lt;lf&gt; cmp;</span><br><span class="line"><span class="keyword">const</span> lf PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">const</span> cmp <span class="title">I</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, P;</span><br><span class="line"><span class="keyword">int</span> M, lim = <span class="number">1</span>, bit = <span class="number">-1</span>, rev[N];</span><br><span class="line">cmp w[N], a0[N], a1[N], b0[N], b1[N];</span><br></pre></td></tr></table></figure>
<p>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(cmp a[], <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t) <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + lim);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, lim) <span class="keyword">if</span>(i &lt; rev[i]) <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i *= <span class="number">2</span>) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += i * <span class="number">2</span>) <span class="built_in">For</span>(k, j, j + i) &#123;</span><br><span class="line">        cmp x = a[k], y = a[i + k] * w[lim / i * (k - j)];</span><br><span class="line">        a[k] = x + y, a[i + k] = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) <span class="built_in">For</span>(i, <span class="number">0</span>, lim) a[i] *= inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT2</span><span class="params">(cmp a[], cmp b[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, lim) a[i] += b[i] * I;</span><br><span class="line">    <span class="built_in">FFT</span>(a, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, lim) b[i] = <span class="built_in">conj</span>(a[i ? lim - i : <span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, lim) &#123;</span><br><span class="line">        cmp x = a[i], y = b[i];</span><br><span class="line">        a[i] = (y + x) * <span class="number">0.5</span>, b[i] = (y - x) * <span class="number">0.5</span> * I;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">num</span><span class="params">(cmp x)</span> </span>&#123; <span class="keyword">return</span> M * <span class="built_in">ll</span>(<span class="built_in">real</span>(x) + <span class="number">0.5</span>) % P + <span class="built_in">ll</span>(<span class="built_in">imag</span>(x) + <span class="number">0.5</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>预处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">M = <span class="built_in">sqrt</span>(P);</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">0</span>, n) a0[i] = A[i] / M, a1[i] = A[i] % M;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">0</span>, m) b0[i] = B[i] / M, b1[i] = B[i] % M;</span><br><span class="line"><span class="keyword">while</span>(lim &lt;= n + m) lim *= <span class="number">2</span>, bit++;</span><br><span class="line">inv = <span class="number">1.</span> / lim;</span><br><span class="line"><span class="built_in">For</span>(i, <span class="number">0</span>, lim) &#123;</span><br><span class="line">    rev[i] = rev[i / <span class="number">2</span>] / <span class="number">2</span> | (i &amp; <span class="number">1</span>) &lt;&lt; bit;</span><br><span class="line">    w[i] = <span class="built_in">cmp</span>(<span class="built_in">cos</span>(PI / lim * i), <span class="built_in">sin</span>(PI / lim * i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FFT2</span>(a0, a1), <span class="built_in">FFT2</span>(b0, b1);</span><br><span class="line"><span class="built_in">For</span>(i, <span class="number">0</span>, lim) &#123;</span><br><span class="line">    cmp t = a0[i] + I * a1[i];</span><br><span class="line">    b0[i] *= t, b1[i] *= t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FFT</span>(b0, <span class="number">1</span>), <span class="built_in">FFT</span>(b1, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">0</span>, n + m) C[i] = (M * <span class="built_in">num</span>(b0[i]) + <span class="built_in">num</span>(b1[i])) % P;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
        <tag>模板</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title>Complete the MST | Codeforces 1508C</title>
    <url>/CF1508C/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/1508/problem/C">题目链接</a></p>
<p>有一张 <span class="math inline">\(n\)</span> 个点的无向完全图，其中 <span class="math inline">\(m\)</span> 条边的边权已给定。</p>
<p>你需要给剩下的边确定边权，使得<strong>所有边的权值</strong>异或和为 <span class="math inline">\(0\)</span>。</p>
<p>求出所有方案中最小生成树权值的最小值。</p>
<p><span class="math inline">\(n \le 2 \cdot 10^5,m \le \min\{2 \cdot 10^5,\binom n2-1\}\)</span></p>
</blockquote>
<p>下面<strong>原图</strong>指给定的 <span class="math inline">\(m\)</span> 条边构成的图，<strong>补图</strong>指剩下的边构成的图，<code>MST</code> 指最小生成树。</p>
<blockquote>
<p>引理：最优解中补图至多有一条权值非 <span class="math inline">\(0\)</span> 的边。</p>
<p>证明：考虑两条补图边 <span class="math inline">\(e_1,e_2\)</span>，它们的权值 <span class="math inline">\(w_1,w_2\)</span> 都大于 <span class="math inline">\(0\)</span>。</p>
<ul>
<li>如果它们都不在 <code>MST</code> 上，把 <span class="math inline">\(e_1\)</span> 权值变为 <span class="math inline">\(0\)</span>，<span class="math inline">\(e_2\)</span> 权值异或上 <span class="math inline">\(e_1\)</span> 权值，新的 <code>MST</code> 不会变劣。</li>
<li>如果它们都在 <code>MST</code> 上，把 <span class="math inline">\(e_1\)</span> 权值变为 <span class="math inline">\(0\)</span>，<span class="math inline">\(e_2\)</span> 权值异或上 <span class="math inline">\(e_1\)</span> 权值，因为 <span class="math inline">\(w_1 \oplus w_2 \le w_1 + w_2\)</span>，所以新的 <code>MST</code> 不会变劣。</li>
<li>如果它们中的一条在 <code>MST</code> 上，一条不在，不妨设 <span class="math inline">\(e_1\)</span> 在 <code>MST</code> 上，把 <span class="math inline">\(e_1\)</span> 权值变为 <span class="math inline">\(0\)</span>，<span class="math inline">\(e_2\)</span> 权值异或上 <span class="math inline">\(e_1\)</span> 权值，新的 <code>MST</code> 不会变劣。</li>
</ul>
<p>综上，如果存在两条权值大于 <span class="math inline">\(0\)</span> 的边，把其中一条的权值变为 <span class="math inline">\(0\)</span>，新的 <code>MST</code> 不会变劣。</p>
</blockquote>
<p>所以补图中有一条<strong>特殊边</strong>的权值恰好为给定的 <span class="math inline">\(m\)</span> 条边的权值异或和，其余边的权值均为 <span class="math inline">\(0\)</span>。</p>
<p>容易想到枚举一下特殊边在不在 <code>MST</code> 上。</p>
<p>先用 <code>DFS</code> 求出补图的生成森林，用 <code>set</code> 优化枚举未访问的点可以做到 <span class="math inline">\(O(m\log n)\)</span> 的复杂度。</p>
<p>如果补图中存在环，那么补图中一定有边不在 <code>MST</code> 上，故特殊边一定不在 <code>MST</code> 上。把求出的生成森林加入原图后，答案即为该图的最小生成树，复杂度 <span class="math inline">\(O(m\log m)\)</span>。</p>
<p>如果不存在环，那么 <span class="math inline">\(n\)</span> 就是 <span class="math inline">\(O(\sqrt m)\)</span> 级别的，如果特殊边在 <code>MST</code> 上，直接用同样的做法；如果不在 <code>MST</code> 上，就需要枚举特殊边是哪一条，每次删去它再沿用以上做法，复杂度 <span class="math inline">\(O(m \log m + nm\alpha(n))\)</span>。一个优化：用原图的最小生成树替代原图，复杂度降为 <span class="math inline">\(O(m\log m + n^2\alpha(n))=O(m\log m)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, fa[N], xorsu, eid, tid;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x ^ fa[x] ? fa[x] = <span class="built_in">find</span>(fa[x]) : x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mrg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((u = <span class="built_in">find</span>(u)) ^ (v = <span class="built_in">find</span>(v))) <span class="keyword">return</span> fa[u] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> edge&amp; b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[N], t[N];</span><br><span class="line">set &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">erase</span>(u);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, G[u].<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i], nxt = G[u][i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; *s.<span class="built_in">rbegin</span>() &gt; v) &#123;</span><br><span class="line">            <span class="keyword">int</span> vv = *s.<span class="built_in">upper_bound</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(vv &gt;= nxt) <span class="keyword">break</span>;</span><br><span class="line">            t[++tid] = &#123;u, vv&#125;, <span class="built_in">dfs</span>(vv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w), xorsu ^= e[i].w;</span><br><span class="line">        G[e[i].u].<span class="built_in">pb</span>(e[i].v), G[e[i].v].<span class="built_in">pb</span>(e[i].u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) G[i].<span class="built_in">pb</span>(<span class="number">0</span>), G[i].<span class="built_in">pb</span>(n + <span class="number">1</span>), <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>()), s.<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) <span class="built_in">dfs</span>(*s.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) <span class="keyword">if</span>(<span class="built_in">mrg</span>(e[i].u, e[i].v)) e[++eid] = e[i];</span><br><span class="line">    <span class="keyword">if</span>(tid &lt; n * (n - <span class="number">1ll</span>) / <span class="number">2</span> - m) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, tid) <span class="built_in">mrg</span>(t[i].u, t[i].v);</span><br><span class="line">        ll as = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, eid) <span class="keyword">if</span>(<span class="built_in">mrg</span>(e[i].u, e[i].v)) as += e[i].w;</span><br><span class="line">        cout &lt;&lt; as;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll as = <span class="number">1e18</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, tid) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, n) fa[j] = j;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, tid) <span class="keyword">if</span>(j ^ i) <span class="built_in">mrg</span>(t[j].u, t[j].v);</span><br><span class="line">            ll su = i ? <span class="number">0</span> : xorsu;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, eid) <span class="keyword">if</span>(<span class="built_in">mrg</span>(e[j].u, e[j].v)) su += e[j].w;</span><br><span class="line">            as = <span class="built_in">min</span>(as, su);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; as;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>一道题3</title>
    <url>/problem3/</url>
    <content><![CDATA[<blockquote>
<p><span class="math inline">\(n\)</span> 个数 <span class="math inline">\(p_i\)</span> 构成一个随机排列。</p>
<p>当你手上的数是 <span class="math inline">\(p_i\)</span> 时，你并不知道 <span class="math inline">\(p_i\)</span> 为多少，但你会获知是否 <span class="math inline">\(p_i = \min\{p_1,p_2,\cdots,p_i\}\)</span>，然后做出以下两种行为之一：</p>
<ul>
<li>如果 <span class="math inline">\(i &lt; n\)</span>，用 <span class="math inline">\(p_{i+1}\)</span> 换掉 <span class="math inline">\(p_i\)</span>。</li>
<li>带走 <span class="math inline">\(p_i\)</span>，并结束。</li>
</ul>
<p>现在你手上的数是 <span class="math inline">\(p_1\)</span>，你想带走 <span class="math inline">\(1\)</span>，求在最优决策下你带走 <span class="math inline">\(1\)</span> 的概率。</p>
<p>共 <span class="math inline">\(T\)</span> 组数据。</p>
<p><span class="math inline">\(n \le 10^6,T \le 10^5\)</span></p>
</blockquote>
<p>设 <span class="math inline">\(f_i\)</span> 表示你手上的数是 <span class="math inline">\(p_i\)</span> 时，在最优决策下你带走 <span class="math inline">\(1\)</span> 的概率。</p>
<p>有 <span class="math inline">\(\frac 1i\)</span> 的概率你获知了 <span class="math inline">\(p_i = \min\{p_1,p_2,\cdots,p_i\}\)</span>，此时一定采取两种行为中带走 <span class="math inline">\(1\)</span> 的概率较大的一种。</p>
<p>采取第一种行为时带走 <span class="math inline">\(1\)</span> 的概率为 <span class="math inline">\(f_{i+1}\)</span>，采取第二种行为时带走 <span class="math inline">\(1\)</span> 的概率为 <span class="math inline">\(\frac in\)</span>。</p>
<p>否则 <span class="math inline">\(p_i \ne \min\{p_1,p_2,\cdots,p_i\}\)</span>，因为 <span class="math inline">\(p_i\)</span> 一定不为 <span class="math inline">\(1\)</span>，所以一定会采取​第一种行为。</p>
<p>即 <span class="math display">\[
f_i = \dfrac {\max\{f_{i+1},\frac in\} + (i-1)f_{i+1}}i
\]</span> 初始化 <span class="math inline">\(f_{n+1} = 0\)</span>，答案即为 <span class="math inline">\(f_1\)</span>。</p>
<p>至此得到一个 <span class="math inline">\(O(Tn)\)</span> 的做法。</p>
<p>注意到 <span class="math inline">\(f_i\)</span> 是单调不增的，而 <span class="math inline">\(\frac in\)</span> 是单调递增的，并且 <span class="math inline">\(f_1 &gt; \frac 1n,f_{n+1} &lt; \frac nn\)</span>。</p>
<p>不难证明存在一个 <span class="math inline">\(d\)</span>，满足 <span class="math display">\[
\begin{cases}
f_i \ge \frac in &amp;(i \le d)\\
f_i &lt; \frac in &amp;(i &gt; d)
\end{cases}
\]</span> 故 <span class="math display">\[
f_i = \begin{cases}
f_{i+1} &amp;(i &lt; d)\\
\dfrac {\frac in+(i-1)f_{i+1}}i &amp;(i \ge d)
\end{cases}
\]</span> 考虑当 <span class="math inline">\(i \ge d\)</span> 时 <span class="math display">\[
f_i=\frac {i-1}if_{i+1}+\frac 1n\\
\frac 1{i-1}f_i=\frac 1if_{i+1}+\frac 1{n(i-1)}
\]</span> 设 <span class="math inline">\(g_i = \frac 1{i-1}f_i\)</span>，则 <span class="math display">\[
\begin{aligned}
&amp;g_i=g_{i+1}+\frac 1{n(i-1)}\\
&amp;=\sum_{j=i-1}^n\frac 1{nj}\\
&amp;=\frac 1n\sum_{j=i-1}^n\frac 1j
\end{aligned}
\Rightarrow
f_i=\frac {i-1}n\sum_{j=i-1}^n\frac 1j
\]</span> 预处理调和数列前缀和后，对于每个 <span class="math inline">\(n\)</span>，可以二分出 <span class="math inline">\(d\)</span>，答案即为 <span class="math display">\[
\frac {d-1}n\sum_{i=d-1}^n\frac 1i
\]</span> 复杂度 <span class="math inline">\(O(n_{\max}+T)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> e = <span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> T, n; ll inv[N], s[N];</span><br><span class="line"><span class="keyword">double</span> S[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, <span class="number">1000000</span>) inv[i] = P / i * -inv[P % i] % P;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">1000000</span>) S[i] = S[i - <span class="number">1</span>] + <span class="number">1.</span> / i, (s[i] += s[i - <span class="number">1</span>] + inv[i]) %= P;</span><br><span class="line">    <span class="keyword">for</span>(cin &gt;&gt; T; T--;) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">upper_bound</span>(S + <span class="number">1</span>, S + n + <span class="number">1</span>, S[n - <span class="number">1</span>] - <span class="number">1</span>) - S;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((s[n - <span class="number">1</span>] - s[k - <span class="number">1</span>]) * k % P * inv[n] % P + P) % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>动态规划</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>梦现时刻 | 洛谷 P7481</title>
    <url>/luogu7481/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P7481">题目链接</a></p>
<p>给定 <span class="math inline">\(n,m\)</span>，保证 <span class="math inline">\(m \le n\)</span>，设 <span class="math inline">\(f(a,b)=\sum\limits_{i=0}^b\binom bi\binom {n-i}a\)</span>。</p>
<p>求 <span class="math inline">\(\bigoplus\limits_{a=1}^m\bigoplus\limits_{b=1}^m\left(f(a,b) \bmod 998244353\right)\)</span>。</p>
<p><span class="math inline">\(n \le 10^9,m \le 5000\)</span></p>
</blockquote>
<h3 id="引理">引理</h3>
<p><span class="math display">\[
\sum_{a=0}^n f(a,b)x^a=(x+2)^b(x+1)^{n-b}
\]</span></p>
<h4 id="证明一">证明一：</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{a=0}^n f(a,b)x^a\\
&amp;=\sum_{a=0}^n\sum\limits_{i=0}^b\binom bi\binom {n-i}ax^a\\
&amp;=\sum_{i=0}^b\binom bi\sum_{a=0}^n\binom {n-i}ax^a\\
&amp;=\sum_{i=0}^b\binom bi(x+1)^{n-i}\\
&amp;=\sum_{i=0}^b\binom bi(x+1)^{b-i}(x+1)^{n-b}\\
&amp;=(x+2)^b(x+1)^{n-b}
\end{aligned}
\]</span></p>
<h4 id="证明二">证明二</h4>
<p>考虑 <span class="math inline">\(f(a,b)\)</span> 的组合意义：有 <span class="math inline">\(n\)</span> 个人，其中 <span class="math inline">\(b\)</span> 个人比较强，要选出两批人：</p>
<ul>
<li>先从比较强的 <span class="math inline">\(b\)</span> 个人中选出 <span class="math inline">\(i\)</span> 个人作为第一批。</li>
<li>再从剩下的 <span class="math inline">\(n-i\)</span> 个人中选出 <span class="math inline">\(a\)</span> 个人作为第二批。</li>
</ul>
<p>因为要对 <span class="math inline">\(i \in [0,b]\)</span> 求和，所以 <span class="math inline">\(f(a,b)\)</span> 表示第一批的人数任意，第二批的人数为 <span class="math inline">\(a\)</span> 的方案数。</p>
<p>换一个角度看这个方案数：设第二批的 <span class="math inline">\(a\)</span> 个人中有 <span class="math inline">\(x\)</span> 个人比较强，<span class="math inline">\(y\)</span> 个人不强（<span class="math inline">\(a=x+y\)</span>）。</p>
<ul>
<li><p>对于一个比较强的人，如果他入选第二批，方案数为 <span class="math inline">\(1\)</span>，否则他既可能入选第一批，也可能落选，方案数为 <span class="math inline">\(2\)</span>。</p>
<p>因此比较强的 <span class="math inline">\(b\)</span> 个人入选的情况数的生成函数为 <span class="math inline">\((x+2)^b\)</span>。</p></li>
<li><p>对于一个不强的人，如果他入选第二批，方案数为 <span class="math inline">\(1\)</span>，否则他落选了，方案数为 <span class="math inline">\(1\)</span>。</p>
<p>因此不强的 <span class="math inline">\(n-b\)</span> 个人入选的情况数的生成函数为 <span class="math inline">\((x+1)^{n-b}\)</span>。</p></li>
</ul>
<p>综上，得到 <span class="math inline">\(\sum\limits_{a=0}^n f(a,b)x^a=(x+2)^b(x+1)^{n-b}\)</span>。</p>
<h3 id="两种解法">两种解法</h3>
<h4 id="类-01-背包-dp">类 01 背包 <code>DP</code></h4>
<p>根据引理，有 <span class="math display">\[
\sum_{a=0}^n f(a,b)x^a=\frac {x+2}{x+1}\sum_{a=0}^nf(a,b-1)x^a
\]</span> 乘 <span class="math inline">\(x+2\)</span> 相当于添加一个物品，除以 <span class="math inline">\(x+1\)</span> 相当于删除一个物品，后者用可撤销背包解决。</p>
<p>复杂度 <span class="math inline">\(O(m^2)\)</span>。</p>
<h4 id="递推">递推</h4>
<p>考虑 <span class="math display">\[
\begin{aligned}
&amp;[(x+2)^b(x+1)^{n-b}]&#39;\\
&amp;=b(x+2)^{b-1}(x+1)^{n-b}+(x+2)^b(n-b)(x+1)^{n-b-1}\\
&amp;=\dfrac{b(x+1)+(n-b)(x+2)}{(x+2)(x+1)}(x+2)^b(x+1)^{n-b}\\
&amp;=\dfrac{nx+2n-b}{(x+2)(x+1)}(x+2)^b(x+1)^{n-b}\\
\end{aligned}
\]</span> 两边同乘 <span class="math inline">\((x+2)(x+1)\)</span> 得： <span class="math display">\[
(x+2)(x+1)[(x+2)^b(x+1)^{n-b}]&#39;=(nx+2n-b)(x+2)^b(x+1)^{n-b}
\]</span> 提取 <span class="math inline">\(x^a\)</span> 系数： <span class="math display">\[
\begin{aligned}
&amp;(a-1)f(a-1,b)+3af(a,b)+2(a+1)f(a+1,b)\\
&amp;=nf(a-1,b)+(2n-b)f(a,b)
\end{aligned}
\]</span> 整理得： <span class="math display">\[
f(a+1,b)=\frac {(2n-b-3a)f(a,b)+(n-a+1)f(a-1,b)}{2(a+1)}
\]</span> 进一步： <span class="math display">\[
f(a,b)=\frac {(2n-b-3a+3)f(a-1,b)+(n-a+2)f(a-2,b)}{2a}
\]</span> 对于 <span class="math inline">\(b \in [1,m]\)</span> 都递推一遍即可。</p>
<p>复杂度 <span class="math inline">\(O(m^2)\)</span>。</p>
<p>代码（类 01 背包 <code>DP</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> inv[<span class="number">5005</span>], f[<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    f[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, m) inv[i] = (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) f[i] = f[i - <span class="number">1</span>] * (n - i + <span class="number">1</span>) % P * inv[i] % P;</span><br><span class="line">    <span class="keyword">int</span> as = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">per</span>(j, m, <span class="number">0</span>) f[j] = (f[j] * <span class="number">2</span> + f[j - <span class="number">1</span>]) % P;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) as ^= f[j] = (f[j] + P - f[j - <span class="number">1</span>]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; as;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码（递推）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> inv[<span class="number">10005</span>], f[<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, m * <span class="number">2</span>) inv[i] = (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="keyword">int</span> as = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        (f[<span class="number">0</span>] *= <span class="number">2</span>) %= P;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) as ^= f[j] = (((n * <span class="number">2</span> - i - j * <span class="number">3</span> + <span class="number">3</span>) * f[j - <span class="number">1</span>] + (n - j + <span class="number">2</span>) * f[j - <span class="number">2</span>]) % P * inv[j * <span class="number">2</span>] % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; as;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷月赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>生成函数</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>不条理狂诗曲 | 洛谷 P7482</title>
    <url>/luogu7482/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P7482">题目链接</a></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span>，定义 <span class="math inline">\(f(l,r)\)</span> 表示从区间 <span class="math inline">\([l,r]\)</span> 中选择若干不相邻的数的和的最大值。</p>
<p>求 <span class="math inline">\(\sum\limits_{l=1}^n\sum\limits_{r=l}^nf(l,r) \bmod 10^9 + 7\)</span>。</p>
<p><span class="math inline">\(n \le 10^5,0 \le a_i \le 10^9\)</span></p>
</blockquote>
<p><span class="math inline">\(f(l,r)\)</span> 显然可以通过 <code>DP</code> 在 <span class="math inline">\(O(r-l+1)\)</span> 的时间内求出，枚举左端点或右端点来计算答案都不太行得通，因为端点移动一步后难以快速维护。</p>
<p>但所有包含同一位置 <span class="math inline">\(p\)</span> 的区间（<span class="math inline">\(p\)</span> 是端点不算）的 <span class="math inline">\(f\)</span> 值之和却可以快速计算，因为枚举了 <span class="math inline">\(p\)</span> 选不选后，<span class="math inline">\(p\)</span> 左右的部分是<strong>独立的</strong>。</p>
<p>对于一个包含 <span class="math inline">\(p\)</span> 的区间 <span class="math inline">\([l,r]\)</span>，有 <span class="math display">\[
f(l,r)=\max\{f(l,p-1)+f(p+1,r),f(l,p-2)+f(p+2,r)+A_p\}
\]</span> 设 <span class="math display">\[
x_i=\begin{cases}f(i,p-1)&amp;(i &lt; p)\\f(p+1,i)&amp;(i&gt;p)\\0&amp;(i=p)\end{cases},y_i=\begin{cases}f(i,p-2)&amp;(i&lt;p-1)\\f(p+2,i)&amp;(i&gt;p+1)\\0&amp;(p-1 \le i \le p+1)\end{cases}
\]</span> <span class="math inline">\(x,y\)</span> 数组可以通过 <code>DP</code> 在 <span class="math inline">\(O(n)\)</span> 的时间内求出。 <span class="math display">\[
f(l,r)=\max\{x_l+x_r,y_l+y_r+A_p\}\\
x_l+x_r \ge y_l + y_r + A_p \iff (x_l - y_l) + (x_r - y_r) \ge A_p
\]</span> 把所有除 <span class="math inline">\(p\)</span> 以外的位置按 <span class="math inline">\(x_i-y_i\)</span> 为关键字升序排序，再用双指针扫描一遍即可求出所有包含 <span class="math inline">\(p\)</span> （<span class="math inline">\(p\)</span> 是端点不算）的 <span class="math inline">\(f\)</span> 值之和，单次的复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>接下来就是套路了，考虑分治，定义函数 <span class="math inline">\(solve(L,R)\)</span> 表示 <span class="math inline">\(\sum\limits_{l=L}^R\sum\limits_{r=l}^Rf(l,r)\)</span>。</p>
<p>令 <span class="math inline">\(mid = \lfloor \frac {L + R}2 \rfloor\)</span>，那么 <span class="math inline">\(solve(L, R) = solve(L, mid) + solve(mid, R) - A_{mid} + \sum\limits_{l=L}^{mid-1}\sum\limits_{r=mid+1}^Rf(l,r)\)</span>。</p>
<p>最后一项用上述方法计算，总复杂度为 <span class="math inline">\(O(n \log^2 n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span> + <span class="number">7</span>, Inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> n; ll a[N], f[N][<span class="number">2</span>][<span class="number">2</span>], A[N], B[N], as;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; (as += a[l]) %= P; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(r == l + <span class="number">1</span>) &#123; (as += a[l] + a[r] + <span class="built_in">max</span>(a[l], a[r])) %= P; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">1</span>) f[mid][i][i] = <span class="number">0</span>, f[mid][i][!i] = -Inf;</span><br><span class="line">    <span class="built_in">rep</span>(i, mid + <span class="number">1</span>, r) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">        f[i][j][<span class="number">1</span>] = f[i - <span class="number">1</span>][j][<span class="number">0</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">per</span>(i, mid - <span class="number">1</span>, l) <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i + <span class="number">1</span>][j][<span class="number">0</span>], f[i + <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">        f[i][j][<span class="number">1</span>] = f[i + <span class="number">1</span>][j][<span class="number">0</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">rep</span>(i, l, r) <span class="keyword">if</span>(i ^ mid) &#123;</span><br><span class="line">        v.<span class="built_in">pb</span>(i);</span><br><span class="line">        A[i] = <span class="built_in">max</span>(f[i][<span class="number">0</span>][<span class="number">0</span>], f[i][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        B[i] = <span class="built_in">max</span>(f[i][<span class="number">1</span>][<span class="number">0</span>], f[i][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123; <span class="keyword">return</span> A[i] - B[i] &lt; A[j] - B[j]; &#125;);</span><br><span class="line">    <span class="keyword">int</span> j = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    ll sua = <span class="number">0</span>, sub = <span class="number">0</span>; <span class="keyword">int</span> cna = <span class="number">0</span>, cnb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : v) <span class="keyword">if</span>(i &gt; mid) (sub += B[i]) %= P, cnb++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : v) <span class="keyword">if</span>(i &lt; mid) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; (v[j] &lt; mid || A[i] - B[i] + A[v[j]] - B[v[j]] &gt; a[mid])) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j] &gt; mid) (sua += A[v[j]]) %= P, (sub -= B[v[j]]) %= P, cna++, cnb--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        (as += (a[mid] + B[i]) * cnb + A[i] * cna + sua + sub) %= P;</span><br><span class="line">    &#125;</span><br><span class="line">    (as -= a[mid]) %= P, <span class="built_in">solve</span>(l, mid), <span class="built_in">solve</span>(mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line">    cout &lt;&lt; (as + P) % P;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷月赛</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Kuroni and Antihype | Codeforces 1305G</title>
    <url>/CF1305G/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/1305/problem/G">题目链接</a></p>
<p>一张有 <span class="math inline">\(n\)</span> 个点的图，每个点的点权为 <span class="math inline">\(a_i\)</span>。</p>
<p>点 <span class="math inline">\(u\)</span> 和点 <span class="math inline">\(v\)</span> 连边当且仅当 <span class="math inline">\(a_u \&amp; a_v = 0\)</span>。</p>
<p>对于点 <span class="math inline">\(u\)</span>，有两种操作：</p>
<ul>
<li>直接涂黑，无贡献。</li>
<li>找一个与 <span class="math inline">\(u\)</span> 相邻且已经涂黑的点 <span class="math inline">\(v\)</span>，再涂黑 <span class="math inline">\(u\)</span>，贡献为 <span class="math inline">\(a_v\)</span>。</li>
</ul>
<p>求涂黑所有点的最大贡献。</p>
<p><span class="math inline">\(n \le 2 \cdot 10^5,a_i \le 2 \cdot 10^5\)</span></p>
</blockquote>
<p>首先加入一个点权为 <span class="math inline">\(0\)</span> 的虚点，且初始为黑，则两种操作就可以统一成第二种。</p>
<p>对于每次操作，就从 <span class="math inline">\(u\)</span> 向 <span class="math inline">\(v\)</span> 连一条有向边，得到一个以 <span class="math inline">\(0\)</span> 为根的有根树。</p>
<p>设点 <span class="math inline">\(u\)</span> 的度数为 <span class="math inline">\(degree_u\)</span>，则总贡献可以表示为 <span class="math display">\[
\sum_{u \in V}a_u(degree_u-1)=\sum_{u \in V}a_udegree_u-\sum_{u \in V}a_u = \sum_{(u,v) \in E}a_u + a_v - \sum_{u \in V}a_u
\]</span> 如果定义 <span class="math inline">\((u,v)\)</span> 边权为 <span class="math inline">\(a_u + a_v\)</span>，则前一部分为生成树权值，后一部分是定值。</p>
<p>所以问题转化为求最大生成树。</p>
<h3 id="先考虑所有点的点权两两不同">先考虑所有点的点权两两不同。</h3>
<p>根据枚举子集的经典结论，边的总数小于 <span class="math inline">\(3^{18}\)</span>，但实际只有一半左右，即 <span class="math inline">\(1.7 \cdot 10^8\)</span> 左右。</p>
<p>考虑 <code>Kruskal</code> 算法，虽然并查集复杂度要乘一个 <span class="math inline">\(\alpha(n)\)</span>，但感觉卡不满。</p>
<p>首先不可能存下所有边，更不可能排序，所以考虑从大到小枚举边权。</p>
<p>注意到 <span class="math inline">\(u,v\)</span> 连边当且仅当 <span class="math inline">\(a_u \&amp; a_v = 0\)</span>，而边权为 <span class="math inline">\(a_u + a_v\)</span>。</p>
<p>直接枚举边权的子集就可以得到两个端点。</p>
<p>剩下的正常做 <code>Kruskal</code> 就行了。</p>
<p>复杂度 <span class="math inline">\(O(3^{18}\alpha(n))\)</span>。</p>
<h3 id="点权相同时">点权相同时</h3>
<p>当枚举到 <span class="math inline">\(a_u,a_v\)</span> 时，<span class="math inline">\(a_u\)</span> 可能会对应很多的 <span class="math inline">\(u\)</span>，设这些 <span class="math inline">\(u\)</span> 构成集合 <span class="math inline">\(U\)</span>，<span class="math inline">\(a_v\)</span> 也会对应很多的 <span class="math inline">\(a_v\)</span>，设这些 <span class="math inline">\(v\)</span> 构成集合 <span class="math inline">\(V\)</span>。</p>
<p>任何一个 <span class="math inline">\(U\)</span> 中的结点和任何一个 <span class="math inline">\(V\)</span> 中的结点都有权值相等的连边，边太多了。</p>
<p>考虑一个等价的连边：</p>
<p>在 <span class="math inline">\(U\)</span> 中选择一个代表元 <span class="math inline">\(u_0\)</span>，同理选个 <span class="math inline">\(v_0\)</span>，<span class="math inline">\(u_0\)</span> 和 <span class="math inline">\(v_0\)</span> 连边，<span class="math inline">\(u_0\)</span> 和 <span class="math inline">\(U\)</span> 中其他点连边，<span class="math inline">\(v_0\)</span> 和 <span class="math inline">\(V\)</span> 中其他点连边。</p>
<p>对于后两种连边，每个集合只用在第一次访问到时进行，复杂度 <span class="math inline">\(O(3^{18}\alpha(n))\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd(a, b) (a = min(a, b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N], fa[N], sz[N], vis[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; nds[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll as = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), as -= a[i];</span><br><span class="line">        nds[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    nds[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">per</span>(S, N - <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> T = S; T &gt; S / <span class="number">2</span>; --T &amp;= S) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nds[T].<span class="built_in">empty</span>() || nds[S ^ T].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> mrg = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> v) &#123;</span><br><span class="line">            u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(u == v) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(sz[u] &lt; sz[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            fa[v] = u, sz[u] += sz[v];</span><br><span class="line">            as += S;</span><br><span class="line">            <span class="keyword">if</span>(sz[u] == n + <span class="number">1</span>) cout &lt;&lt; as, <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">mrg</span>(nds[T][<span class="number">0</span>], nds[S ^ T][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!vis[T]) <span class="keyword">for</span>(<span class="keyword">int</span> u : nds[T]) <span class="built_in">mrg</span>(u, nds[S ^ T][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!vis[S ^ T]) <span class="keyword">for</span>(<span class="keyword">int</span> v : nds[S ^ T]) <span class="built_in">mrg</span>(nds[T][<span class="number">0</span>], v);</span><br><span class="line">        vis[T] = vis[S ^ T] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>Cycling City | Codeforces 521E</title>
    <url>/CF521E/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/521/problem/E">题目链接</a></p>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的简单无向图。</p>
<p>问在图中能否找到两个点，满足这两个点之间有至少三条点不相交的简单路径，有解要打印三条路径。</p>
<p><span class="math inline">\(n,m \le 2 \cdot 10^5\)</span> 不保证图连通。</p>
</blockquote>
<p>考虑 <span class="math inline">\(u \rightarrow v\)</span> 有三条点不相交的路径会是什么样子，发现有两个环相交了。</p>
<p><img src="https://i.loli.net/2021/04/03/k3PV8WRYS4Uqmon.png" /></p>
<p>反过来，如果任意两个环都不相交，即仙人掌，那就无解。</p>
<p>至此，得到了有解的充要条件：不是仙人掌。</p>
<p>但为了便于打印路径，采用另一种方法。</p>
<p>设 <span class="math inline">\(low_u\)</span> 为 <code>tarjan</code> 算法中的定义，<span class="math inline">\(Low_u\)</span> 表示次小值。</p>
<p>如果 <span class="math inline">\(Low_u = dfn_u\)</span>，则子树内的一个点到子树外的一个点至多有两条点不相交的简单路径。</p>
<p>于是存在满足 <span class="math inline">\(Low_u &lt; dfn_u\)</span> 的点 <span class="math inline">\(u\)</span> 是有解的必要条件。</p>
<p>观察这张图，如果 <span class="math inline">\(lca(v,V)=u\)</span>，那么 <span class="math inline">\(u \rightarrow Low\)</span>，<span class="math inline">\(u \rightarrow v \rightarrow low \rightarrow Low\)</span> 和 <span class="math inline">\(u \rightarrow V \rightarrow Low\)</span> 是三条点不相交的简单路径。</p>
<p><img src="https://i.loli.net/2021/04/03/tQCALX5ah47RU9f.png" /></p>
<p>只要以 <span class="math inline">\(u\)</span> 为根的子树中只有 <span class="math inline">\(u\)</span> 一个点满足 <span class="math inline">\(Low_u &lt; dfn_u\)</span>，则 <span class="math inline">\(lca(v, V) = u\)</span>。</p>
<p>在 <code>dfs</code> 过程中第一次找到满足 <span class="math inline">\(Low_u &lt; dfn_u\)</span> 的点 <span class="math inline">\(u\)</span> 即符合上一行的条件，因为它是子树中最后判定的点。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> vector &lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">int</span> n, m; vi G[N];</span><br><span class="line"><span class="keyword">int</span> idx, dfn[N], fa[N], ma;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, fa, U, Fa;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> uu) &#123; u = fa = U = Fa = uu; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> uu, <span class="keyword">int</span> ffa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[ffa] &lt; dfn[fa]) U = u, Fa = fa, u = uu, fa = ffa;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[ffa] &lt; dfn[Fa]) U = uu, Fa = ffa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="built_in">as</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function">node <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++idx; <span class="function">node <span class="title">lowu</span><span class="params">(u)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">        fa[v] = u;</span><br><span class="line">        node lowv = <span class="built_in">dfs</span>(v);</span><br><span class="line">        lowu.<span class="built_in">upd</span>(lowv.u, lowv.fa), lowu.<span class="built_in">upd</span>(lowv.U, lowv.Fa);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v ^ fa[u]) lowu.<span class="built_in">upd</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span>(!ma &amp;&amp; dfn[lowu.Fa] &lt; dfn[u]) as = lowu, ma = u;</span><br><span class="line">    <span class="keyword">return</span> lowu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vi <span class="title">find</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    vi p;</span><br><span class="line">    <span class="keyword">while</span>(s ^ t) p.<span class="built_in">pb</span>(s), s = fa[s];</span><br><span class="line">    p.<span class="built_in">pb</span>(t);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">vi p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llu &quot;</span>, p.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u : p) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v), G[u].<span class="built_in">pb</span>(v), G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span>(!ma &amp;&amp; !dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(ma) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        p = <span class="built_in">find</span>(ma, as.Fa), <span class="built_in">print</span>();</span><br><span class="line">        p = <span class="built_in">find</span>(as.U, ma), <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">        p.<span class="built_in">pb</span>(as.Fa), <span class="built_in">print</span>();</span><br><span class="line">        p = <span class="built_in">find</span>(as.Fa, as.fa); vi t = <span class="built_in">find</span>(as.u, ma);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">end</span>(), t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), <span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Case of Computer Network | Codeforces 555E</title>
    <url>/CF555E/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/555/problem/E">题目链接</a></p>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图和 <span class="math inline">\(q\)</span> 组有序点对 <span class="math inline">\((s_i,t_i)\)</span>。</p>
<p>询问是否可以给每条边定向，使得所有的 <span class="math inline">\(s_i\)</span> 都能到达 <span class="math inline">\(t_i\)</span>。</p>
<p><span class="math inline">\(n,m,q \le 2 \cdot 10^5\)</span> 不保证图连通，可能有重边。</p>
</blockquote>
<p>先假设有解，尝试求出一组解，再判定这组解合不合法。</p>
<h3 id="构造解">构造解</h3>
<p>一个经典结论：</p>
<blockquote>
<p>一个<strong>边双连通分量</strong>存在一种给每条边定向的方案，使之成为<strong>强连通分量</strong>。</p>
<p>一个<strong>强连通分量</strong>把有向边变成无向边后成为<strong>边双连通分量</strong>。</p>
</blockquote>
<p>对于前者直接让树边向下，反向边向上即可。</p>
<p>对于后者考虑一条有向边的两个端点可以相互到达，推出这条边在一个简单环上。</p>
<p>把图中的边双全部定向成强连通分量，接下来只需要给所有<strong>桥</strong>定向，以使 <span class="math inline">\(s_i\)</span> 所在的边双能到达 <span class="math inline">\(t_i\)</span> 所在的边双。</p>
<p>其实无需求边双，只需求出哪些边是桥即可，<strong>由于此题有重边，<code>tarjan</code> 算法应当记录上一条边而不是父亲</strong>。</p>
<p>建出 <code>dfs</code> 树，对于每组 <span class="math inline">\((s_i,t_i)\)</span>，要求 <span class="math inline">\(s_i\)</span> 到 <span class="math inline">\(t_i\)</span> 路径上的桥由 <span class="math inline">\(s_i\)</span> 指向 <span class="math inline">\(t_i\)</span>。</p>
<p>让 <span class="math inline">\(s_i \rightarrow lca\)</span> 上的边 <span class="math inline">\(+1\)</span>，<span class="math inline">\(lca \rightarrow t_i\)</span> 上的边 <span class="math inline">\(-1\)</span>，树上差分转换为 <span class="math inline">\(s_i\)</span> 处 <span class="math inline">\(+1\)</span>，<span class="math inline">\(t_i\)</span> 处 <span class="math inline">\(-1\)</span>，<span class="math inline">\(lca\)</span> 处不变。</p>
<p><img src="https://i.loli.net/2021/04/03/t6zWCK1xuaEgcb5.png" /></p>
<p>一条边的最终权值如果为正，则必须向上，为负则必须向下，为 <span class="math inline">\(0\)</span> 则都可以。</p>
<h3 id="判定">判定</h3>
<p>检验 <span class="math inline">\(s_i \rightarrow lca\)</span> 上的边是否全部为正，<span class="math inline">\(lca \rightarrow t_i\)</span> 上的边是否全部为负。</p>
<p>记 <span class="math inline">\(up_u\)</span> 表示从 <span class="math inline">\(u\)</span> 开始只经过非桥边和权值为<strong>正</strong>的桥边能到达的深度最小的结点。</p>
<p><span class="math inline">\(down_u\)</span> 表示从 <span class="math inline">\(u\)</span> 开始只经过非桥边和权值为<strong>负</strong>的桥边能到达的深度最小的结点。</p>
<p>如果 <span class="math inline">\(up_{s_i}\)</span> 和 <span class="math inline">\(down_{t_i}\)</span> 中深度较大者是 <span class="math inline">\(s_i\)</span> 和 <span class="math inline">\(t_i\)</span> 的公共祖先 <span class="math inline">\((s_i,t_i)\)</span> 就合法，使用 <code>dfs</code> 序可判定。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, idx, dfn[N], suf[N], cut[N];</span><br><span class="line">vector &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> vis[N], sz[N], s[N], t[N], up[N], down[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowu = dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w] : G[u]) <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">        <span class="keyword">int</span> lowv = <span class="built_in">dfs</span>(v, w);</span><br><span class="line">        lowu = <span class="built_in">min</span>(lowu, lowv), cut[v] = lowv &gt; dfn[u];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(w ^ lst &amp;&amp; dfn[v] &lt; dfn[u]) lowu = <span class="built_in">min</span>(lowu, dfn[v]);</span><br><span class="line">    suf[u] = idx;</span><br><span class="line">    <span class="keyword">return</span> lowu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w] : G[u]) <span class="keyword">if</span>(!vis[v]) <span class="built_in">Dfs</span>(v), sz[u] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>, up[u] = up[fa], down[u] = down[fa];</span><br><span class="line">    <span class="keyword">if</span>(!fa || (cut[u] &amp;&amp; sz[u] &lt;= <span class="number">0</span>)) up[u] = u;</span><br><span class="line">    <span class="keyword">if</span>(!fa || (cut[u] &amp;&amp; sz[u] &gt;= <span class="number">0</span>)) down[u] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w] : G[u]) <span class="keyword">if</span>(!vis[v]) <span class="built_in">DFs</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; </span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(&#123;v, ++idx&#125;), G[v].<span class="built_in">push_back</span>(&#123;u, idx&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s[i], &amp;t[i]), sz[s[i]]++, sz[t[i]]--;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span>(!vis[i]) <span class="built_in">Dfs</span>(i);</span><br><span class="line">    <span class="built_in">mem</span>(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span>(!vis[i]) <span class="built_in">DFs</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        <span class="keyword">int</span> lca = dfn[up[s[i]]] &gt; dfn[down[t[i]]] ? up[s[i]] : down[t[i]];</span><br><span class="line">        <span class="keyword">if</span>(dfn[s[i]] &gt; dfn[t[i]]) <span class="built_in">swap</span>(s[i], t[i]);</span><br><span class="line">        <span class="keyword">if</span>(dfn[s[i]] &lt; dfn[lca] || dfn[t[i]] &gt; suf[lca]) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>边双连通分量</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>Christmas Game | Codeforces 1498F</title>
    <url>/CF1498F/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/1498/problem/F">题目链接</a></p>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树和 <span class="math inline">\(k\)</span>，每个结点上有 <span class="math inline">\(a_i\)</span> 个物品，<code>Alice</code> 和 <code>Bob</code> 在上面玩游戏。</p>
<p>在确定根之后，两个玩家轮流选择任意一个存在 <span class="math inline">\(k\)</span> 级祖先的结点 <span class="math inline">\(u\)</span>，然后把 <span class="math inline">\(u\)</span> 的任意个物品移到 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(k\)</span> 级祖先上。</p>
<p>最后没有物品可取的人输。</p>
<p>问当每个结点作为根时，谁必胜。</p>
<p><span class="math inline">\(n \le 10^5, k \le 20,a_i \le 10^9\)</span></p>
</blockquote>
<p>当 <span class="math inline">\(k=1\)</span> 时，它几乎是一个<a href="http://coding-pages-bucket-3532178-8430896-13917-522304-1305159063.cos-website.ap-hongkong.myqcloud.com/nim-you-xi-and-sg-ding-li/">阶梯 <code>NIM</code> 游戏</a>。</p>
<p>设根结点深度为 <span class="math inline">\(0\)</span>，根据阶梯 <code>NIM</code> 游戏的结论，原问题等价于所有深度为奇数的结点做 <code>NIM</code> 游戏，即先手必胜当且仅当所有深度为奇数的结点的 <span class="math inline">\(a_i\)</span> 异或和不为 <span class="math inline">\(0\)</span>。</p>
<p>对于一般的情况，先手必胜当且仅当 <span class="math display">\[
\bigoplus_{\big\lfloor \frac {depth_u}k \big\rfloor 为奇数}a_u \ne 0
\]</span> 设 <span class="math inline">\(f_{u,i}\)</span> 表示以 <span class="math inline">\(u\)</span> 为根的子树里，所有满足 <span class="math inline">\(depth_v - depth_u \equiv i \pmod {2k}\)</span> 的结点 <span class="math inline">\(v\)</span> 的点权异或和。</p>
<p>然后换根 <code>DP</code> 一下即可。</p>
<p>复杂度 <span class="math inline">\(O(nk)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N];</span><br><span class="line">ll f[N][<span class="number">40</span>], ans[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, K) f[u][(i + <span class="number">1</span>) % K] ^= f[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = a[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) <span class="keyword">if</span>(v ^ fa) <span class="built_in">dfs</span>(v, u), <span class="built_in">add</span>(u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i, K / <span class="number">2</span>, K) ans[u] ^= f[u][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) <span class="keyword">if</span>(v ^ fa) <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u), <span class="built_in">Dfs</span>(v, u), <span class="built_in">add</span>(v, u), <span class="built_in">add</span>(u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K, K *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v), G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">Dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i] != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>博弈论</tag>
        <tag>阶梯 NIM 游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>NIM 游戏 &amp; SG 定理</title>
    <url>/nim-you-xi-and-sg-ding-li/</url>
    <content><![CDATA[<p>定义<strong>必胜状态</strong>为<strong>当前局面先手必胜的状态</strong>，<strong>必败状态</strong>为<strong>当前局面先手必败的状态</strong>。</p>
<h3 id="有向图游戏">有向图游戏</h3>
<blockquote>
<p>在一个<strong>有向无环图</strong>中，只有一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负。</p>
</blockquote>
<p>对于点 <span class="math inline">\(u\)</span> 和它的 <span class="math inline">\(k\)</span> 个后继点 <span class="math inline">\(v_1,v_2,\cdots,v_k\)</span>，定义 <code>SG</code> 函数： <span class="math display">\[
SG(u)=\text{mex}\{SG(v_1),SG(v_2),\cdots,SG(v_k)\}
\]</span> 特别地，当 <span class="math inline">\(u\)</span> 没有后继状态时 <span class="math inline">\(SG(u)=0\)</span>。</p>
<p>显然，先手必胜当且仅当 <span class="math inline">\(SG(u) \ne 0\)</span>。</p>
<p>对于 <span class="math inline">\(n\)</span> 个有向图游戏组合而成的游戏，即两个玩家轮流推动 <span class="math inline">\(n\)</span> 个棋子之一，设这个游戏的初始状态为 <span class="math inline">\(S\)</span>，棋子的起点分别为 <span class="math inline">\(s_1,s_2,\cdots,s_n\)</span>，则有 <strong><code>SG</code> 定理</strong>：</p>
<p><span class="math inline">\(SG(S) = SG(s_1) \oplus SG(s_2) \oplus \cdots \oplus SG(s_n)\)</span>。</p>
<p>证明：由于组合而成的游戏也是有向图游戏，因此所有的状态存在一个拓扑序，以下使用<strong>数学归纳法</strong>证明：</p>
<ul>
<li><p>归纳奠基：对于没有后继的状态 <span class="math inline">\(S\)</span>，<span class="math inline">\(\forall i \in [1,n], SG(s_i)=0, SG(S)=0\)</span>，命题成立。</p></li>
<li><p>归纳假设：设当前状态 <span class="math inline">\(S\)</span> 满足 <span class="math inline">\(SG(s_1) + SG(s_2) + \cdots + SG(s_n) = m\)</span>，对于所有满足 <span class="math inline">\(SG(s_1&#39;) + SG(s_2&#39;) + \cdots + SG(s_n&#39;) &lt; m\)</span> 的状态以及所有满足 <span class="math inline">\(SG(s_1&#39;) + SG(s_2&#39;) + \cdots + SG(s_n&#39;) = m\)</span> 并且拓扑序小于 <span class="math inline">\(S\)</span> 的状态命题成立。</p></li>
<li><p>归纳递推：设 <span class="math inline">\(SG(s_1) \oplus SG(s_2) \oplus \cdots \oplus SG(s_n) =k\)</span>。</p>
<p>先证明 <span class="math inline">\(\forall k&#39; &lt; k\)</span>, <span class="math inline">\(S\)</span> 都存在一个后继状态 <span class="math inline">\(S&#39;\)</span> 满足 <span class="math inline">\(SG(S&#39;)=k&#39;\)</span>。</p>
<p>设 <span class="math inline">\(k \oplus k&#39;\)</span> 在二进制下的最高位为第 <span class="math inline">\(m\)</span> 位，因为 <span class="math inline">\(k&#39; &lt; k\)</span>, 所以 <span class="math inline">\(k&#39;\)</span> 的第 <span class="math inline">\(m\)</span> 位为 <span class="math inline">\(0\)</span>，<span class="math inline">\(k\)</span> 的第 <span class="math inline">\(m\)</span> 位为 <span class="math inline">\(1\)</span>。</p>
<p>根据异或定义，存在 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(SG(s_i)\)</span> 的第 <span class="math inline">\(m\)</span> 位为 <span class="math inline">\(1\)</span>。</p>
<p>那么 <span class="math inline">\(SG(s_i) \oplus k \oplus k&#39; &lt; SG(s_i)\)</span>，根据 <code>SG</code> 函数定义，<span class="math inline">\(s_i\)</span> 一定存在后继点 <span class="math inline">\(s_i&#39;\)</span>，满足 <span class="math inline">\(SG(s_i&#39;) = SG(s_i) \oplus k \oplus k&#39;\)</span>。</p>
<p>把 <span class="math inline">\(s_i\)</span> 推到 <span class="math inline">\(s_i&#39;\)</span> 后满足 <span class="math inline">\(SG(s_1) + SG(s_2) + \cdots + SG(s_i&#39;) + \cdots + SG(s_n) &lt; m\)</span>，因此 <span class="math inline">\(SG(S&#39;)=SG(s_1) \oplus SG(s_2) \oplus \cdots \oplus SG(s_i&#39;) \oplus \cdots \oplus SG(s_n)=k&#39;\)</span>。</p>
<p>再证明 <span class="math inline">\(S\)</span> 不存在后继状态 <span class="math inline">\(S&#39;\)</span> 满足 <span class="math inline">\(SG(S&#39;)=k\)</span>。</p>
<p>如果把 <span class="math inline">\(s_i\)</span> 推到 <span class="math inline">\(s_i&#39;\)</span>，一定 <span class="math inline">\(SG(s_i&#39;) \ne SG(s_i)\)</span>。</p>
<p>如果 <span class="math inline">\(SG(s_i&#39;) &lt; SG(s_i)\)</span>，那么 <span class="math inline">\(SG(s_1) + SG(s_2) + \cdots + SG(s_i&#39;) + \cdots + SG(s_n) &lt; m\)</span>，因此 <span class="math inline">\(SG(S&#39;)=SG(s_1) \oplus SG(s_2) \oplus \cdots \oplus SG(s_i&#39;) \oplus \cdots \oplus SG(s_n) \ne k\)</span>。</p>
<p>如果 <span class="math inline">\(SG(s_i&#39;) &gt; SG(s_i)\)</span>，那么 <span class="math inline">\(SG(s_1) + SG(s_2) + \cdots + SG(s_i&#39;) + \cdots + SG(s_n) &gt; m\)</span>，因此 <span class="math inline">\(SG(S&#39;)\)</span> 未知，但我们只需证 <span class="math inline">\(SG(S&#39;) \ne k\)</span>。根据 <code>SG</code> 函数定义，<span class="math inline">\(s_i&#39;\)</span> 一定存在后继点 <span class="math inline">\(s_i&#39;&#39;\)</span>，满足 <span class="math inline">\(SG(s_i&#39;&#39;) = SG(s_i)\)</span>，此时 <span class="math inline">\(SG(s_1) + SG(s_2) + \cdots + SG(s_i&#39;&#39;) + \cdots + SG(s_n) = m\)</span>，并且 <span class="math inline">\(S&#39;&#39;\)</span> 的拓扑序小于 <span class="math inline">\(S\)</span>，因此 <span class="math inline">\(SG(S&#39;&#39;)=SG(s_1) \oplus SG(s_2) \oplus \cdots \oplus SG(s_i&#39;&#39;) \oplus \cdots \oplus SG(s_n)=k\)</span>，所以一定有 <span class="math inline">\(SG(S&#39;) \ne k\)</span>。</p></li>
</ul>
<h3 id="nim-游戏">NIM 游戏</h3>
<p>很多的公平组合游戏都可以转化为多个有向图游戏的组合，比如 <strong>NIM 游戏</strong>。</p>
<blockquote>
<p><span class="math inline">\(n\)</span> 堆物品，每堆有 <span class="math inline">\(a_i\)</span> 个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。</p>
<p>取走最后一个物品的人获胜。</p>
</blockquote>
<p>对于每一堆石子，定义结点 <span class="math inline">\(x\)</span> 表示有 <span class="math inline">\(x\)</span> 个物品的状态。所有编号大的结点向编号小的结点连边。</p>
<p>这样，NIM 游戏就转化 <span class="math inline">\(n\)</span> 个有向图游戏的组合了。</p>
<p>易得 <span class="math inline">\(SG(x)=x\)</span>，根据 <code>SG</code> 定理，当且仅当 <span class="math inline">\(a_1 \oplus a_2 \oplus \cdots \oplus a_n \ne 0\)</span> 时，先手必胜。</p>
<h3 id="阶梯-nim-游戏">阶梯 NIM 游戏</h3>
<blockquote>
<p><span class="math inline">\(n\)</span> 堆物品，每堆有 <span class="math inline">\(a_i\)</span> 个，两个玩家轮流取走任意第 <span class="math inline">\(i\)</span> 堆（<span class="math inline">\(i &gt; 1\)</span>）的任意个物品移到第 <span class="math inline">\(i-1\)</span> 堆中，但不能不取。</p>
<p>最后没有物品可取的人输。</p>
</blockquote>
<p>结论：<strong>此游戏等价于 <span class="math inline">\(\lfloor \frac n2 \rfloor\)</span> 堆物品，每堆有 <span class="math inline">\(a_{2i}\)</span> 个物品的 NIM 游戏。</strong></p>
<p>不妨假设在 NIM 游戏中 <code>A</code> 必胜，<code>B</code> 必败，则 <code>A</code> 可以使用以下策略：</p>
<ul>
<li>如果前一步 <code>B</code> 从第 <span class="math inline">\(2i\)</span> 堆里取物品或者当前为第一步，<code>A</code> 按照 NIM 里的策略从对应的堆里取物品。</li>
<li>如果前一步 <code>B</code> 从第 <span class="math inline">\(2i+1\)</span> 堆里取物品，<code>A</code> 将这些物品再移到第 <span class="math inline">\(2i-1\)</span> 堆。</li>
</ul>
<p>这样奇数堆中的物品就不会影响胜负情况，而在偶数堆中取物品相当于直接删除（因为它们到奇数堆后就不会影响胜负情况）。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>阶梯 NIM 游戏</tag>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Houses | Codeforces 1498E</title>
    <url>/CF1498E/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/1498/problem/E">题目链接</a></p>
<p>有一张 <span class="math inline">\(n\)</span> 个点的竞赛图。</p>
<p>不会给这张竞赛图，但会给每个点的入度 <span class="math inline">\(k_i\)</span>。</p>
<p>还可以<strong>通过交互</strong>询问从 <span class="math inline">\(u\)</span> 能否到达 <span class="math inline">\(v\)</span>，但一旦回答了”是“，就不能再询问了。</p>
<p>定义一个点对 <span class="math inline">\((u,v)\)</span> 的价值是 <span class="math inline">\(|k_u-k_v|\)</span>。</p>
<p>求所有双向可达的点对中价值最大的一对，或者输出无解。如果有多对，输出任意一对。</p>
<p><span class="math inline">\(n \le 500\)</span></p>
</blockquote>
<h3 id="做法一">做法一</h3>
<p>考虑一对点 <span class="math inline">\((u,v)\)</span>，由于是竞赛图，<span class="math inline">\(u,v\)</span> 间有连边，不妨设 <span class="math inline">\(u \rightarrow v\)</span>。</p>
<p>如果 <span class="math inline">\(v\)</span> 不能到达 <span class="math inline">\(u\)</span>，<span class="math inline">\(\exists S,u \in S \land \forall x \in S, y \not \in S,x \rightarrow y\)</span>，即集合 <span class="math inline">\(S\)</span> 内的点全部向 <span class="math inline">\(S\)</span> 外的点连边。</p>
<p><span class="math inline">\(\therefore k_v \ge |S|,k_u &lt; |S| \Rightarrow k_u &lt; k_v\)</span></p>
<p>得到一个结论：如果一对点不双向可达，那么入度大的一定无法到达入度小的。</p>
<p>把所有点对按价值从大到小依次询问，每次询问入度大的能否到达入度小的，如果可以，就直接输出这一对。</p>
<p>如果到最后都没有回答“是”，那么输出无解。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Qry&amp; b)<span class="keyword">const</span> &#123; <span class="keyword">return</span> v &gt; b.v; &#125;</span><br><span class="line">&#125; q[N * N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"><span class="keyword">int</span> n, idx, k[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">rep</span>(j, i + <span class="number">1</span>, n)</span><br><span class="line">        q[++idx] = k[i] &lt; k[j] ? (Qry)&#123; j, i, k[j] - k[i] &#125; : (Qry)&#123; i, j, k[i] - k[j] &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + idx + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, idx) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>, q[i].x, q[i].y);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">&#x27;Y&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;! %d %d\n&quot;</span>, q[i].x, q[i].y), <span class="built_in">fflush</span>(stdout), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;! 0 0&quot;</span>), <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="做法二">做法二</h3>
<p>考虑拓扑序最小的几个<strong>强连通分量</strong>的并集 <span class="math inline">\(S\)</span>，<span class="math inline">\(S\)</span> 内的点全部向 <span class="math inline">\(S\)</span> 外的点连边，所以 <span class="math inline">\(S\)</span> 内所有点的入度和等于 <span class="math inline">\(\binom {|S|}2\)</span>，<strong>反之亦然</strong>。</p>
<p>把所有点按入度从小到大排序，如果前 <span class="math inline">\(m\)</span> 个节点的入度和等于 <span class="math inline">\(\binom m2\)</span>，那么前 <span class="math inline">\(m\)</span> 个点一定是拓扑序最小的几个强连通分量的并集，<strong>并且不会漏掉</strong>，这样就可以分离出所有的强连通分量，直接统计答案即可。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>，因为排序可以桶排，<strong>无需询问</strong>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n; P a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].fi), a[i].se = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> su = <span class="number">0</span>; <span class="function">P <span class="title">mi</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">ma</span><span class="params">(<span class="number">-1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    pair &lt;<span class="keyword">int</span>, P&gt; as;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        su += a[i].fi;</span><br><span class="line">        mi = <span class="built_in">min</span>(mi, a[i]), ma = <span class="built_in">max</span>(ma, a[i]);</span><br><span class="line">        <span class="keyword">if</span>(su == i * (i - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mi.se ^ ma.se) as = <span class="built_in">max</span>(as, <span class="built_in">mp</span>(ma.fi - mi.fi, <span class="built_in">mp</span>(mi.se, ma.se)));</span><br><span class="line">            mi.fi = n, ma.fi = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(as.se.fi) <span class="built_in">printf</span>(<span class="string">&quot;! %d %d\n&quot;</span>, as.se.fi, as.se.se);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;! 0 0&quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>Bananas in a Microwave | Codeforces 1498D</title>
    <url>/CF1498D/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/1498/problem/D">题目链接</a></p>
<p>有一个变量 <span class="math inline">\(k\)</span> 初始为 <span class="math inline">\(0\)</span>。</p>
<p>对于时刻 <span class="math inline">\(i=1,2,3,\cdots,n\)</span>，给定 <span class="math inline">\(t_i,x_i,y_i\)</span>，且执行以下操作：</p>
<ul>
<li>若 <span class="math inline">\(t_i=1\)</span>，选择 <span class="math inline">\(a \in [0,y_i]\)</span>，执行 <span class="math inline">\(a\)</span> 次 <span class="math inline">\(k=\lceil k + x_i \rceil\)</span>。</li>
<li>若 <span class="math inline">\(t_i=2\)</span>，选择 <span class="math inline">\(a \in [0,y_i]\)</span>，执行 <span class="math inline">\(a\)</span> 次 <span class="math inline">\(k=\lceil k \cdot x_i \rceil\)</span>。</li>
</ul>
<p>其中 <span class="math inline">\(x_i\)</span> 是<strong>实数</strong>。</p>
<p>对于每个 <span class="math inline">\(j \in [1,m]\)</span>，求可能的最小时刻使得 <span class="math inline">\(k=j\)</span>。</p>
<p><span class="math inline">\(n \le 200,y_i \le m \le 10^5\)</span></p>
<p>对于 <span class="math inline">\(t_i=1\)</span>，有 <span class="math inline">\(0 &lt; x_i \le m\)</span>，对于 <span class="math inline">\(t_i=2\)</span>，有 <span class="math inline">\(1 &lt; x_i \le m\)</span>。</p>
</blockquote>
<p>对于每个时刻 <span class="math inline">\(i\)</span>，维护数组 <span class="math inline">\(ok_j\)</span> 表示经过前 <span class="math inline">\(i\)</span> 个时刻能否使 <span class="math inline">\(k=j\)</span>。</p>
<p>设 <span class="math inline">\(next_j=\begin{cases}\lceil j + x_i \rceil&amp;(t_i=1)\\\lceil j \cdot x_i \rceil&amp;(t_i=2)\end{cases}\)</span>。</p>
<p>因为 <span class="math inline">\(\forall j \ne k,next_j \ne next_k\)</span>，所以 <span class="math inline">\(j \rightarrow next_j\)</span> 连边后形成若干条链。</p>
<p>假设一条链上的结点分别为 <span class="math inline">\(v_1,v_2,v_3,\cdots,v_s\)</span></p>
<p>对于 <span class="math inline">\(v_j\)</span>，如果 <span class="math inline">\(\exist k \in [j-y_i,j)\)</span>，满足 <span class="math inline">\(ok_k=1\)</span>，那么在第 <span class="math inline">\(i\)</span> 时刻 <span class="math inline">\(k\)</span> 可以等于 <span class="math inline">\(v_j\)</span>。</p>
<p>对每条链扫描一遍即可求出在第 <span class="math inline">\(i\)</span> 时刻 <span class="math inline">\(k\)</span> 可以等于哪些值。</p>
<p>复杂度 <span class="math inline">\(O(nm)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd(a, b) (a = min(a, b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>, M = N + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[M], nxt[M], vis[M], ok[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(f, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> t, y; ll x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(k, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">1</span>) &#123;</span><br><span class="line">            x = (x + N - <span class="number">1</span>) / N;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, m) nxt[i] = <span class="built_in">min</span>(i + x, m + <span class="number">1ll</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nxt[<span class="number">0</span>] = m + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, m) nxt[i] = <span class="built_in">min</span>((i * x + N - <span class="number">1</span>) / N, m + <span class="number">1ll</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">mem</span>(vis, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, m) <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            vector &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m; j = nxt[j]) vis[j] = <span class="number">1</span>, v.<span class="built_in">push_back</span>(j);</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">For</span>(j, <span class="number">0</span>, v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt) ok[v[j]] = <span class="number">1</span>;</span><br><span class="line">                cnt += f[v[j]] != <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= y) cnt -= f[v[j - y]] != <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, m) <span class="keyword">if</span>(!~f[i] &amp;&amp; ok[i]) f[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>New Year and Original Order | Codeforces 908G</title>
    <url>/CF908G/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/problemset/problem/908/G">题目链接</a></p>
<p>定义 <span class="math inline">\(S(x)\)</span> 表示把 <span class="math inline">\(x\)</span> 各数位上的数排序后得到的新数，<span class="math inline">\(S(353594)=334559\)</span>。</p>
<p>给定 <span class="math inline">\(n\)</span>，求 <span class="math inline">\(\sum\limits_{i=1}^nS(i) \bmod 10^9+7\)</span>。</p>
<p><span class="math inline">\(n \le 10^{700}\)</span></p>
</blockquote>
<p>设 <span class="math inline">\(n\)</span> 总共 <span class="math inline">\(m\)</span> 位，<span class="math inline">\(h_{x,i}\)</span> 表示 <span class="math inline">\(x\)</span> 有多少个数位上的数大于等于 <span class="math inline">\(i\)</span>。</p>
<span id="more"></span>
<p>然后发现 <span class="math inline">\(S(x) = \sum\limits_{i=1}^9 \underbrace{111\cdots 1}=\frac 19\sum\limits_{i=1}^910^{h_{x,i}}-1=\frac 19\sum\limits_{i=1}^9\sum\limits_{j=0}^{m}(10^j-1)\sum\limits_{k=1}^n[h_{k,i}=j]\)</span><br />
_________________________<span class="math inline">\(h_{x,i}\)</span> 个 <span class="math inline">\(1\)</span></p>
<p>因此对每个 <span class="math inline">\(i,j\)</span> 求出 <span class="math inline">\(\sum\limits_{k=1}^n[h_{k,i}=j]\)</span> 即可求得答案。</p>
<p>数位 <code>DP</code> 即可，复杂度 <span class="math inline">\(O(100m^2)\)</span>。</p>
<p>也可以组合计数：</p>
<p>先让 <code>n++</code>，问题变成求 <span class="math inline">\(\sum_{x &lt; n}S(x)\)</span>。</p>
<p>定义第 <span class="math inline">\(i\)</span> 位是从最高位开始的第 <span class="math inline">\(i\)</span> 位，<span class="math inline">\(a_i\)</span> 表示 <span class="math inline">\(n\)</span> 的第 <span class="math inline">\(i\)</span> 位。</p>
<p>先枚举数 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(n\)</span> 的 <code>LCP</code> <span class="math inline">\(i \in [0,m)\)</span>，再枚举 <span class="math inline">\(x\)</span> 在第 <span class="math inline">\(i+1\)</span> 位上的值 <span class="math inline">\(j \in [0,a_{i+1})\)</span>，则所有 <span class="math inline">\(x\)</span> 的贡献为：</p>
<p>这里 <span class="math inline">\(k\)</span> 表示低 <span class="math inline">\(m-i-1\)</span> 位中有多少位大于等于 <span class="math inline">\(d\)</span>。 <span class="math display">\[
\frac 19\sum_{d=1}^9\sum_{k=0}^{m-i-1}\binom {m-i-1}k(10-d)^kd^{m-i-1-k}(10^{\sum_{s=1}^i[a_s \ge d]+[j \ge d]+k}-1)
\]</span> 故答案为： <span class="math display">\[
\begin{aligned}
&amp;\frac 19\sum_{i=0}^{m-1}\sum_{j=0}^{a_{i+1}-1}\sum_{d=1}^9\sum_{k=0}^{m-i-1}\binom {m-i-1}k(10-d)^kd^{m-i-1-k}(10^{\sum_{s=1}^i[a_s \ge d]+[j \ge d]+k}-1)\\
&amp;=\frac 19\sum_{i=0}^{m-1}\sum_{j=0}^{a_{i+1}-1}\sum_{d=1}^9\left(\left(10^{\sum_{s=1}^i[a_s \ge d]+[j \ge d]}\sum_{k=0}^{m-i-1}\binom {m-i-1}k(100-10d)^kd^{m-i-1-k}\right)-10^{m-i-1}\right)\\
&amp;=\frac 19\sum_{i=0}^{m-1}\sum_{j=0}^{a_{i+1}-1}\sum_{d=1}^9\left(10^{\sum_{s=1}^i[a_s \ge d]+[j \ge d]}(100-9d)^{m-i-1}-10^{m-i-1}\right)\\
&amp;=\frac 19\sum_{i=0}^{m-1}\sum_{d=1}^9\left(10^{\sum_{s=1}^i[a_s \ge d]}(10\max\{a_{i+1}-d,0\}+\min\{a_{i+1},d\})(100-9d)^{m-i-1}-a_{i+1}10^{m-i-1}\right)\\
&amp;=\frac 19\sum_{i=1}^m\sum_{j=1}^9\left(10^{\sum_{s=1}^{i-1}[a_s \ge j]}(100-9j)^{m-i}(10\max\{a_i-j,0\}+\min\{a_i,j\})-a_i10^{m-i}\right)
\end{aligned}
\]</span> <span class="math inline">\(\sum_{s=1}^i[a_s \ge d],(100-9d)^{m-i-1},10^{m-i-1}\)</span> 可以枚举 <span class="math inline">\(i\)</span> 时顺便维护。</p>
<p>复杂度 <span class="math inline">\(O(10m)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">705</span>]; <span class="keyword">char</span> s[<span class="number">705</span>];</span><br><span class="line">ll Pow[<span class="number">705</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) a[i] = s[n - i] - <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[i] == <span class="number">9</span>) a[i++] = <span class="number">0</span>;</span><br><span class="line">    a[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) n++;</span><br><span class="line">    <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">10</span>) Pow[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">10</span>) Pow[i][j] = Pow[i - <span class="number">1</span>][j] * (<span class="number">100</span> - <span class="number">9</span> * j) % P;</span><br><span class="line">    <span class="keyword">int</span> idx[<span class="number">11</span>] = &#123;&#125;;</span><br><span class="line">    ll as = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">9</span>) &#123;</span><br><span class="line">        (as += Pow[idx[j]][<span class="number">10</span>] * Pow[n - i][j] % P * (<span class="number">10</span> * <span class="built_in">max</span>(a[i] - j, <span class="number">0</span>) + <span class="built_in">min</span>(a[i], j)) - a[i] * Pow[n - i][<span class="number">10</span>]) %= P;</span><br><span class="line">        idx[j] += a[i] &gt;= j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (as * <span class="number">111111112</span> % P + P) % P;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>数位动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Merged Sequences | Codeforces 1144G</title>
    <url>/CF1144G/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/problemset/problem/1144/G">题目链接</a></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span>。</p>
<p>问能否把它拆成一个严格递增序列和一个严格递减序列，如果有解则输出方案。</p>
<p><span class="math inline">\(n \le 2 \cdot 10^5\)</span></p>
</blockquote>
<p>设 <span class="math inline">\(f_{i,0}\)</span> 表示把序列的前 <span class="math inline">\(i\)</span> 个数拆成一个递增序列和一个递减序列（可以为空），并且 <span class="math inline">\(A_i\)</span> 属于递增序列时，递减序列结尾可能的最大值。<span class="math inline">\(f_{i,1}\)</span> 表示 <span class="math inline">\(A_i\)</span> 属于递减序列时，递增序列结尾可能的最小值。</p>
<p>转移有四种：</p>
<ul>
<li><span class="math inline">\(A_{i-1},A_i\)</span> 都属于递增序列，条件是 <span class="math inline">\(A_{i-1} &lt; A_i\)</span>，转移为 <span class="math inline">\(f_{i-1,0} \rightarrow f_{i,0}\)</span> 。</li>
<li><span class="math inline">\(A_{i-1},A_i\)</span> 都属于递减序列，情况类似。</li>
<li><span class="math inline">\(A_{i-1}\)</span> 属于递减序列，<span class="math inline">\(A_i\)</span> 属于递增序列，条件是 <span class="math inline">\(f_{i-1,1} &lt; A_i\)</span>，转移为 <span class="math inline">\(A_{i-1} \rightarrow f_{i,0}\)</span>。</li>
<li><span class="math inline">\(A_{i-1}\)</span> 属于递增序列，<span class="math inline">\(A_i\)</span> 属于递减序列，情况类似。</li>
</ul>
<p>为了输出方案，记 <span class="math inline">\(g_{i,0}\)</span> 表示在最优方案中 <span class="math inline">\(A_{i-1}\)</span> 属于哪个序列，<span class="math inline">\(g_{i,1}\)</span> 同理。</p>
<p>实现中可以用 <code>pair &lt;int, int&gt;</code> 把 <code>f</code> 和 <code>g</code> 数组压一起。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, A[N], in[N];</span><br><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f[N][<span class="number">2</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>].fi = N, f[<span class="number">1</span>][<span class="number">1</span>].fi = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>].fi = <span class="number">-1</span>, f[i][<span class="number">1</span>].fi = N;</span><br><span class="line">        <span class="keyword">if</span>(A[i - <span class="number">1</span>] &lt; A[i]) f[i][<span class="number">0</span>] = &#123;f[i - <span class="number">1</span>][<span class="number">0</span>].fi, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(A[i - <span class="number">1</span>] &gt; A[i]) f[i][<span class="number">1</span>] = &#123;f[i - <span class="number">1</span>][<span class="number">1</span>].fi, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(f[i - <span class="number">1</span>][<span class="number">1</span>].fi &lt; A[i]) f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>], <span class="built_in">mp</span>(A[i - <span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(f[i - <span class="number">1</span>][<span class="number">0</span>].fi &gt; A[i]) f[i][<span class="number">1</span>] = <span class="built_in">min</span>(f[i][<span class="number">1</span>], <span class="built_in">mp</span>(A[i - <span class="number">1</span>], <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(~f[n][<span class="number">0</span>].fi || f[n][<span class="number">1</span>].fi &lt; N) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        in[n] = ~f[n][<span class="number">0</span>].fi ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">per</span>(i, n, <span class="number">2</span>) in[i - <span class="number">1</span>] = f[i][in[i]].se;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, in[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Guards In The Storehouse | Codeforces 845F</title>
    <url>/CF845F/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://codeforces.com/problemset/problem/845/F">题目链接</a></p>
<p>给定一个 <span class="math inline">\(n \times m\)</span> 的网格，有些位置是障碍，其他是空地。</p>
<p>在一个空地放灯可以照亮这个灯向右，向下第一个障碍前的所有方格。</p>
<p>求有多少种在空地上放灯的方案，使得最多 <span class="math inline">\(1\)</span> 个空地没有被照亮，对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(nm \le 250\)</span></p>
</blockquote>
<p><span class="math inline">\(\land\)</span> 是逻辑与，<span class="math inline">\(\lor\)</span> 是逻辑或。</p>
<p>首先 <span class="math inline">\(nm \le 250 \Rightarrow \min\{n,m\} \le 15\)</span>。</p>
<p>如果 <span class="math inline">\(n &lt; m\)</span>，就可以将行列转置，问题不变，但 <span class="math inline">\(m \le 15\)</span> 了。</p>
<p>容易想到对每一行状压，状压一行中每个格子向上第一个障碍前是否有灯（即这个格子是否有向下的光）。</p>
<p>这样时间复杂度过高，感觉行不通，于是考虑压轮廓线，按照从上到下，从左到右的顺序放灯。</p>
<p>设 <span class="math inline">\(f_{i\,a,b,S}\)</span> 表示目前<strong>将要</strong>决定格子 <span class="math inline">\(i=(x,y)\)</span> 放不放灯，<span class="math inline">\(a\)</span> 表示从 <span class="math inline">\(i\)</span> 向左第一个障碍前是（<span class="math inline">\(1\)</span>）否（<span class="math inline">\(0\)</span>）有灯（即 <span class="math inline">\(i\)</span> 左边是否有向右的光），<span class="math inline">\(b\)</span> 表示有几个目前<strong>已决定</strong>有没有放灯的空地没有被照亮，而 <span class="math inline">\(S\)</span> 是压的是第 <span class="math inline">\(x\)</span> 行前 <span class="math inline">\(y-1\)</span> 个格子和第 <span class="math inline">\(x-1\)</span> 行后 <span class="math inline">\(m-y+1\)</span> 个格子上是（<span class="math inline">\(1\)</span>）否（<span class="math inline">\(0\)</span>）有向下的光。</p>
<p>图中的情况 <span class="math inline">\(a = 0, b = 1, S = \{0,0,1,0,1\}\)</span>。</p>
<p><img src="https://i.loli.net/2021/03/26/3JZXsTfOdn2GyAe.png" /></p>
<p>转移就三种情况（先不考虑从一行最后一个格子转移到下一行第一个格子的情况）：</p>
<ul>
<li>格子 <span class="math inline">\(i\)</span> 是障碍，那么它会挡住向右和向下的光，形式化地： <span class="math display">\[
a \rightarrow 0,S \rightarrow S \setminus \{y\}\\
\]</span> <figure class="highlight plaintext"><figcaption><span>转移到 ```f[nxt][0][b][~(~S | 1 << y)]```。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 格子 $i$ 是空地，在格子 $i$ 放灯，那么它会产生向右和向下的光。</span><br><span class="line">  $$</span><br><span class="line">  a \rightarrow 1,S \rightarrow S \cup \&#123;y\&#125;</span><br><span class="line">  $$</span><br><span class="line">  ```f[i][a][b][S]``` 转移到 ```f[nxt][1][b][S | 1 &lt;&lt; y]```</span><br><span class="line"></span><br><span class="line">- 格子 $i$ 是空地，不在格子 $i$ 放灯，那么还要考虑 $i$ 会不会被照亮。</span><br><span class="line"></span><br><span class="line">  如果 $a=1 \lor y \in S$，那么 $i$ 会被照亮，$a,b$ 和 $S$  都不变，否则 $i$ 不会被照亮， $b$ 必须为 0，转移后变为 $1$，$a$ 和 $S$ 不变。</span><br><span class="line"></span><br><span class="line">当 $i$ 是一行最后一个格子时，唯一区别是转移后 $a$ 变为 $0$，因此在代码里无需单独讨论。</span><br><span class="line"></span><br><span class="line">答案就是格子 $(n+1,1)$ 的所有 ```f``` 值之和，因为状态的定义是目前**将要**决定这个格子放不放灯。</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span><br><span class="line">#define per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span><br><span class="line">#define mem(a, b) memset(a, b, sizeof a)</span><br><span class="line">#define For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll P = 1e9 + 7;</span><br><span class="line">int n, m, f[255][2][2][1 &lt;&lt; 15]; char s[255][255];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    For(i, 0, n) scanf(&quot;%s&quot;, s[i]);</span><br><span class="line">    if(n &lt; m) &#123;</span><br><span class="line">        For(i, 0, n) For(j, i + 1, m) swap(s[i][j], s[j][i]);</span><br><span class="line">        swap(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    f[0][0][0][0] = 1;</span><br><span class="line">    For(i, 0, n) For(j, 0, m) rep(a, 0, 1) rep(b, 0, 1) For(S, 0, 1 &lt;&lt; m) &#123;</span><br><span class="line">        int x = f[i * m + j][a][b][S], nxt = i * m + j + 1;</span><br><span class="line">        if(!x) continue;</span><br><span class="line">        if(s[i][j] == &#x27;x&#x27;) (f[nxt][0][b][~(~S | 1 &lt;&lt; j)] += x) %= P;</span><br><span class="line">        else &#123;</span><br><span class="line">            (f[nxt][j &lt; m - 1][b][S | 1 &lt;&lt; j] += x) %= P;</span><br><span class="line">            if(a | (S &gt;&gt; j &amp; 1)) (f[nxt][a &amp; (j &lt; m - 1)][b][S] += x) %= P;</span><br><span class="line">            else if(!b) (f[nxt][0][1][S] += x) %= P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int as = 0;</span><br><span class="line">    rep(b, 0, 1) For(S, 0, 1 &lt;&lt; m) (as += f[n * m][0][b][S]) %= P;</span><br><span class="line">    cout &lt;&lt; as;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状压动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Meetings 2 | JOISC2021 D3T3</title>
    <url>/JOISC2021D3T3/</url>
    <content><![CDATA[<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个点的树。</p>
<p>当一些结点上的人开会时，会将满足以下条件的结点作为会议的候选结点：所有参会者到此结点的距离和最小。</p>
<p>对于每一个的 <span class="math inline">\(k \in [1,n]\)</span>，求出所有可能的 <span class="math inline">\(k\)</span> 个人的会议最多有多少个候选结点。</p>
<p><span class="math inline">\(n \le 2 \cdot 10^5\)</span></p>
</blockquote>
<h4 id="这题告诉我们涉及到-size-时可以考虑把重心作为树的重心有没有什么性质">这题告诉我们：涉及到 <code>size</code> 时可以考虑把重心作为树的重心有没有什么性质。</h4>
<h3 id="结论-1当-k-为奇数时答案为-1">结论 <span class="math inline">\(1\)</span>：当 <span class="math inline">\(k\)</span> 为奇数时，答案为 <span class="math inline">\(1\)</span>。</h3>
<p>证明：</p>
<p>设 <span class="math inline">\(f(u)\)</span> 表示删去 <span class="math inline">\(u\)</span> 后，每个连通块内关键结点（有参会者的结点）数量的最大值。</p>
<p>假设 <span class="math inline">\(u\)</span> 是一个候选结点，那么 <span class="math inline">\(f(u) \le \lfloor \frac k2 \rfloor\)</span> ，否则可以找到一个与 <span class="math inline">\(u\)</span> 相邻的结点 <span class="math inline">\(v\)</span> 满足所在连通块大小大于 <span class="math inline">\(\lfloor \frac k2 \rfloor\)</span> ，不难发现 <span class="math inline">\(v\)</span> 比 <span class="math inline">\(u\)</span> 严格更优。</p>
<p>因此任意一个不同于 <span class="math inline">\(u\)</span> 的结点 <span class="math inline">\(v\)</span> 必定满足 <span class="math inline">\(f(v) \ge k -f(u) &gt; \lfloor \frac k2 \rfloor\)</span>，所以 <span class="math inline">\(v\)</span> 一定不是候选结点。</p>
<h3 id="结论-2当-k-为偶数时所有候选结点一定是一条链">结论 <span class="math inline">\(2\)</span>：当 <span class="math inline">\(k\)</span> 为偶数时，所有候选结点一定是一条链。</h3>
<p>证明：</p>
<p>若 <span class="math inline">\(u, v\)</span> 是不相邻两个结点，且都是候选结点。设边 <span class="math inline">\((u,v)\)</span> 两边的关键结点数量分别为 <span class="math inline">\(a,b\)</span>。</p>
<p>则 <span class="math inline">\(a + b = k, a \le f(v) \le \frac k2,b \le f(u) \le \frac k2 \Rightarrow a = b = \frac k2\)</span>。</p>
<p>所有平分 <span class="math inline">\(k\)</span> 个点的边 <span class="math inline">\((u,v)\)</span> 一定是一条链，如图。</p>
<p><img src="https://i.loli.net/2021/03/22/cs9ZJOrImCibEAz.png" /></p>
<p>至此，可以得到一个 <span class="math inline">\(O(n^2)\)</span> 做法：</p>
<p>设 <span class="math inline">\(F(u,v)\)</span> 表示链 <span class="math inline">\(u - v\)</span> 两边的结点数的较小值。</p>
<p>枚举一条链 <span class="math inline">\(u - v\)</span>，如果 <span class="math inline">\(F(u,v) \ge \frac k2\)</span>，那么可以在两边分别放 <span class="math inline">\(\frac k2\)</span> 参会者，就至少能得到链长个候选结点。<br />
因此用链长更新 <span class="math inline">\(k=2F(u,v)\)</span> 时的答案。</p>
<p>然后最仙的想法就是把树的重心作为根，然后对于任意一条链 <span class="math inline">\(u - v\)</span>，<span class="math inline">\(F(u,v) = \min\{size_u,size_v\}\)</span>，证明略（主要是分析深度递增型链）。</p>
<p>从空集开始，把所有点按 <span class="math inline">\(size\)</span> 从大到小加入，动态维护当前树的直径 <span class="math inline">\(D\)</span>。</p>
<p>若刚加入的点为 <span class="math inline">\(u\)</span>，那么就用 <span class="math inline">\(D\)</span> 更新 <span class="math inline">\(k=2size_u\)</span> 时的答案。</p>
<p>动态维护树的直径的方法也很简单：设当前的直径的两个端点是 <span class="math inline">\(a, b\)</span>，加入结点 <span class="math inline">\(u\)</span> 后，如果直径改变，则要么是 <span class="math inline">\(u - a\)</span>，要么是 <span class="math inline">\(u - b\)</span>，算两次树上距离即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sz[N], rt, d[N], fa[<span class="number">18</span>][N], ans[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; G[N], nds[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ma = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) <span class="keyword">if</span>(v ^ fa)</span><br><span class="line">        <span class="built_in">dfs</span>(v, u), sz[u] += sz[v], ma = <span class="built_in">max</span>(ma, sz[v]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span>(ma, n - sz[u]) &lt;= n / <span class="number">2</span>) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">17</span>) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) <span class="keyword">if</span>(v ^ fa[<span class="number">0</span>][u])</span><br><span class="line">        fa[<span class="number">0</span>][v] = u, d[v] = d[u] + <span class="number">1</span>, <span class="built_in">Dfs</span>(v), sz[u] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[u] &lt; d[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">int</span> res = d[u] - d[v];</span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">17</span>, <span class="number">0</span>) <span class="keyword">if</span>(d[u] - (<span class="number">1</span> &lt;&lt; i) &gt;= d[v]) u = fa[i][u];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">17</span>, <span class="number">0</span>) <span class="keyword">if</span>(fa[i][u] ^ fa[i][v])</span><br><span class="line">        u = fa[i][u], v = fa[i][v], res += <span class="number">2</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v), G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">Dfs</span>(rt);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) nds[sz[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    u = v = rt;</span><br><span class="line">    <span class="keyword">int</span> D = <span class="number">0</span>, d;</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nds[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>((d = <span class="built_in">dis</span>(x, u)) &gt; D) v = x, D = d;</span><br><span class="line">            <span class="keyword">if</span>((d = <span class="built_in">dis</span>(x, v)) &gt; D) u = x, D = d;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = D + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i &amp; <span class="number">1</span> ? <span class="number">1</span> : ans[i / <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JOISC</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树的重心</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>Food Court | JOISC2021 D1T3</title>
    <url>/JOI2021D1T3/</url>
    <content><![CDATA[<blockquote>
<p>有 <span class="math inline">\(N\)</span> 个商店，在每个商店的前面，都有顾客排队，顾客分 <span class="math inline">\(M\)</span> 类。</p>
<p>一共发生了 <span class="math inline">\(Q\)</span> 个事件，每个事件是以下之一。</p>
<ul>
<li>在第 <span class="math inline">\(L\)</span> 到 <span class="math inline">\(R\)</span> 的每个商店前的队列末尾加入 <span class="math inline">\(K\)</span> 个 <span class="math inline">\(C\)</span> 类顾客。</li>
<li>对于第 <span class="math inline">\(L\)</span> 到 <span class="math inline">\(R\)</span> 的每个商店，如果队列中的人数不少于 <span class="math inline">\(K\)</span>，则队列最前面的 <span class="math inline">\(K\)</span> 个顾客离开，否则队列中的顾客将全部离开。</li>
<li>询问第 <span class="math inline">\(A\)</span> 个商店前的队列中从前往后数的第 <span class="math inline">\(B\)</span> 个人属于哪一类，不存在输出 <span class="math inline">\(0\)</span></li>
</ul>
<p><span class="math inline">\(N, M, Q \le 2.5 \cdot 10^5\)</span></p>
</blockquote>
<h3 id="先考虑第-a-个商店前的队列中的人数怎么求">先考虑第 <span class="math inline">\(A\)</span> 个商店前的队列中的人数怎么求。</h3>
<p>对于第一种操作，就是区间加上一个正数；对于第二种操作，就是区间减去一个正数，再和 <span class="math inline">\(0\)</span> 取 <code>max</code>。</p>
<p>简化一下就是：区间加上一个整数，再和 <span class="math inline">\(0\)</span> 取 <code>max</code>。</p>
<p>对于一个位置，假设它依次进行操作的数分别为 <span class="math inline">\(a_1,a_2,\cdots,a_k\)</span>，那么此时它的值为 <span class="math display">\[
\max\{0,\max\{0,\max\{0,\cdots\max\{0,a_1\}\cdots+a_{k-1}\}+a_k\}\\
=\max\{0,a_k,a_{k-1}+a_k,a_{k-2}+a_{k-1}+a_k,\cdots,a_1+a_2+\cdots+a_k\}\\
=\sum_{i=1}^ka_i-\min\{0,a_1,a_1+a_2,\cdots,a_1+a_2+\cdots+a_k\}
\]</span> 即在不考虑再和 <span class="math inline">\(0\)</span> 取 <code>max</code> 的情况下，当前值减<strong>历史</strong>最小值。</p>
<p>做法是建立线段树，对每个结点维护加的懒标记 <span class="math inline">\(tag_i\)</span> 和<strong>仅考虑包含此区间的操作</strong>时的历史最小值 <span class="math inline">\(minTag_i\)</span>。</p>
<p>区间加 <span class="math inline">\(b\)</span> 时就 <code>tag[i] += b, minTag[i] = min(minTag[i], tag[i])</code>。</p>
<p>下放懒标记时就 <code>tag[son] += tag[fa], minTag[son] = min(minTag[son], tag[son] + minTag[fa])</code>。</p>
<h3 id="再考虑原题">再考虑原题</h3>
<p>假设第 <span class="math inline">\(A\)</span> 个商店当前有 <span class="math inline">\(K\)</span> 个人，这个商店总共来过 <span class="math inline">\(S\)</span> 个人，则当前第 <span class="math inline">\(B\)</span> 个人就是所有来过的人中第 <span class="math inline">\(B+S-K\)</span> 个人。</p>
<p><span class="math inline">\(S\)</span> 很好算，而 <span class="math inline">\(K\)</span> 用上述方法即可求得。问题是转化为求所有来过的人中第 <span class="math inline">\(K\)</span> 个人。</p>
<p>离线下所有第一种操作，依次扫描第 <span class="math inline">\(1\)</span> 个到第 <span class="math inline">\(n\)</span> 个商店，维护一个时间轴线段树，每个结点的值这段时间内来过多少人。</p>
<p>当扫到一个区间的左端点 <span class="math inline">\(L\)</span> 时在对应的时间 <span class="math inline">\(t\)</span> 上加人数 <span class="math inline">\(B\)</span>。扫<strong>过</strong>一个区间的右端点 <span class="math inline">\(R\)</span> （即扫到 <span class="math inline">\(R+1\)</span>）时在对应的时间 <span class="math inline">\(t\)</span> 上减人数 <span class="math inline">\(B\)</span>。</p>
<p>询问就是查询最小的 <span class="math inline">\(T\)</span> 满足 <span class="math inline">\([1,T]\)</span> 内加入的人数不少于要求的 <span class="math inline">\(K\)</span> ，答案是第 <span class="math inline">\(T\)</span> 个操作对于的 <span class="math inline">\(C\)</span>，线段树上二分一下即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, o * 2 + 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line">ll c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">for</span>(; i &lt;= n; i += i &amp; -i) c[i] += v; &#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> i, ll r = <span class="number">0</span>)</span> </span>&#123; <span class="keyword">for</span>(; i; i &amp;= i - <span class="number">1</span>) r += c[i]; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="keyword">namespace</span> seg1 &#123;</span><br><span class="line">    ll ta[N * <span class="number">4</span>], mi[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> o, ll k, ll kk)</span> </span>&#123;</span><br><span class="line">        mi[o] = <span class="built_in">min</span>(mi[o], ta[o] + kk), ta[o] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">put</span>(o * <span class="number">2</span>, ta[o], mi[o]);</span><br><span class="line">        <span class="built_in">put</span>(o * <span class="number">2</span> + <span class="number">1</span>, ta[o], mi[o]);</span><br><span class="line">        ta[o] = mi[o] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">put</span>(o, k, k);</span><br><span class="line">        <span class="built_in">pd</span>(o);</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">upd</span>(L, R, k, lch);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid) <span class="built_in">upd</span>(L, R, k, rch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ta[o] - mi[o];</span><br><span class="line">        <span class="built_in">pd</span>(o);</span><br><span class="line">        <span class="keyword">return</span> p &lt;= mid ? <span class="built_in">qry</span>(p, lch) : <span class="built_in">qry</span>(p, rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> seg2 &#123;</span><br><span class="line">    ll c[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        c[o] += v; <span class="keyword">if</span>(p &gt; mid) <span class="built_in">upd</span>(p, v, rch); <span class="keyword">else</span> <span class="keyword">if</span>(l &lt; r) <span class="built_in">upd</span>(p, v, lch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">qry</span><span class="params">(ll k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; r ? k &lt;= c[o * <span class="number">2</span>] ? <span class="built_in">qry</span>(k, lch) : <span class="built_in">qry</span>(k - c[o * <span class="number">2</span>], rch) : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Add[N];</span><br><span class="line">vector &lt;pair &lt;ll, <span class="keyword">int</span>&gt;&gt; Qry[N];</span><br><span class="line"><span class="keyword">int</span> id[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> op, l, r, a, b; ll c;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;id[i], &amp;b);</span><br><span class="line">            seg1::<span class="built_in">upd</span>(l, r, b, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            Add[l].<span class="built_in">push_back</span>(&#123; b, i &#125;), <span class="built_in">add</span>(l, b);</span><br><span class="line">            Add[r + <span class="number">1</span>].<span class="built_in">push_back</span>(&#123; -b, i &#125;), <span class="built_in">add</span>(r + <span class="number">1</span>, -b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;b);</span><br><span class="line">            seg1::<span class="built_in">upd</span>(l, r, -b, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;a, &amp;c);</span><br><span class="line">            ll K = seg1::<span class="built_in">qry</span>(a, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(K &lt; c) ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> Qry[a].<span class="built_in">push_back</span>(&#123; c + <span class="built_in">qry</span>(a) - K, i &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> ans[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, t] : Add[i]) seg2::<span class="built_in">upd</span>(t, v, <span class="number">1</span>, q, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [k, t] : Qry[i]) ans[t] = id[seg2::<span class="built_in">qry</span>(k, <span class="number">1</span>, q, <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) <span class="keyword">if</span>(~ans[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JOISC</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Food Court | JOISC2021 D1T3</title>
    <url>/JOISC2021D1T3/</url>
    <content><![CDATA[<blockquote>
<p>有 <span class="math inline">\(N\)</span> 个商店，在每个商店的前面，都有顾客排队，顾客分 <span class="math inline">\(M\)</span> 类。</p>
<p>一共发生了 <span class="math inline">\(Q\)</span> 个事件，每个事件是以下之一。</p>
<ul>
<li>在第 <span class="math inline">\(L\)</span> 到 <span class="math inline">\(R\)</span> 的每个商店前的队列末尾加入 <span class="math inline">\(K\)</span> 个 <span class="math inline">\(C\)</span> 类顾客。</li>
<li>对于第 <span class="math inline">\(L\)</span> 到 <span class="math inline">\(R\)</span> 的每个商店，如果队列中的人数不少于 <span class="math inline">\(K\)</span>，则队列最前面的 <span class="math inline">\(K\)</span> 个顾客离开，否则队列中的顾客将全部离开。</li>
<li>询问第 <span class="math inline">\(A\)</span> 个商店前的队列中从前往后数的第 <span class="math inline">\(B\)</span> 个人属于哪一类，不存在输出 <span class="math inline">\(0\)</span></li>
</ul>
<p><span class="math inline">\(N, M, Q \le 2.5 \cdot 10^5\)</span></p>
</blockquote>
<h3 id="先考虑第-a-个商店前的队列中的人数怎么求">先考虑第 <span class="math inline">\(A\)</span> 个商店前的队列中的人数怎么求。</h3>
<p>对于第一种操作，就是区间加上一个正数；对于第二种操作，就是区间减去一个正数，再和 <span class="math inline">\(0\)</span> 取 <code>max</code>。</p>
<p>简化一下就是：区间加上一个整数，再和 <span class="math inline">\(0\)</span> 取 <code>max</code>。</p>
<p>对于一个位置，假设它依次进行操作的数分别为 <span class="math inline">\(a_1,a_2,\cdots,a_k\)</span>，那么此时它的值为 <span class="math display">\[
\max\{0,\max\{0,\max\{0,\cdots\max\{0,a_1\}\cdots+a_{k-1}\}+a_k\}\\
=\max\{0,a_k,a_{k-1}+a_k,a_{k-2}+a_{k-1}+a_k,\cdots,a_1+a_2+\cdots+a_k\}\\
=\sum_{i=1}^ka_i-\min\{0,a_1,a_1+a_2,\cdots,a_1+a_2+\cdots+a_k\}
\]</span> 即在不考虑再和 <span class="math inline">\(0\)</span> 取 <code>max</code> 的情况下，当前值减<strong>历史</strong>最小值。</p>
<p>做法是建立线段树，对每个结点维护加的懒标记 <span class="math inline">\(tag_i\)</span> 和<strong>仅考虑包含此区间的操作</strong>时的历史最小值 <span class="math inline">\(minTag_i\)</span>。</p>
<p>区间加 <span class="math inline">\(b\)</span> 时就 <code>tag[i] += b, minTag[i] = min(minTag[i], tag[i])</code>。</p>
<p>下放懒标记时就 <code>tag[son] += tag[fa], minTag[son] = min(minTag[son], tag[son] + minTag[fa])</code>。</p>
<h3 id="再考虑原题">再考虑原题</h3>
<p>假设第 <span class="math inline">\(A\)</span> 个商店当前有 <span class="math inline">\(K\)</span> 个人，这个商店总共来过 <span class="math inline">\(S\)</span> 个人，则当前第 <span class="math inline">\(B\)</span> 个人就是所有来过的人中第 <span class="math inline">\(B+S-K\)</span> 个人。</p>
<p><span class="math inline">\(S\)</span> 很好算，而 <span class="math inline">\(K\)</span> 用上述方法即可求得。问题是转化为求所有来过的人中第 <span class="math inline">\(K\)</span> 个人。</p>
<p>离线下所有第一种操作，依次扫描第 <span class="math inline">\(1\)</span> 个到第 <span class="math inline">\(n\)</span> 个商店，维护一个时间轴线段树，每个结点的值这段时间内来过多少人。</p>
<p>当扫到一个区间的左端点 <span class="math inline">\(L\)</span> 时在对应的时间 <span class="math inline">\(t\)</span> 上加人数 <span class="math inline">\(B\)</span>。扫<strong>过</strong>一个区间的右端点 <span class="math inline">\(R\)</span> （即扫到 <span class="math inline">\(R+1\)</span>）时在对应的时间 <span class="math inline">\(t\)</span> 上减人数 <span class="math inline">\(B\)</span>。</p>
<p>询问就是查询最小的 <span class="math inline">\(T\)</span> 满足 <span class="math inline">\([1,T]\)</span> 内加入的人数不少于要求的 <span class="math inline">\(K\)</span> ，答案是第 <span class="math inline">\(T\)</span> 个操作对于的 <span class="math inline">\(C\)</span>，线段树上二分一下即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, o * 2 + 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line">ll c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">for</span>(; i &lt;= n; i += i &amp; -i) c[i] += v; &#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> i, ll r = <span class="number">0</span>)</span> </span>&#123; <span class="keyword">for</span>(; i; i &amp;= i - <span class="number">1</span>) r += c[i]; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="keyword">namespace</span> seg1 &#123;</span><br><span class="line">    ll ta[N * <span class="number">4</span>], mi[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> o, ll k, ll kk)</span> </span>&#123;</span><br><span class="line">        mi[o] = <span class="built_in">min</span>(mi[o], ta[o] + kk), ta[o] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">put</span>(o * <span class="number">2</span>, ta[o], mi[o]);</span><br><span class="line">        <span class="built_in">put</span>(o * <span class="number">2</span> + <span class="number">1</span>, ta[o], mi[o]);</span><br><span class="line">        ta[o] = mi[o] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">put</span>(o, k, k);</span><br><span class="line">        <span class="built_in">pd</span>(o);</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">upd</span>(L, R, k, lch);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid) <span class="built_in">upd</span>(L, R, k, rch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ta[o] - mi[o];</span><br><span class="line">        <span class="built_in">pd</span>(o);</span><br><span class="line">        <span class="keyword">return</span> p &lt;= mid ? <span class="built_in">qry</span>(p, lch) : <span class="built_in">qry</span>(p, rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> seg2 &#123;</span><br><span class="line">    ll c[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        c[o] += v; <span class="keyword">if</span>(p &gt; mid) <span class="built_in">upd</span>(p, v, rch); <span class="keyword">else</span> <span class="keyword">if</span>(l &lt; r) <span class="built_in">upd</span>(p, v, lch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">qry</span><span class="params">(ll k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; r ? k &lt;= c[o * <span class="number">2</span>] ? <span class="built_in">qry</span>(k, lch) : <span class="built_in">qry</span>(k - c[o * <span class="number">2</span>], rch) : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Add[N];</span><br><span class="line">vector &lt;pair &lt;ll, <span class="keyword">int</span>&gt;&gt; Qry[N];</span><br><span class="line"><span class="keyword">int</span> id[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> op, l, r, a, b; ll c;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;id[i], &amp;b);</span><br><span class="line">            seg1::<span class="built_in">upd</span>(l, r, b, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            Add[l].<span class="built_in">push_back</span>(&#123; b, i &#125;), <span class="built_in">add</span>(l, b);</span><br><span class="line">            Add[r + <span class="number">1</span>].<span class="built_in">push_back</span>(&#123; -b, i &#125;), <span class="built_in">add</span>(r + <span class="number">1</span>, -b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;b);</span><br><span class="line">            seg1::<span class="built_in">upd</span>(l, r, -b, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;a, &amp;c);</span><br><span class="line">            ll K = seg1::<span class="built_in">qry</span>(a, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(K &lt; c) ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> Qry[a].<span class="built_in">push_back</span>(&#123; c + <span class="built_in">qry</span>(a) - K, i &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> ans[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, t] : Add[i]) seg2::<span class="built_in">upd</span>(t, v, <span class="number">1</span>, q, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [k, t] : Qry[i]) ans[t] = id[seg2::<span class="built_in">qry</span>(k, <span class="number">1</span>, q, <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) <span class="keyword">if</span>(~ans[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JOISC</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Realistic Gameplay | Codefoces 1430F</title>
    <url>/CF1430F/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/problemset/problem/1430/F">题目链接</a></p>
<p>你有一把枪，枪的弹匣量为 <span class="math inline">\(k\)</span>。</p>
<p>有 <span class="math inline">\(n\)</span> 波怪物，对于第 <span class="math inline">\(i\)</span> 波，你必须在 <span class="math inline">\([l_i,r_i]\)</span> 时间内消灭 <span class="math inline">\(a_i\)</span> 只怪物 <span class="math inline">\((r_i \le l_{i+1})\)</span>，你可以在任意时刻打出一发子弹击杀一只怪物且不耗费时间。你每次换弹都需要将弹匣（包括里面的子弹）扔掉，并花费 1 单位的时间。</p>
<p>在保证通关的情况下，需要的最少的子弹数为多少。</p>
<p><span class="math inline">\(n \le 2000,k \le 10^9, l_i \le r_i \le 10^9,a_i \le 10^9\)</span></p>
</blockquote>
<p>考虑什么时候会换弹，要么是当前子弹打完了，而这波怪还没打完，称之为一类换弹；要么是当前这波怪已经打完了，但为了通关而换新弹匣 ，称之为二类换弹。</p>
<p>如果所有二类换弹在哪一波都是确定的，只要按时间线扫描一遍就可以算出所有一类换弹的时间。</p>
<p>因此设 <span class="math inline">\(f_i\)</span> 表示打完前 <span class="math inline">\(i\)</span> 波怪，且在第 <span class="math inline">\(i\)</span> 波进行一次二类换弹需要的最少的子弹数。<br />
转移就从第 <span class="math inline">\(i + 1\)</span> 波开始扫描，同时维护当前弹匣中的子弹数，直到不合法为止。<br />
如果在 <span class="math inline">\(r_j\)</span> 之前消灭了第 <span class="math inline">\(j\)</span> 波的所有怪物，就可以在第 <span class="math inline">\(j\)</span> 波进行一次二类换弹后转移到 <span class="math inline">\(f_j\)</span>。<br />
如果能消灭完所有怪就更新 <code>ans</code>。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd(a, b) (a = min(a, b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], a[N];</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(f, <span class="number">63</span>), f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l[i], &amp;r[i], &amp;a[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nw = K;</span><br><span class="line">        <span class="built_in">rep</span>(j, i + <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (a[j] - nw + K - <span class="number">1</span>) / K;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; r[j] - l[j]) <span class="keyword">break</span>;</span><br><span class="line">            nw += t * K - a[j];</span><br><span class="line">            f[i] += a[j];</span><br><span class="line">            <span class="keyword">if</span>(j == n) <span class="built_in">upd</span>(f[j], f[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t &lt; l[j + <span class="number">1</span>] - l[j]) <span class="built_in">upd</span>(f[j], f[i] + nw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[n] &lt; <span class="number">0x3f3f3f3f3f3f3f3f</span>) cout &lt;&lt; f[n];</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Policeman and a Tree | Codeforces 868E</title>
    <url>/CF868E/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://codeforces.com/problemset/problem/868/E">题目链接</a></p>
<p>一棵 <span class="math inline">\(n\)</span> 个结点的边带权树，有一个警察初始在 <span class="math inline">\(s\)</span> 点，速度为 <span class="math inline">\(1\)</span>，树上分布有 <span class="math inline">\(m\)</span> 个罪犯，速度为任意大，如果罪犯和警察在同一个结点就会被干掉，警察希望干掉所有罪犯的时间尽量短，而罪犯希望最大化这个时间，假设每个人都以最优策略行动，求这个时间。</p>
<p><span class="math inline">\(1 \le n, m, w_i \le 50\)</span>，<span class="math inline">\(w_i\)</span> 为边权。</p>
<p>所有罪犯初始不在 <span class="math inline">\(s\)</span> 点，一个结点可能会有多个罪犯。</p>
</blockquote>
<h3 id="状态设计">状态设计</h3>
<p>考虑这个过程是怎样的。</p>
<p>当警察在结点 <span class="math inline">\(1\)</span> 时，由于罪犯速度任意大，但不能经过警察，所以罪犯分布在被结点 <span class="math inline">\(1\)</span> 隔开的三个部分中，并且可以在所属部分的任意位置上，<strong>不妨假设</strong>罪犯全部分布在所有与结点 <span class="math inline">\(1\)</span> 相邻的结点 <span class="math inline">\(2,3,4\)</span> 上。</p>
<p>图上的红数字表示该结点上有多少名罪犯。</p>
<p><img src="https://i.loli.net/2021/03/18/A4Zpd72bkRMeINU.png" /></p>
<p>当警察从结点 <span class="math inline">\(1\)</span> 走到结点 <span class="math inline">\(4\)</span> 时，结点 <span class="math inline">\(4\)</span> 上的两名罪犯就需要走到结点 <span class="math inline">\(5,6\)</span> ，同时结点 <span class="math inline">\(2,3\)</span> 上的两名罪犯可以一起走到结点 <span class="math inline">\(1\)</span>。</p>
<p><img src="https://i.loli.net/2021/03/18/gtTQYLueC21mlZW.png" /></p>
<p>容易想到用警察所在的结点 <span class="math inline">\(u\)</span> 和所有与结点 <span class="math inline">\(u\)</span> 相邻的结点上分别有多少名罪犯来表示一个状态。<br />
但一个结点的度数是 <span class="math inline">\(O(n)\)</span> 级别的，因此状态数爆炸。</p>
<p>另一个描述状态的想法是警察当前在哪条边上，这条边的两端分别有多少名罪犯。<br />
然后状态数就减少成了 <span class="math inline">\(O(n^3)\)</span>，非常少。</p>
<p>因此我们用 <span class="math inline">\(f_{i,j,k}\)</span> 表示当前总共还剩 <span class="math inline">\(i\)</span> 名罪犯，警察<strong>刚走上</strong> <span class="math inline">\(j = u \rightarrow v\)</span> 这条<strong>有向边</strong>（警察和 <span class="math inline">\(u\)</span> 的距离忽略不计），结点 <span class="math inline">\(v\)</span> 上有 <span class="math inline">\(k\)</span> 名罪犯。</p>
<h3 id="转移">转移</h3>
<p>假设当前总共还剩 <span class="math inline">\(i\)</span> 名罪犯，警察在<strong>有向边</strong> <span class="math inline">\(j = u \rightarrow v\)</span> 上，边权为 <span class="math inline">\(w\)</span>，结点 <span class="math inline">\(v\)</span> 上有 <span class="math inline">\(k\)</span> 名罪犯。</p>
<p>如果结点 <span class="math inline">\(v\)</span> 是叶子结点，显然 <span class="math display">\[
f_{i,j,k}=f_{i-k,\bar j,i-k} + w
\]</span> 其中 <span class="math inline">\(\bar j\)</span> 是 <span class="math inline">\(j\)</span> 的反向边。</p>
<p>另一种情况：</p>
<p><img src="https://i.loli.net/2021/03/18/Vsnf9c6hIvYkCRd.png" /></p>
<p>结点 <span class="math inline">\(4\)</span> 上的 <span class="math inline">\(k\)</span> 名罪犯必须要分为两波，其中 <span class="math inline">\(a\)</span> 名跑到了结点 <span class="math inline">\(5\)</span>，<span class="math inline">\(b\)</span> 名跑到了结点 <span class="math inline">\(6\)</span>。<br />
警察会下一步会在 <span class="math inline">\(4 \rightarrow 5\)</span> 和 <span class="math inline">\(4 \rightarrow 6\)</span> 中选择较优的一条有向边。</p>
<p>罪犯为了最大化时间： <span class="math display">\[
f_{i,1 \rightarrow 4,k} = \max_{a+b=k}\min \lbrace f_{i,4 \rightarrow 5,a},f_{i,4 \rightarrow 6,b}\rbrace + w
\]</span> 一般地，设结点 <span class="math inline">\(v\)</span> 除 <span class="math inline">\(u\)</span> 以外的相邻点分别为 <span class="math inline">\(a_1,a_2,a_3,\cdots,a_d\)</span>，则转移方程为： <span class="math display">\[
f_{i,j,k}=\max_{c_1+c_2+\cdots+c_d=k}\min_{s=1}^df_{i,v \rightarrow a_s,c_s} + w
\]</span> 下面给出一种复杂度比较优秀的贪心算法实现第二种转移：</p>
<blockquote>
<p>引理：若求 <span class="math inline">\(f_{i,j,k}\)</span> 时的<strong>决策</strong>为 <span class="math inline">\(c_1,c_2,\cdots,c_d\)</span>。<br />
那么求 <span class="math inline">\(f_{i,j,k+1}\)</span> 时的决策 <span class="math inline">\(\bar c_1,\bar c_2,\cdots,\bar c_d\)</span> 一定是在 <span class="math inline">\(c_1,c_2,\cdots,c_d\)</span> 中的某个数 <span class="math inline">\(+1\)</span> 得到的。<br />
并且 <span class="math inline">\(+1\)</span> 的这个 <span class="math inline">\(c_x\)</span> 满足 <span class="math display">\[
f_{i,v \rightarrow a_x,c_x+1}=\max_{s=1}^df_{i,v \rightarrow a_s,c_s+1}
\]</span> 证明：首先在总人数和位置相同的情况下，警察追的人越多，剩下的时间就越短。<br />
故 <span class="math inline">\(f_{i,j,0} \ge f_{i,j,1} \ge f_{i,j,2} \ge \cdots \ge f_{i,j,i}\)</span>。</p>
<p>考虑 <span class="math display">\[
\forall x \le f_{i,j,k}\exists c_1,c_2,\cdots,c_d,\\f_{i,v \rightarrow a_1,c_1} \ge x\\f_{i,v \rightarrow a_2,c_2} \ge x\\\cdots\\f_{i,v \rightarrow a_d,c_d} \ge x
\]</span> 由二分答案算法的 <code>check</code> 函数可知：若 <span class="math inline">\(m_i\)</span> 是 <span class="math inline">\(f_{i,v \rightarrow a_i}\)</span> 数列中最后一个大于等于 <span class="math inline">\(x\)</span> 的位置，<br />
则 <span class="math inline">\(m_1+m_2+\cdots+m_d \ge k\)</span>。</p>
<p>而以这种决策的构造方式，一定有 <span class="math inline">\(c_1 \le m_1,c_2 \le m_2, \cdots, c_d \le m_d\)</span>，因此通过该决策得到的值一定不劣于 <span class="math inline">\(x\)</span>。</p>
</blockquote>
<p>因此可以用一个大根堆维护那个 <span class="math inline">\(x\)</span>，可以在 <span class="math inline">\(O(n\log n)\)</span> 的时间同时求出 <span class="math inline">\(f_{i,j,0},f_{i,j,1},\cdots,f_{i,j,i}\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(n^3\log n)\)</span>，标算的复杂度是 <span class="math inline">\(O(n^5)\)</span> 的。</p>
<p>然而由于常数巨大，最小的点要 <span class="math inline">\(15\)</span> <code>ms</code>，最大的点要 <span class="math inline">\(30\)</span> <code>ms</code>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>, Inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, m, ev[N * <span class="number">2</span>], ew[N * <span class="number">2</span>], cnt[N], deg[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N * <span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i][j][k]) <span class="built_in">solve</span>(i, j);</span><br><span class="line">    <span class="keyword">return</span> f[i][j][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, e, c;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c &lt; i ? <span class="built_in">dp</span>(i, e, c + <span class="number">1</span>) : <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; b)<span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">val</span>() &lt; b.<span class="built_in">val</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    f[i][j][<span class="number">0</span>] = Inf;</span><br><span class="line">    <span class="keyword">if</span>(deg[ev[j]] == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, i) f[i][j][k] = k &lt; i ? <span class="built_in">dp</span>(i - k, j ^ <span class="number">1</span>, i - k) + ew[j] : ew[j];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        priority_queue &lt;node&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : G[ev[j]]) <span class="keyword">if</span>(e ^ j ^ <span class="number">1</span>) q.<span class="built_in">push</span>(&#123; i, e, <span class="number">0</span> &#125;);</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, i) &#123;</span><br><span class="line">            node x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            f[i][j][k] = <span class="built_in">min</span>(f[i][j][k - <span class="number">1</span>], x.<span class="built_in">val</span>() + ew[j]);</span><br><span class="line">            x.c++, q.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = cnt[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : G[u]) <span class="keyword">if</span>(ev[e] ^ fa) res += <span class="built_in">dfs</span>(ev[e], u);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = i * <span class="number">2</span>, b = a + <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, deg[ev[a] = v]++, deg[ev[b] = u]++, ew[a] = ew[b] = w;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(a), G[v].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) cin &gt;&gt; u, cnt[u]++;</span><br><span class="line">    <span class="keyword">int</span> ans = Inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : G[s]) ans = <span class="built_in">min</span>(ans, <span class="built_in">dp</span>(m, e, <span class="built_in">dfs</span>(ev[e], s)));</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>自然数等幂求和</title>
    <url>/zi-ran-shu-deng-mi-qiu-he/</url>
    <content><![CDATA[<h3 id="拉格朗日插值">&lt;1&gt; 拉格朗日插值</h3>
<p>把 <span class="math inline">\(1,2,\cdots,m+2\)</span> 插值即可 <span class="math display">\[
\sum_{i=1}^ni^m=\sum_{i=1}^{m+2}S_m(i)\prod_{j\ne i}\frac{n-j}{i-j}
\]</span> 预处理 <span class="math display">\[
pre_i=\prod_{j=1}^in-j,suf_i=\prod_{j=i}^{m+2}n-j
\]</span> 和阶乘逆元。</p>
<p>进一步 <span class="math display">\[
\sum_{i=1}^ni^m=\sum_{i=1}^{m+2}S_m(i)\frac {pre_{i-1}suf_{i+1}}{(i-1)!(m+2-i)!(-1)^{m+2-i}}
\]</span> 复杂度 <span class="math inline">\(O(m\log P)\)</span> 或 <span class="math inline">\(O(m)\)</span>（欧拉筛 <span class="math inline">\(i^k\)</span>）。</p>
<h3 id="直接上公式无需求逆">&lt;2&gt; 直接上公式(无需求逆)</h3>
<p><span class="math display">\[
\sum_{i=1}^ni^{m+1}=\sum_{k=0}^m\binom{n+k+1}{m+2}\sum_{r=0}^k(-1)^r\binom{m+2}r(k+1-r)^{m+1}
\]</span></p>
<p>复杂度 <span class="math inline">\(O(m^2)\)</span>。</p>
<h3 id="第二类斯特林数">&lt;3&gt; 第二类斯特林数</h3>
<p>预处理 <span class="math display">\[
{0 \brace 0} = 1 \\
{n \brace m} = {n - 1 \brace m - 1} + m{n - 1 \brace m}
\]</span> 结论 <span class="math display">\[
\sum_{i=1}^mi^m=\sum_{i=1}^n{m \brace i}\frac 1{i+1}(n+1)^{\underline{i+1}}
\]</span> 复杂度 <span class="math inline">\(O(m^2)\)</span> （无需求逆）或 <span class="math inline">\(O(m\log m)\)</span> （需要求第二类斯特林数-行）。</p>
<h3 id="递推">&lt;4&gt; 递推</h3>
<p><span class="math display">\[
f_i=\sum_{j=1}^nj^i\\
f_i=\frac 1{i+1}\left((n+1)^{i+1}-\sum_{j=0}^{i-1}\binom{i+1}jf_j\right)
\]</span></p>
<p>复杂度 <span class="math inline">\(O(m^2)\)</span>。</p>
<h3 id="伯努利数">&lt;5&gt; 伯努利数</h3>
<p>预处理 <span class="math display">\[
B_0=1\\
\sum_{i=0}^m\binom{m+1}iB_i=0
\]</span> 结论 <span class="math display">\[
\sum_{i=1}^ni^m=\frac 1{m+1}\sum_{i=0}^m\binom{m+1}iB_in^{m+1-i}
\]</span> 另外伯努利数的指数型生成函数 <span class="math display">\[
B(x)=\frac x{e^x-1}
\]</span> 通过多项式求逆</p>
<p>可以优化到 <span class="math inline">\(O(m\log m)\)</span>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>自然数等幂求和</tag>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛 &amp; Min-25 筛 &amp; Powerful Number 筛</title>
    <url>/du-jiao-shai-and-min-25-shai-and-powerful-number-shai/</url>
    <content><![CDATA[<blockquote>
<p>给定积性函数 <span class="math inline">\(f(x)\)</span>，求 <span class="math inline">\(\sum\limits_{i=1}^Nf(i)\)</span>。</p>
</blockquote>
<h3 id="杜教筛">杜教筛</h3>
<p>找到积性函数 <span class="math inline">\(g(x)\)</span>，设 <span class="math inline">\(S(x) = \sum\limits_{i=1}^x f(i)\)</span>，那么答案是 <span class="math inline">\(S(N)\)</span>。</p>
<p><strong>核心</strong>： <span class="math display">\[
g(1)S(n) = \sum\limits_{i=1}^n (f*g)(i) - \sum\limits_{i=2}^n g(i)S(\big\lfloor \dfrac n i \big\rfloor)
\]</span> 如果 <span class="math inline">\(g(x)\)</span> 和 <span class="math inline">\((f*g)(x)\)</span> 的前缀和很好求，就可以代这个公式递归。</p>
<p><strong>需要记忆化</strong>。</p>
<p>先欧拉筛出 <span class="math inline">\(S(1) - S(N^{\frac 2 3})\)</span>，对于其他会递归到的 <span class="math inline">\(S(x)\)</span>，<span class="math inline">\(x\)</span> 只可能是 <span class="math inline">\(\big\lfloor\dfrac N i \big \rfloor\)</span>，故可以用 <span class="math inline">\(F_i\)</span> 存 <span class="math inline">\(S(x)\)</span>。</p>
<p>时空复杂度均为 <span class="math inline">\(O(n^{\frac 2 3})\)</span>。</p>
<h3 id="min-25-筛">Min-25 筛</h3>
<p><span class="math inline">\(p_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个质数，<span class="math inline">\(d_i\)</span> 表示 <span class="math inline">\(i\)</span> 的最小质因子。</p>
<p><span class="math inline">\(S(n, i) = \sum\limits_{j = 2}^n [d_j &gt; p_i]f(j)\)</span></p>
<p>那么答案是 <span class="math inline">\(S(N, 0)\)</span>。</p>
<p>有递推 <span class="math inline">\(S(n, i) = \sum\limits_{j = i+1}^{p_j \le n} f(p_j) + \sum\limits_{j = i+1}^{p_j^2 \le n}\sum\limits_{k=1}^{p_j^k \le n} f(p_j^k)(S(\big\lfloor \dfrac n{p_j^k} \big\rfloor, j) + [k&gt;1])\)</span>。</p>
<p>如果 <span class="math inline">\(f(p^k)\)</span> 和第一项很好求，那就可以递归到 <span class="math inline">\(0\)</span>，而且<strong>无需记忆化</strong>。</p>
<p>所以问题是求第一项。</p>
<p>找一个完全积性函数 <span class="math inline">\(h(x)\)</span> 满足 <span class="math inline">\(h(p) = f(p)\)</span>。</p>
<p>设 <span class="math inline">\(g(n, i) = \sum\limits_{j=2}^n [j \in P \lor d_j &gt; p_i]h(j)\)</span></p>
<p>有递推 <span class="math inline">\(g(n, i) = g(n, i - 1) - h(p_i)(g(\big\lfloor\dfrac n {p_i} \big\rfloor, i - 1) - \sum\limits_{j=1}^{i-1}h(p_j))\)</span>。</p>
<p>减后面那项是因为 <span class="math inline">\(p_ip_j(j &lt; i)\)</span> 的最小质因子不是 <span class="math inline">\(p_i\)</span>。</p>
<p>当 <span class="math inline">\(n &lt; p_i^2\)</span> 时，<span class="math inline">\(g(n,i)=g(n,i-1)\)</span>，即不需要转移。</p>
<p>注意到 <span class="math inline">\(n\)</span> 会取到的值一定是 <span class="math inline">\(\big\lfloor\dfrac N i \big \rfloor\)</span>，且 <span class="math inline">\(j \le \sqrt N\)</span>。</p>
<p>初始化 <span class="math inline">\(g(n, 0) = \sum\limits_{i=2}^n h(i)\)</span>，<strong>注意 <span class="math inline">\(1\)</span> 不算</strong>。</p>
<p>然后从小到大枚举 <span class="math inline">\(j\)</span>，开滚动数组存另一维，所以另一维需从大到小枚举计算。</p>
<blockquote>
<p>求 1 - n 的质数数量。</p>
<p><span class="math inline">\(n \le 10^{11}\)</span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="built_in">sqrt</span>(<span class="number">1e11</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, f1[N], f2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, lim) f1[i] = i - <span class="number">1</span>, f2[i] = n / i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(p, <span class="number">2</span>, lim) <span class="keyword">if</span> (f1[p] ^ f1[p - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> w1 = lim / p;</span><br><span class="line">        ll x = f1[p - <span class="number">1</span>], w3 = (ll)p * p, w2 = <span class="built_in">min</span>((ll)lim, n / w3), d = n / p;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, w1) f2[i] -= f2[i * p] - x;</span><br><span class="line">        <span class="built_in">rep</span>(i, w1 + <span class="number">1</span>, w2) f2[i] -= f1[d / i] - x;</span><br><span class="line">        <span class="built_in">per</span>(i, lim, w3) f1[i] -= f1[i / p] - x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常数优化">常数优化</h4>
<p>由于 <code>double</code> 乘法快于 <code>long long</code> 乘法，可以预处理 <span class="math inline">\(1-\sqrt n\)</span> 的倒数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="built_in">sqrt</span>(<span class="number">1e11</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, f1[N], f2[N];</span><br><span class="line"><span class="keyword">double</span> inv[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, lim) f1[i] = i - <span class="number">1</span>, f2[i] = n / i - <span class="number">1</span>, inv[i] = <span class="number">1.0</span> / i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(p, <span class="number">2</span>, lim) <span class="keyword">if</span> (f1[p] ^ f1[p - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> w1 = lim / p;</span><br><span class="line">        ll x = f1[p - <span class="number">1</span>], w3 = (ll)p * p, w2 = <span class="built_in">min</span>((ll)lim, n / w3), d = n / p;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, w1) f2[i] -= f2[i * p] - x;</span><br><span class="line">        <span class="built_in">rep</span>(i, w1 + <span class="number">1</span>, w2) f2[i] -= f1[<span class="built_in"><span class="keyword">int</span></span>(d * inv[i] + Eps)] - x;</span><br><span class="line">        <span class="built_in">per</span>(i, lim, w3) f1[i] -= f1[<span class="built_in"><span class="keyword">int</span></span>(i * inv[p] + Eps)] - x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="powerful-number-筛">Powerful Number 筛</h3>
<p>定义：所有质因子的指数都大于 <span class="math inline">\(1\)</span> 的数叫 <code>Powerful Number</code>。</p>
<p>性质：可以表示为 <span class="math inline">\(a^2b^3\)</span>。</p>
<blockquote>
<p>引理：<span class="math inline">\(n\)</span> 以内的 <code>Powerful Number</code> 的数量为 <span class="math inline">\(O(\sqrt n)\)</span> 级别。</p>
<p>证明：根据性质，枚举 <span class="math inline">\(a\)</span>，可以算出数量的上界： <span class="math display">\[
\sum_{i=1}^{\sqrt n}\sqrt[3] {\frac n{a^2}} &lt; \int_0^{\sqrt n - 1}\sqrt[3] {\frac n{a^2}}da = 3n^\frac 13(\sqrt n - 1)^\frac 13 &lt; 3\sqrt n
\]</span></p>
</blockquote>
<p>一个想法：如果一个积性函数仅在 <code>Powerful Number</code> 处取值不为 <span class="math inline">\(0\)</span>，那么与之相关的计算可能做到较低的复杂度。</p>
<p>找到一个<strong>积性函数</strong> <span class="math inline">\(g(x)\)</span> 满足 <span class="math inline">\(g(x)=f(x) (x \in Prime)\)</span>，设 <span class="math inline">\(f(x)=\sum\limits_{ab=x}g(a)h(b)\)</span>，可知 <span class="math inline">\(h(x)\)</span> 仅在 <code>Powerful Number</code> 处取值不为 <span class="math inline">\(0\)</span>。</p>
<p>首先预处理出 <span class="math inline">\(h(x)\)</span> 在 <span class="math inline">\(p^k(p \in Prime,k &gt; 1)\)</span> 处的取值，这里可以做到 <span class="math inline">\(O(\sqrt N)\)</span>（无论 <span class="math inline">\(O(1)\)</span> 算 <span class="math inline">\(h(p^k)\)</span> 还是 <span class="math inline">\(O(k)\)</span> 算都是这个复杂度）。</p>
<p>于是 <span class="math display">\[
\sum_{i=1}^Nf(i)=\sum_{ab \le N}g(a)h(b)=\sum_{b=1}^Nh(b)\sum_{a=1}^{\lfloor \frac Na \rfloor}g(a)
\]</span> 最后要求 <span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\(\lfloor \frac Na \rfloor\)</span> 的前缀和能快速求。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Min-25 筛</tag>
        <tag>杜教筛</tag>
        <tag>知识总结</tag>
        <tag>Powerful Number 筛</tag>
      </tags>
  </entry>
  <entry>
    <title>Many Slimes | abc 140f</title>
    <url>/abc140f/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://atcoder.jp/contests/abc140/tasks/abc140_f">题目链接</a></p>
<p>每个细菌都有一个 <span class="math inline">\(s\)</span> 值。</p>
<p>最初只有一个细菌。每一天原先的细菌都会生一个孩子，且孩子的 <span class="math inline">\(s\)</span> 值小于母体的 <span class="math inline">\(s\)</span> 值。</p>
<p>给定 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(2^n\)</span> 个数。</p>
<p>判断是否存在一种情况，经过 <span class="math inline">\(n\)</span> 天后所有细菌的 <span class="math inline">\(s\)</span> 值为给定的数。</p>
<p><span class="math inline">\(n \le 10^5,s_i \le 10^9\)</span></p>
</blockquote>
<p>首先最大的数一定是原始细菌的 <span class="math inline">\(s\)</span> 值。然后考虑第 <span class="math inline">\(i\)</span> 天的细菌，它们所选择的 <span class="math inline">\(s\)</span> 一定要尽可能的大，如果选小了会使它们的后代选择变少。</p>
<p>然后对于每一天产生的每个细菌都按顺序贪心地选择一个尽可能大的值。</p>
<p>同一天选择的顺序是<strong>无关紧要</strong>的，下面给出证明：</p>
<blockquote>
<p>考虑第 <span class="math inline">\(i\)</span> 天有两个选择的顺序上<strong>相邻</strong>的细菌 <span class="math inline">\(a, b\)</span>，记它们父亲的 s 分别为 <span class="math inline">\(A, B (A &lt; B)\)</span>。</p>
<p>如果让 <span class="math inline">\(a\)</span> 先选，且两者的 <span class="math inline">\(s\)</span> 分别为 <span class="math inline">\(x，y(x &lt; y)\)</span>。</p>
<p>若 <span class="math inline">\(y &lt; A\)</span>，那么交换顺序后两者的 <span class="math inline">\(s\)</span> 就为 <span class="math inline">\(y，x\)</span>。</p>
<p>由于 <span class="math inline">\(a, b\)</span> 在同一天产生，它们在决定后续方案时的<strong>地位</strong>相同，那么选择的顺序也就无关紧要了。</p>
<p>若 <span class="math inline">\(y &gt; A\)</span>，那么交换顺序后两者的 s 不变，选择的顺序连方案都不会影响。</p>
</blockquote>
<p>为了方便，把父亲编号为 <span class="math inline">\(j(j&lt;2^i)\)</span> 的细菌编号为 <span class="math inline">\(j+2^i\)</span>。</p>
<p>然后直接按编号顺序确定 <span class="math inline">\(s\)</span> 就行了，为了支持删除和查找前驱，可以用 <code>multiset</code> 来维护没被选择的 <span class="math inline">\(s\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n, m = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    multiset &lt;<span class="keyword">int</span>, greater &lt;<span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) s.<span class="built_in">insert</span>(<span class="built_in">read</span>());</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    c.<span class="built_in">push_back</span>(*s.<span class="built_in">begin</span>()), s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">        <span class="built_in">For</span>(j, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = s.<span class="built_in">upper_bound</span>(c[j]);</span><br><span class="line">            <span class="keyword">if</span>(it != s.<span class="built_in">end</span>()) c.<span class="built_in">push_back</span>(*it), s.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>) &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>) &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ABC</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Dictionary | Gym 100958B</title>
    <url>/Gym100958B/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://codeforces.com/gym/100958/problem/B">题目链接</a></p>
<p>有 <span class="math inline">\(n\)</span> 由<strong>小写字母和 <code>?</code> 组成</strong>的字符串，问有多少种替换 <code>?</code> 的方案，使得最终的字符串 <span class="math inline">\(S_1,S_2,\cdots,S_n\)</span> 满足字典序递增。</p>
<p><span class="math inline">\(n \le 50, |S_i| \le 20\)</span></p>
</blockquote>
<h6 id="我的解法">我的解法：</h6>
<p>在每个字符串的第一个字符被确定后发现第一个字符不同的串之间字典是关系已经确定，关系还未确定的（第一个字符相同）的串组成若干区间。</p>
<p>由于区间之间是独立的，将删掉所有串第一个字符后所有区间内部的合法方案数乘起来就是总方案数，而“删掉所有串第一个字符后所有区间内部的合法方案”是一个数量不多的子问题，考虑把“前多少个字符已经删掉”和“区间”作为 <code>DP</code> 的状态。</p>
<p>我们有一个状态的定义：<span class="math inline">\(f_{i,l,r}\)</span> 表示只从每个串的第 <span class="math inline">\(i\)</span> 个字符开始考虑，替换第 <span class="math inline">\(l\)</span> 个到 <span class="math inline">\(r\)</span> 个串中的 <code>?</code> ，使得 <span class="math inline">\(S_l,S_{l+1},\cdots,S_r\)</span> 满足字典序递增的方案数。</p>
<p>然后发现这个状态虽然描述清楚了子问题，但没有很显然的转移。为了实现高效的转移，每次转移时还需要做一个横向 <code>DP</code>，有点麻烦。</p>
<p>所有给这个状态在添加一维 <span class="math inline">\(k\)</span> 表示第 <span class="math inline">\(l\)</span> 个到 <span class="math inline">\(r\)</span> 个串中第 <span class="math inline">\(i\)</span> 个字符都必须大于等于 <span class="math inline">\(k\)</span>，然后就有很简单的递推：</p>
<p>枚举最小的 <span class="math inline">\(j \in [l,r]\)</span>，使得 <span class="math inline">\(S_{j}[i] &gt; k\)</span>，也就是说 <span class="math inline">\(\forall x \in [l,j-1]\)</span>，有 <span class="math inline">\(S_x[i] = k\)</span>，<span class="math inline">\(\forall x \in [j,r]\)</span>，有 <span class="math inline">\(S_x[i] \ge k + 1\)</span>。 <span class="math display">\[
f_{i,l,r,k}=\sum\limits_{j=l}^{r+1}f_{i+1,l,j-1,&#39;a&#39;}\cdot f_{i,j,r,k+1}
\]</span> 为了处理较短的串提前结束而出现空字符的问题，记 <span class="math inline">\(k=-1\)</span> 表示允许空字符出现。如果 <span class="math inline">\(S_l[i]\)</span> 是空字符，那么它就等于 <span class="math inline">\(f_{i,l+1,r,&#39;a&#39;}\)</span>，否则是 <span class="math inline">\(f_{i,l,r,&#39;a&#39;}\)</span>，如果 <span class="math inline">\(k \ne -1\)</span>，那么 <span class="math inline">\(S_l[i]\)</span> 就不能是空字符。</p>
<p>最后是边界条件：当 <span class="math inline">\(l &gt; r\)</span> 时值为 <span class="math inline">\(1\)</span>，当 <span class="math inline">\(l \le r \land k &gt; &#39;z&#39;\)</span> 时值为 <span class="math inline">\(0\)</span>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">55</span>][<span class="number">25</span>];</span><br><span class="line">ll f[<span class="number">25</span>][<span class="number">55</span>][<span class="number">55</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">if</span>(k &gt; <span class="number">25</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">return</span> S[l][i] ? <span class="built_in">dp</span>(i, l, r, <span class="number">0</span>) : <span class="built_in">dp</span>(i, l + <span class="number">1</span>, r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!S[l][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll&amp; res = f[i][l][r][k];</span><br><span class="line">    <span class="keyword">if</span>(~res) <span class="keyword">return</span> res; res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(j, l, r + <span class="number">1</span>) &#123;</span><br><span class="line">        res = (res + <span class="built_in">dp</span>(i + <span class="number">1</span>, l, j - <span class="number">1</span>, <span class="number">-1</span>) * <span class="built_in">dp</span>(i, j, r, k + <span class="number">1</span>)) % P;</span><br><span class="line">        <span class="keyword">if</span>(S[j][i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; S[j][i] != <span class="string">&#x27;a&#x27;</span> + k) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; (S[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">mem</span>(f, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="其他的解法">其他的解法：</h6>
<ol type="1">
<li><p>第一篇代码状态设定和转移和我的解法相同，但对于空字符的处理是<strong>把它当做一个比“a"小</strong>的字符，然后将所有串的长度全部补成 <span class="math inline">\(20\)</span>，把 <span class="math inline">\(k=&#39;z&#39;+1\)</span> 和 <span class="math inline">\(i=21\)</span> 作为边界情况，同时限制 <code>?</code> 不能变成空字符。但转移时需要特判没有字符 <span class="math inline">\(k\)</span> 和全部是字符 <span class="math inline">\(k\)</span> 的情况。</p></li>
<li><p>第二篇代码是把 <span class="math inline">\(f_{i,l,r}\)</span> 作为状态，转移时作一个横向 DP，设 <span class="math inline">\(T_{i,j}\)</span> 表示当前已经填了字符"a"-<span class="math inline">\(i\)</span>（不一定用过），填好第 <span class="math inline">\(l\)</span> 到第 <span class="math inline">\(i\)</span> 个串的方案数。</p>
<p>我不太清楚这样做的复杂度。</p></li>
<li><p>第三篇和第一篇的唯一区别是把空区间作为边界条件，转移时无需特判。</p></li>
</ol>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Password Remembering | UVa12212</title>
    <url>/UVa12212/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=244&amp;page=show_problem&amp;problem=3364">题目链接</a></p>
<p>输入正整数 <span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span> <span class="math inline">\((A \le B &lt; 2^{64})\)</span>，求有多少个整数 <span class="math inline">\(n\)</span> 满足: <span class="math inline">\(A \le n \le B \land A \le rev(n) \le B\)</span>。<span class="math inline">\(rev(1203)=3021\)</span>，<span class="math inline">\(rev(1050)=501\)</span>。</p>
</blockquote>
<p>不难看出此题是一个数位 DP，可以把以下作为状态：</p>
<ul>
<li>高 <span class="math inline">\(i\)</span> 位已经确定。</li>
<li>高 <span class="math inline">\(i\)</span> 位与 <span class="math inline">\(A\)</span> 的大小关系（大于或等于）。</li>
<li>高 <span class="math inline">\(i\)</span> 位与 <span class="math inline">\(B\)</span> 的大小关系（小于或等于）。</li>
<li>从最高非零位到第 <span class="math inline">\(i\)</span> 位共有 <span class="math inline">\(j\)</span> 位。</li>
<li>这 <span class="math inline">\(j\)</span> 位翻转后与 <span class="math inline">\(A\)</span> 的低 <span class="math inline">\(j\)</span> 位的大小关系（大于，小于或等于）。</li>
<li>这 <span class="math inline">\(j\)</span> 位翻转后与 <span class="math inline">\(B\)</span> 的低 <span class="math inline">\(j\)</span> 位的大小关系（大于，小于或相等）。</li>
<li>当前是否填了非零位。</li>
<li><code>DP</code> 值是合法的填未确定位的方案数。</li>
</ul>
<p>感觉这个 DP 非常麻烦，状态数太多，有两维还是 <span class="math inline">\(0/1/2\)</span> 的。</p>
<p>考虑差分一下，记 <span class="math inline">\(\text{calc}(A, B)\)</span> 表示有多少个整数 <span class="math inline">\(n\)</span> 满足: <span class="math inline">\(n&lt;A \land rev(n)&lt;B\)</span></p>
<p>那么答案是 <span class="math inline">\(\text{calc}(B+1,B+1)-\text{calc}(A,B+1)-\text{calc}(B+1,A)+\text{calc}(A,A)\)</span></p>
<p>剩下的问题是实现 <span class="math inline">\(\text{calc}\)</span> 函数，还是考虑数位 DP，但状态只需存：</p>
<ul>
<li>高 <span class="math inline">\(i\)</span> 位已经确定。</li>
<li>高 <span class="math inline">\(i\)</span> 位与 <span class="math inline">\(A\)</span> 的大小关系（大于或等于）。</li>
<li>从最高非零位到第 <span class="math inline">\(i\)</span> 位共有 <span class="math inline">\(j\)</span> 位。</li>
<li>这 <span class="math inline">\(j\)</span> 位翻转后与 <span class="math inline">\(B\)</span> 的低 <span class="math inline">\(j\)</span> 位的大小关系（小于或不小于）。</li>
<li>当前是否填了非零位。</li>
</ul>
<p>状态数现在少了两维，而且没有 <span class="math inline">\(0/1/2\)</span> 的。</p>
<p>现在考虑转移方程：当前的状态是 <span class="math inline">\({(i,leA,j,leB,hv0)}\)</span>, 枚举第 <span class="math inline">\(i-1\)</span> 位上填 <span class="math inline">\(s\)</span>.</p>
<p>要填或已经填了非零位（<span class="math inline">\(hv0=0\lor s&gt;0\)</span>)： <span class="math display">\[
(i-1,leA\lor s&lt;a_{i-1},j+1,s&lt;b_{j+1}\lor (s=b_{j+1}\land leB),0)\leftarrow (i,leA,j,leB,0)
\]</span> 否则 <span class="math display">\[
(i-1,leA\lor s&lt;a_{i-1},1,0,1)\leftarrow (i,leA,1,0,1)
\]</span> 最后，调用 <span class="math inline">\(\text{calc}\)</span> 函数时特判 <span class="math inline">\(A=2^{64}\)</span> 和 <span class="math inline">\(B=2^{64}\)</span> 的情况。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> U64[] = &#123; <span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span> &#125;;</span><br><span class="line">ull A, B, f[<span class="number">25</span>][<span class="number">25</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]; <span class="keyword">int</span> na, a[<span class="number">25</span>], nb, b[<span class="number">25</span>];</span><br><span class="line"><span class="function">ull <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> leA, <span class="keyword">int</span> leB, <span class="keyword">int</span> hv0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i) <span class="keyword">return</span> leA &amp;&amp; (j &lt;= nb || leB);</span><br><span class="line">    ull&amp; res = f[i][j][leA][leB][hv0];</span><br><span class="line">    <span class="keyword">if</span>(~res) <span class="keyword">return</span> res; res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(s, <span class="number">0</span>, j &gt; nb ? <span class="number">0</span> : leA ? <span class="number">9</span> : a[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> Hv0 = hv0 &amp; !s;</span><br><span class="line">        res += <span class="built_in">dp</span>(i - <span class="number">1</span>, j &gt; nb ? j : j + !Hv0, leA || s &lt; a[i], j &gt; nb ? leB : !Hv0 &amp;&amp; (s &lt; b[j] || (s == b[j] &amp;&amp; leB)), Hv0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">calc</span><span class="params">(ull A, ull B)</span> </span>&#123;</span><br><span class="line">    na = nb = <span class="number">0</span>, <span class="built_in">mem</span>(f, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(A) <span class="keyword">while</span>(A) a[++na] = A % <span class="number">10</span>, A /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">20</span>) a[++na] = U64[i];</span><br><span class="line">    <span class="keyword">if</span>(B) <span class="keyword">while</span>(B) b[++nb] = B % <span class="number">10</span>, B /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">20</span>) b[++nb] = U64[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(na, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="built_in">rep</span>(kase, <span class="number">1</span>, T) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%llu%llu&quot;</span>, &amp;A, &amp;B), B++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %llu\n&quot;</span>, kase, <span class="built_in">calc</span>(B, B) - <span class="built_in">calc</span>(A, B) - <span class="built_in">calc</span>(B, A) + <span class="built_in">calc</span>(A, A));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数位动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>一道题2</title>
    <url>/problem2/</url>
    <content><![CDATA[<blockquote>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span>，把 <span class="math inline">\(A\)</span> 划分为两个非空集合，划分的价值为两个集合的异或和加起来，求可能的最大价值。</p>
<p><span class="math inline">\(n \le 10^5,A_i \le 10^{18}\)</span></p>
</blockquote>
<p>设总异或和为 <span class="math inline">\(sum\)</span> ，若两个集合的异或和分别为 <span class="math inline">\(S_1,S_2\)</span>，由 <span class="math inline">\(S_1 \oplus S_2 = sum\)</span> 知道，若 <span class="math inline">\(sum\)</span> 第 <span class="math inline">\(i\)</span> 位为 <span class="math inline">\(1\)</span>，不管怎么划分，第 <span class="math inline">\(i\)</span> 位一定产生一次贡献。若 <span class="math inline">\(sum\)</span> 第 <span class="math inline">\(i\)</span> 位为 <span class="math inline">\(0\)</span>，那么 <span class="math inline">\(S_1,S_2\)</span> 在第 <span class="math inline">\(i\)</span> 位上相同。</p>
<p>考虑 <span class="math inline">\(sum\)</span> 为 <span class="math inline">\(0\)</span> 的位，由于 <span class="math inline">\(S_1,S_2\)</span> 在这些位上是相同的，只需要最大化 <span class="math inline">\(S_1\)</span> 就行了，由于 <span class="math inline">\(S_1\)</span> 为全集和空集都不会成为最优解，问题就转化为：</p>
<p>给定n个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。</p>
<p>用线性基解决。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100005</span>], bas[<span class="number">70</span>], su, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]), su ^= a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) a[i] &amp;= ~su;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">per</span>(j, <span class="number">59</span>, <span class="number">0</span>) <span class="keyword">if</span>(a[i] &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bas[j]) a[i] ^= bas[j];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">per</span>(k, j - <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">if</span>(a[i] &gt;&gt; k &amp; <span class="number">1</span>) a[i] ^= bas[k];</span><br><span class="line">            <span class="built_in">rep</span>(k, j + <span class="number">1</span>, <span class="number">59</span>) <span class="keyword">if</span>(bas[k] &gt;&gt; j &amp; <span class="number">1</span>) bas[k] ^= a[i];</span><br><span class="line">            bas[j] = a[i]; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">59</span>) ans ^= bas[i];</span><br><span class="line">    cout &lt;&lt; su + ans * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>一道题1</title>
    <url>/problem1/</url>
    <content><![CDATA[<blockquote>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>。有 <span class="math inline">\(q\)</span> 次询问，每次给出区间 <span class="math inline">\([L,R]\)</span> ,</p>
<p>求 <span class="math inline">\(\max\limits_{L\le l&lt;r\le R}\dfrac{\sum_{i=l}^ra_i}{r-l}\)</span></p>
<p><span class="math inline">\(n\le 10^5,q\le 3\cdot 10^4,|a_i|\le 10^6\)</span></p>
</blockquote>
<p>先把原问题转化成斜率最大值。</p>
<p>记 <span class="math inline">\(s_i=\sum_{j=1}^ia_j,\text{点}A_i(i,s_{i-1}),\text{点}B_i(i,s_i)\)</span></p>
<p><span class="math inline">\(\text{原式}=\max\limits_{L\le i &lt; j\le R}\text{Slope}_{A_i,B_j}\)</span></p>
<p>考虑 <span class="math inline">\(L=1,R=n\)</span> 时怎么做。</p>
<ul>
<li><p>从左往右依次扫描，同时维护 <span class="math inline">\(A\)</span> 类点的下凸包，每次二分求出 <span class="math inline">\(B_i\)</span> 过当前凸包上的切点。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p></li>
<li><p><strong>线性做法</strong>：单调队列维护 <span class="math inline">\(A\)</span> 类点的下凸包，一旦发现队首不是当前 <span class="math inline">\(B_i\)</span> 过当前凸包上的切点，就将队首弹出。</p>
<p>这样做可能会导致之后的一些 <span class="math inline">\(B_i\)</span> 的切点被弹出而失去这些 <span class="math inline">\(B_i\)</span> 的最优解，但可以证明这样做不会错过<strong>全局最优解</strong>。</p>
<p><strong>如图</strong>，扫描到 <span class="math inline">\(E\)</span> 时切点已经不是 <span class="math inline">\(A\)</span> 了，弹出 <span class="math inline">\(A\)</span> 后会导致扫到 <span class="math inline">\(F\)</span> 时失去最优解。</p>
<p>但因为 <span class="math inline">\(F\)</span> 的切线是 <span class="math inline">\(AF\)</span>, 所以 <span class="math inline">\(\text{Slope}_{AF}&lt;\text{Slope}_{AB}&lt;\text{Slope}_{BE}\)</span>。</p>
<p>故 <span class="math inline">\(AF\)</span> 劣于 <span class="math inline">\(BE\)</span>, <span class="math inline">\(A\)</span> 已经不可能更新最优解。</p>
<p><img src="https://i.loli.net/2020/11/18/ncWZHmCtw2bokxX.png" /></p></li>
</ul>
<p>考虑分块，令 <span class="math inline">\(sz=\sqrt n\)</span>，每次查询分两类：</p>
<ul>
<li><p>当 <span class="math inline">\(A_i,B_j\)</span> 都在边角（在同一个块或不同块）中时，直接对所有边角使用线性做法求出这类最优解。</p></li>
<li><p>当 <span class="math inline">\(A_i,B_j\)</span> 至少有一个在大块中时。</p>
<p>预处理 <span class="math inline">\(pre_{i,j}=\max\limits_{sz\cdot i\le I&lt; J \le j}\text{Slope}_{A_I,B_J},suf_{i,j}=\max\limits_{j\le I&lt;J\le sz\cdot i}\text{Slope}_{A_I,B_J}\)</span></p>
<p>预处理方式也使用线性做法。</p>
<p>用 <span class="math inline">\(pre_{\lceil\frac L{sz}\rceil,R},suf_{\lfloor\frac R{sz}\rfloor,L}\)</span> 更新答案。</p></li>
</ul>
<p>综上，时间复杂度 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>, M = <span class="number">125</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">getchar</span>(), r = <span class="number">0</span>, f = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="number">48</span>) &#123; <span class="keyword">if</span>(c == <span class="number">45</span>) f = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="number">47</span>) r = r * <span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> r * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, Q, sz; ll a[N], maU[M][N]; <span class="keyword">int</span> maD[M][N];<span class="comment">// U 后缀表示分子，D 后缀表示分母</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"><span class="keyword">int</span> l, r, x[N], D; ll y[N], U;<span class="comment">// U/D 是答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; l = <span class="number">1</span>, r = <span class="number">0</span>, U = <span class="number">-1e9</span>, D = <span class="number">1</span>; &#125;<span class="comment">// 清空凸包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(ll u, <span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">// 更新答案</span></span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="number">0</span>) u = -u, d = -d;</span><br><span class="line">    <span class="keyword">if</span>(u * D &gt; U * d) U = u, D = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> X, ll Y)</span> </span>&#123;<span class="comment">// X 递增时维护的是下凸包，递减时维护的是上凸包</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r &amp;&amp; (y[r] - y[r<span class="number">-1</span>]) * (X - x[r]) &gt;= (Y - y[r]) * (x[r] - x[r<span class="number">-1</span>])) r--;</span><br><span class="line">    x[++r] = X, y[r] = Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> X, ll Y)</span> </span>&#123;<span class="comment">// 过该点作切线并更新答案</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r &amp;&amp; (Y - y[l]) * (X - x[l+<span class="number">1</span>]) &lt;= (Y - y[l+<span class="number">1</span>]) * (X - x[l])) l++;</span><br><span class="line">    <span class="built_in">upd</span>(Y - y[l], X - x[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q, sz = <span class="built_in">sqrt</span>(n * <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, n) a[i] = <span class="built_in">read</span>() + a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">per</span>(i, (n - <span class="number">1</span>) / sz, <span class="number">0</span>) &#123; <span class="comment">// 为了压空间，pre, suf 数组合并成 ma 数组 </span></span><br><span class="line">        <span class="built_in">init</span>(); <span class="built_in">For</span>(j, i * sz, n) <span class="built_in">qry</span>(j, a[j]), maU[i][j] = U, maD[i][j] = D, <span class="built_in">ins</span>(j, a[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">init</span>(); <span class="built_in">per</span>(j, i * sz, <span class="number">0</span>) <span class="built_in">qry</span>(j, a[j<span class="number">-1</span>]), maU[i][j] = U, maD[i][j] = D, <span class="built_in">ins</span>(j, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    <span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">        L = <span class="built_in">read</span>() - <span class="number">1</span>, R = <span class="built_in">read</span>() - <span class="number">1</span>, <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">if</span>(L / sz ^ R / sz) &#123;</span><br><span class="line">            <span class="built_in">For</span>(i, L, L / sz * sz + sz) <span class="built_in">qry</span>(i, a[i]), <span class="built_in">ins</span>(i, a[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="built_in">rep</span>(i, R / sz * sz, R) <span class="built_in">qry</span>(i, a[i]), <span class="built_in">ins</span>(i, a[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="built_in">upd</span>(maU[(L+sz<span class="number">-1</span>)/sz][R], maD[(L+sz<span class="number">-1</span>)/sz][R]);</span><br><span class="line">            <span class="built_in">upd</span>(maU[R/sz][L], maD[R/sz][L]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">rep</span>(i, L, R) <span class="built_in">qry</span>(i, a[i]), <span class="built_in">ins</span>(i, a[i<span class="number">-1</span>]);</span><br><span class="line">        ll d = <span class="built_in">gcd</span>(<span class="built_in">llabs</span>(U), D);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, U / d, D / d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vasya and Polynomial | Codeforeces 493E</title>
    <url>/CF493E/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/493/problem/E">题目链接</a></p>
<p>原题题意：给你三个正整数 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>，问多少个<strong>非负整系数</strong>多项式 <span class="math inline">\(F\)</span>, 满足 <span class="math inline">\(F(a)=b \land F(b)=c\)</span></p>
<p><span class="math inline">\(1 \le a, b, c \le 10^{18}\)</span></p>
</blockquote>
<p>若 <span class="math inline">\(a=1,b=1\)</span> 答案显然。</p>
<p>否则因为<strong>非负整系数</strong>的限制，多项式系数是 <span class="math inline">\(\log\)</span> 级别的。</p>
<p>我们考虑一个更一般的问题：问多少个<strong>非负整系数</strong>多项式 <span class="math inline">\(F\)</span>, 满足 <span class="math display">\[
F(a)=x \land F(b)=y \land x \le b
\]</span> 设 <span class="math inline">\(F\)</span> 的常数项为 <span class="math inline">\(V\)</span>。</p>
<p>根据 <span class="math inline">\(F(a)=x\)</span> 和 <span class="math inline">\(F(b)=y\)</span> 知道 <span class="math inline">\(V \le x, V \equiv y\ (mod\ b)\)</span>。</p>
<p>分两种情况。</p>
<ol type="1">
<li><p>当 <span class="math inline">\(x=b \land b\ |\ y\)</span> 时，则 <span class="math inline">\(V=0 \lor V=x\)</span>，</p>
<p>若 <span class="math inline">\(V=x\)</span>，因为 <span class="math inline">\(F(a)=x\)</span>, 所以 <span class="math inline">\(F\)</span> 只能是常函数 <span class="math inline">\(F(x)=V\)</span>，当 <span class="math inline">\(x \ne y\)</span> 时无解。</p>
<p>另一种情况，因为 <span class="math inline">\(F(a)-V=x-V\)</span>，所以 <span class="math inline">\(a\)</span> 要能整除 <span class="math inline">\(x-V\)</span>，如果不整除就无解。</p>
<p>否则令 <span class="math inline">\(G(x)=\dfrac{F(x)-V}x\)</span>，有 <span class="math inline">\(G(a)=\dfrac{x-V}a，G(b)=\dfrac{y-V}b\)</span>。</p>
<p>显然 <span class="math inline">\(\dfrac{x-V}a \le x \le b\)</span>，因此就转化为了一个子问题。</p></li>
<li><p>当 <span class="math inline">\(x &lt; b \lor b \not |\ y\)</span> 时，显然 <span class="math inline">\(V=y \mod b\)</span>，可以转化为子问题。</p></li>
</ol>
<p>边界条件是 <span class="math inline">\(xy=0\)</span>, 这意味着无解（<span class="math inline">\(F(x)=0\)</span> 不算合法）。</p>
<p>然后就可以求出多项式的数量了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a, b, c; </span><br><span class="line">find(ll x, ll y) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> <span class="number">0</span>; ll v = y % b;</span><br><span class="line">    <span class="keyword">return</span> ((x - v) % a ? <span class="number">0</span> : find((x - v) / a, (y - v) / b)) + (x == y);</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>) <span class="built_in">puts</span>(c &gt; <span class="number">1</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;inf&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, find(b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何求<strong>次数最高的前提下字典序最小</strong>的多项式？</p>
<p>分析递归过程，每个次数的合法多项式<strong>最多一个</strong>，递归时优先选择次数高的就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">cnt, ans; ll a, b, c, A[<span class="number">100</span>];</span><br><span class="line">find(ll x, ll y, <span class="keyword">int</span> d) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span>;</span><br><span class="line">    ll v = A[d] = y % b;</span><br><span class="line">    <span class="keyword">if</span>((x - v) % a == <span class="number">0</span>) find((x - v) / a, (y - v) / b, d + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(x == y) &#123; <span class="keyword">if</span>(!ans) A[cnt = d] = x; ans++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">main(T) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>) <span class="built_in">puts</span>(c &gt; <span class="number">1</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="number">0</span>, find(b, c, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">            <span class="keyword">if</span>(ans) <span class="keyword">for</span>(<span class="built_in">printf</span>(<span class="string">&quot;\n%d &quot;</span>, cnt); ~cnt; <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, A[cnt--]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 std::streambuf 的 Fast IO 模板</title>
    <url>/ji-yu-stdstreambuf-de-fast-io-mo-ban/</url>
    <content><![CDATA[<h3 id="读入输出非负整数版">读入输出非负整数版</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">static</span> streambuf* in = cin.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + in -&gt; sgetn(buf, M), p1 == p2) ? -1 : *p1++)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[M], *p1, *p2;</span><br><span class="line">    <span class="keyword">int</span> c = gc, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="number">48</span>) c = gc;</span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="number">47</span>) r = r * <span class="number">10</span> + (c &amp; <span class="number">15</span>), c = gc;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：<code>main</code> 函数开头请加入这 <span class="math inline">\(3\)</span> 句话</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>其实后两句可以选择性添加，见文末。</p>
<p><strong>不可与 <code>cin, cout, scanf, printf, gets, puts, getchar, putchar</code> 等其他读入输出方式同时使用</strong></p>
<p>其实也不是全部不能同时使用，见文末。</p>
<p><strong><code>read</code> 函数只能通过文件输入或者标准输入完后按 <code>Ctrl + Z</code> （仅 <code>WIN 10</code>）。</strong></p>
<h3 id="读入输出整数版">读入输出整数版</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">static</span> streambuf* in = cin.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gc (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + in -&gt; sgetn(buf, M), p1 == p2) ? -1 : *p1++)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[M], *p1, *p2;</span><br><span class="line">    <span class="keyword">int</span> c = gc, r = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="number">48</span>) &#123; <span class="keyword">if</span>(c == <span class="number">45</span>) f = <span class="number">-1</span>; c = gc; &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="number">47</span>) r = r * <span class="number">10</span> + (c &amp; <span class="number">15</span>), c = gc;</span><br><span class="line">    <span class="keyword">return</span> r * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">pc</span>(<span class="number">45</span>), x = -x;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：输出 <code>long long</code> 时 <code>wrt</code> 函数中的 <code>c</code> 数组大小要开到 <span class="math inline">\(20\)</span>。</strong></p>
<h3 id="文末补充">文末补充</h3>
<ul>
<li><p>在使用 <code>read</code> 函数时要加 <code>cin.tie(0)</code>，在使用 <code>wrt</code> 函数时要加 <code>cout.tie(0)</code>，但 <code>ios::sync_with_stdio(0)</code> <strong>必须加。</strong></p></li>
<li><p>两个函数不可与 <code>scanf, printf, gets, puts, getchar, putchar</code> 等 <code>stdio</code> 的读入输出方式同时使用。</p>
<p>在 <code>read</code> 函数第一次调用前可以随便使用 <code>cin</code> 等 <code>streambuf</code> 的读入方式。</p>
<p><code>wrt</code> 函数可以与 <code>cout</code> 等 <code>streambuf</code> 的输出方式随便交叉使用。</p></li>
</ul>
]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>一道题</title>
    <url>/problem/</url>
    <content><![CDATA[<blockquote>
<p>给定一棵 <span class="math inline">\(n\)</span> 个节点的树，每个节点 <span class="math inline">\(u\)</span> 上有一个可容纳 <span class="math inline">\(k_u\)</span> 个球的桶，<span class="math inline">\(m\)</span> 次操作：给一个节点到根路径上的所有节点的桶内放一个<strong>有颜色的</strong>球，如果节点的桶满了则不能放进这个节点，<span class="math inline">\(q\)</span> 次询问某节点的桶内的球有多少种颜色。</p>
<p><span class="math inline">\(n, m, q \le 10^5\)</span></p>
</blockquote>
<p>因为节点上的桶有容量，所以只有某时刻前的操作会对该节点产生影响。</p>
<p>记 <span class="math inline">\(Max_u\)</span> 表示<span class="math inline">\(u\)</span>号节点上的桶<strong>恰好</strong>装满的时刻，考虑求出每个节点的 <span class="math inline">\(Max\)</span>，将所有询问以 <span class="math inline">\(Max\)</span> 为关键字升序排序，问题就转化为单点加球，子树查询颜色数的问题。</p>
<ul>
<li><p>求 <span class="math inline">\(Max\)</span>：</p>
<p><span class="math inline">\(Max_u\)</span> 按照定义是所有覆盖 <span class="math inline">\(u\)</span> 节点的操作的时间第 <span class="math inline">\(k_u\)</span> 小，而所有覆盖 <span class="math inline">\(u\)</span> 节点的操作是下端点在 <span class="math inline">\(u\)</span> 子树内的操作，如果能将这些操作放到同一区间上，就可以用主席数实现区间第 <span class="math inline">\(k\)</span> 小。</p>
<p>如果对每个点都至多有一次操作以它为下端点，将这个节点的 dfs 序作为对应操作的下标，操作的时间为值，问题就转化成了区间第 <span class="math inline">\(k\)</span> 小。</p>
<p>但对每个点都可能作为多次操作的下端点，需要将每个结点扩充成一个区间，区间长度为这个节点对应操作的数量，然后就可以类别上一段所说的方法求出 <span class="math inline">\(Max\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x[i], &amp;c[i]);</span><br><span class="line">    tim[dfn[x[i]]].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    R[i] = R[i<span class="number">-1</span>]; <span class="comment">//R[i] 是 dfs 序为 i 的节点对应区间的右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t : tim[i]) SegTree::<span class="built_in">upd</span>(t, R[i]), R[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n) Max[i] = SegTree::<span class="built_in">qry</span>(k[i], R[dfn[i]<span class="number">-1</span>], R[suf[i]]);</span><br></pre></td></tr></table></figure></li>
<li><p>单点加球，子树查询颜色数的问题：</p>
<p>考虑静态查询子树查询颜色数的问题，做法是每个有颜色的结点处 <span class="math inline">\(+1\)</span>，每个结点和同种颜色， <code>dfs</code> 序小于这个结点且 <code>dfs</code> 序最大的结点的 <code>lca</code> 处 <span class="math inline">\(-1\)</span>。</p>
<p>如图</p>
<figure>
<img src="https://i.loli.net/2020/10/24/8mOxgRBsJMpzLI1.jpg" alt=".jpg" /><figcaption aria-hidden="true">.jpg</figcaption>
</figure>
<p>在 <span class="math inline">\(4，5\)</span> 号结点的 <code>lca</code>，<span class="math inline">\(1\)</span> 号结点处 <span class="math inline">\(-1\)</span>。</p>
<p>在 <span class="math inline">\(5，6\)</span> 号结点的 <code>lca</code>，<span class="math inline">\(1\)</span> 号结点处 <span class="math inline">\(-1\)</span>。</p>
<p>...</p>
<p>然后查询子树和就是子树颜色数。</p>
<p>再考虑单点加球，子树查询颜色数的问题。其实只需要加一个 <code>set</code> 数组和树状数组，<code>set</code> 数组维护当前每种颜色结点的 <code>dfs</code> 序，单点加球时在 <code>set</code> 中找出前驱和后继，这个点处 <span class="math inline">\(+1\)</span>，它和前驱的 <code>lca</code> 处 <span class="math inline">\(-1\)</span>，和后继的 <code>lca</code> 处 <span class="math inline">\(-1\)</span>，前驱和后继的 <code>lca</code> 处 <span class="math inline">\(+1\)</span>，然后查询子树和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ci = c[i], dfnx = dfn[x[i]];</span><br><span class="line"><span class="keyword">if</span>(s[ci].<span class="built_in">count</span>(dfnx)) <span class="keyword">return</span>;</span><br><span class="line">s[ci].<span class="built_in">insert</span>(dfnx), <span class="built_in">add</span>(dfnx, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> it = s[ci].<span class="built_in">find</span>(dfnx);</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>, suf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(it != s[ci].<span class="built_in">begin</span>()) pre = *(--it), it++;</span><br><span class="line"><span class="keyword">if</span>(it != --s[ci].<span class="built_in">end</span>()) suf = *(++it), it--;</span><br><span class="line"><span class="keyword">if</span>(pre) <span class="built_in">upd</span>(pre, dfnx, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(suf) <span class="built_in">upd</span>(suf, dfnx, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(pre &amp;&amp; suf) <span class="built_in">upd</span>(pre, suf, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, k[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Seg &#123;</span><br><span class="line">    <span class="keyword">int</span> sz, T[N], c[N*<span class="number">20</span>], ls[N*<span class="number">20</span>], rs[N*<span class="number">20</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lch l, mid, ls[o]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, rs[o]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> oo, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>&amp; o)</span> </span>&#123;</span><br><span class="line">        c[o = ++sz] = c[oo] + <span class="number">1</span>, ls[o] = ls[oo], rs[o] = rs[oo];</span><br><span class="line">        <span class="keyword">if</span>(p &gt; mid) <span class="built_in">upd</span>(rs[oo], p, rch);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l ^ r) <span class="built_in">upd</span>(ls[oo], p, lch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o, <span class="keyword">int</span> oo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> k &gt; <span class="number">1</span> ? m : l;</span><br><span class="line">        <span class="keyword">int</span> cnt = c[ls[o]] - c[ls[oo]];</span><br><span class="line">        <span class="keyword">return</span> k &lt;= cnt ? <span class="built_in">qry</span>(k, lch, ls[oo]) : <span class="built_in">qry</span>(k - cnt, rch, rs[oo]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">upd</span>(T[t], p, <span class="number">0</span>, m, T[t+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qry</span>(k, <span class="number">0</span>, m, T[r], T[l]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Tree &#123;</span><br><span class="line">    <span class="keyword">int</span> idx, dfn[N], suf[N], rnk[N], d[N], fa[<span class="number">20</span>][N];</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; G[N]; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        rnk[dfn[u] = ++idx] = u;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">19</span>) fa[i][u] = fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][u]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) <span class="keyword">if</span>(v ^ fa[<span class="number">0</span>][u])</span><br><span class="line">            fa[<span class="number">0</span>][v] = u, d[v] = d[u] + <span class="number">1</span>, <span class="built_in">dfs</span>(v);</span><br><span class="line">        suf[u] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u] &lt; d[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="built_in">per</span>(i, <span class="number">19</span>, <span class="number">0</span>) <span class="keyword">if</span>(d[u] - (<span class="number">1</span> &lt;&lt; i) &gt;= d[v]) u = fa[i][u];</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="built_in">per</span>(i, <span class="number">19</span>, <span class="number">0</span>) <span class="keyword">if</span>(fa[i][u] ^ fa[i][v]) u = fa[i][u], v = fa[i][v];</span><br><span class="line">        <span class="keyword">return</span> fa[<span class="number">0</span>][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> Max[N], R[N], x[N], c[N], g[N];</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; tim[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pretreat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x[i], &amp;c[i]), g[i] = c[i];</span><br><span class="line">            tim[dfn[x[i]]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(g + <span class="number">1</span>, g + m + <span class="number">1</span>);<span class="comment">//离散化颜色</span></span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) c[i] = <span class="built_in">lower_bound</span>(g + <span class="number">1</span>, g + m + <span class="number">1</span>, c[i]) - g;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            R[i] = R[i<span class="number">-1</span>];<span class="comment">//R[i] 是 dfs 序为 i 的节点对应区间的右端点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t : tim[i]) Seg::<span class="built_in">upd</span>(t, R[i]), R[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) Max[i] = Seg::<span class="built_in">qry</span>(k[i], R[dfn[i]<span class="number">-1</span>], R[suf[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> C[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= n; i += i &amp; -i) C[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> r = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; i; i &amp;= i - <span class="number">1</span>) r += C[i];</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qry</span>(suf[u]) - <span class="built_in">qry</span>(dfn[u] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set &lt;<span class="keyword">int</span>&gt; s[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(dfn[<span class="built_in">lca</span>(rnk[u], rnk[v])], x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//单点加球</span></span><br><span class="line">        <span class="keyword">int</span> ci = c[i], dfnx = dfn[x[i]];</span><br><span class="line">        <span class="keyword">if</span>(s[ci].<span class="built_in">count</span>(dfnx)) <span class="keyword">return</span>;</span><br><span class="line">        s[ci].<span class="built_in">insert</span>(dfnx), <span class="built_in">add</span>(dfnx, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> it = s[ci].<span class="built_in">find</span>(dfnx);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, suf = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(it != s[ci].<span class="built_in">begin</span>()) pre = *(--it), it++;</span><br><span class="line">        <span class="keyword">if</span>(it != --s[ci].<span class="built_in">end</span>()) suf = *(++it), it--;</span><br><span class="line">        <span class="keyword">if</span>(pre) <span class="built_in">upd</span>(pre, dfnx, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(suf) <span class="built_in">upd</span>(suf, dfnx, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; suf) <span class="built_in">upd</span>(pre, suf, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], u, v, ans[N]; vector &lt;<span class="keyword">int</span>&gt; id[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        Tree::G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        Tree::G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    Tree::<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k[i]);</span><br><span class="line">    Tree::<span class="built_in">pretreat</span>();</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x[i]), id[Tree::Max[x[i]]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        Tree::<span class="built_in">ins</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j : id[i]) ans[j] = Tree::<span class="built_in">Qry</span>(x[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, q) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>TheCowDivOne | TopCoder 11351</title>
    <url>/TC11351/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://vjudge.net/problem/TopCoder-11351/origin">题目链接</a></p>
<p>给定 <span class="math inline">\(n, k\)</span>。</p>
<p>求出从 <span class="math inline">\(0,1,2,\cdots,n-1\)</span> 中选出 <span class="math inline">\(k\)</span> 个总和能被 <span class="math inline">\(n\)</span> 整除的数的方案数，模 <span class="math inline">\(10^9+7\)</span>。</p>
<p><span class="math inline">\(n \le 10^9, k \le 1000\)</span></p>
</blockquote>
<p>我们先确定 <span class="math inline">\(k - 1\)</span> 个数的值，再解出最后一个数，这样可能导致最后一个数被选 <span class="math inline">\(2\)</span> 次。</p>
<p>考虑容斥，减去钦定它选了 <span class="math inline">\(2\)</span> 次的方案数，加上钦定它选了 <span class="math inline">\(3\)</span> 次的方案数，<span class="math inline">\(\cdots\)</span>。</p>
<p>钦定最后一个数 <span class="math inline">\(x\)</span> 出现了至少 <span class="math inline">\(t\)</span> 次，那么设另外 <span class="math inline">\(k - t\)</span> 个数的和为 <span class="math inline">\(S\)</span>，则方程： <span class="math display">\[
tx + S \equiv 0\pmod n
\]</span> 在 <span class="math inline">\([0, n)\)</span> 范围内，方程有解条件为 <span class="math display">\[
\gcd(t,n)|S
\]</span> 解的个数为 <span class="math display">\[
\gcd(t,n)
\]</span> 设 <span class="math inline">\(f_{i,S}\)</span> 表示 <span class="math inline">\(i\)</span> 个数的和被 <span class="math inline">\(S\)</span> 整除的方案数，则 <span class="math display">\[
f_{i,S} = \frac 1i \sum_{j = 1}^i (-1)^{j+1} \frac nS\gcd(j,S) f_{i-j,\gcd(j,S)}
\]</span> 乘 <span class="math inline">\(\frac nS\)</span> 是因为我们是要求 <span class="math inline">\([0,\ n)\)</span> 中解的个数， <span class="math inline">\(\frac 1i\)</span> 是因为我们相当于钦定最后一个数为特殊数，而实际要求的是无序方案。 观察转移方程，显然除了 <span class="math inline">\(S=n\)</span> 的情况，一定有 <span class="math inline">\(S|(k-i)\)</span>，故总状态数为 <span class="math inline">\(k\log k\)</span>，即复杂度为 <span class="math inline">\(O(k^2\log k)\)</span>。</p>
<p>代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> ll P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll inv[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TheCowDivOne</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, k) inv[i] = (P - P / i) * inv[P % i] % P;</span><br><span class="line">        <span class="built_in">rep</span>(s, <span class="number">1</span>, k) f[<span class="number">0</span>][s] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, k) <span class="built_in">rep</span>(s, <span class="number">1</span>, k) <span class="keyword">if</span>((k - i) % s == <span class="number">0</span>) &#123;</span><br><span class="line">            ll&amp; re = f[i][s];</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, i) &#123;</span><br><span class="line">                <span class="keyword">int</span> g = __gcd(j, s);</span><br><span class="line">                (re += (j &amp; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>) * n / s * g * f[i - j][g]) %= P;</span><br><span class="line">            &#125;</span><br><span class="line">            re = re * inv[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        ll as = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, k) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = __gcd(j, n);</span><br><span class="line">            (as += (j &amp; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>) * g * f[k - j][g]) %= P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (as + P) * inv[k] % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>TopCoder</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>动态规划</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>关于康威生命游戏</title>
    <url>/guan-yu-xi-bao-zi-dong-ji-kang-wei-sheng-ming-you-xi/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://playgameoflife.com/">Play</a></p>
<p>生命游戏中，对于任意细胞，规则如下：</p>
<ul>
<li><p>每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围<strong>八格</strong>细胞产生互动</p></li>
<li><p>当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态。（模拟生命数量稀少）</p></li>
<li><p>当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样。</p></li>
<li><p>当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</p></li>
<li><p>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。（模拟繁殖）</p>
<p>按规则处理当前的细胞图，可以得到下一代的细胞图，周而复始。</p></li>
</ul>
</blockquote>
<p>我的一些发现。 1. 核心元件：结构简单，演变 230 轮。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ■   ■</span><br><span class="line">■ ■ ■ ■</span><br><span class="line">  ■   ■</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p>循环周期优美的元件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ■   ■          ■   ■</span><br><span class="line">■ ■ ■ ■  3 格  ■ ■ ■ ■</span><br><span class="line">  ■   ■          ■   ■</span><br></pre></td></tr></table></figure></p></li>
<li><p>演变 650 轮（放 4 个滑翔机）的元件： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ■   ■          ■   ■</span><br><span class="line">■ ■ ■ ■  7 格  ■ ■ ■ ■</span><br><span class="line">  ■   ■          ■   ■</span><br></pre></td></tr></table></figure></p></li>
<li><p>演变 2500 轮（放 20 个滑翔机）的元件： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ■   ■          ■   ■</span><br><span class="line">■ ■ ■ ■ 10 格  ■ ■ ■ ■</span><br><span class="line">  ■   ■          ■   ■</span><br></pre></td></tr></table></figure></p></li>
<li><p>有点长的循环周期： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">■    ■           ■   ■</span><br><span class="line">■ ■ ■ ■  2 格  ■ ■ ■ ■</span><br><span class="line">■    ■           ■   ■</span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>一言（持续更新）</title>
    <url>/yi-yan/</url>
    <content><![CDATA[<p>尝试 <code>Ctrl + F</code> 一下您看过的动漫吧。</p>
<ul>
<li><p><strong>与众不同的生活方式很累人呢，因为找不到借口。</strong> —— 幸运星</p></li>
<li><p><strong>面对就好，去经历就好。</strong> —— 花伞菌</p></li>
<li><p><strong>将愿望倾入不愿忘却的回忆中……</strong> —— ef-a tale of memories</p></li>
<li><p><strong>美好的人眼里映出的世界也是美好的。</strong> —— ARIA</p></li>
<li><p><strong>看似美好的东西，往往藏着陷阱。</strong> —— 只有神知道的世界</p></li>
<li><p><strong>天空是连着的，如果我们也能各自发光的话，无论距离有多远，都能看到彼此努力的身影。</strong> —— 龙虎斗</p></li>
<li><p><strong>恋ではなく、爱でもなく、もっとずっと 深く重い。</strong> —— sweet pool</p></li>
<li><p><strong>花开花落，再灿烂的星光也会消失。</strong> —— 圣斗士星矢</p></li>
<li><p><strong>挡着在我们面前的是巨大庞然的人生，阻隔在我们中间的是广阔无际的时间，对于他们，我们无能为力……</strong> —— 秒速五厘米</p></li>
<li><p><strong>我是一个经常笑的人，可我不是经常开心的人。</strong> —— 未闻花名</p></li>
<li><p><strong>努力是不会背叛自己的，虽然梦想有时会背叛自己。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>人经历风浪是会变得更强，可是船不同，日积月累的只有伤痛。</strong> —— 海贼王</p></li>
<li><p><strong>真相只有一个！</strong> —— 柯南</p></li>
<li><p><strong>用你的笑容去改变这个世界，别让这个世界改变了你的笑容。</strong> —— 网络</p></li>
<li><p><strong>我有在反省，但我不后悔。</strong> —— 物语系列</p></li>
<li><p><strong>我没有梦想，但是我能保护！</strong> —— 假面骑士555</p></li>
<li><p><strong>或许只需一滴露水，便能守护这绽放的花朵。</strong> —— 反叛的鲁鲁修</p></li>
<li><p><strong>我不会让任何人看到我软弱的一面。</strong> —— 桔梗</p></li>
<li><p><strong>当你想做一件事，却无能为力的时候，是最痛苦的。</strong> —— 高达SEED</p></li>
<li><p><strong>我的腿让我停下，可是心却不允许我那么做。</strong> —— 钢之炼金术师</p></li>
<li><p><strong>我手中的魔法，是守护挚爱的力量，是坚定这个信念所必须的力量，我一定会拯救你的，无论在何时、何地。</strong> —— 魔法少女奈叶</p></li>
<li><p><strong>比任何人都要了解自己，比任何人都要关爱自己。喜欢上这样的人，并没有什么奇怪的呢。</strong> —— 初音岛</p></li>
<li><p><strong>像平常的你一样引发奇迹吧-</strong> —— 魔法少女小圆</p></li>
<li><p><strong>既不回头，何必不忘；既然无缘，何须誓言；今日种种，似水无痕；明夕何夕，君已陌路。</strong> —— 仙剑奇侠传</p></li>
<li><p><strong>可是就算我们通一千次短信，我们各自的心，大概也只会相互靠近一厘米吧。</strong> —— 秒速5厘米</p></li>
<li><p><strong>所谓的言语，只有当对方听进去了才开始有意义啊。</strong> —— 少年同盟</p></li>
<li><p><strong>如果还有来生 ，我无论如何都要来到你身边，我已经没有了其他想要追求的东西，因为没有比你更重要的了。</strong> —— 秒速五厘米</p></li>
<li><p><strong>世界上没有一个人能代替另一个人。</strong> —— 人型电脑天使心</p></li>
<li><p><strong>其实，恋爱这种东西，当你看上人家的那一刹那就已经失败了。</strong> —— 秋之回忆</p></li>
<li><p><strong>隐约雷鸣，阴霾天空，即使天无雨，我亦留此地。</strong> —— 言叶之庭</p></li>
<li><p><strong>就是因为你不好，才要留在你身边，给你幸福。</strong> —— 哈尔的移动城堡</p></li>
<li><p><strong>微风摇曳着窗帘，夕阳斜射入教室，在那里鼓起勇气告白的少年。即使现在也能清晰地回想起她的声音「当朋友，不行吗？」</strong> —— 果然我的青春恋爱喜剧搞错了</p></li>
<li><p><strong>少罗嗦，你还不如虫子呢！</strong> —— 迷糊餐厅</p></li>
<li><p><strong>别人恋爱不成功，你连暗恋都不成功！</strong> —— 灌篮高手</p></li>
<li><p><strong>就算只有六十亿分之一的机会，我们还是会邂逅。</strong> —— Angel Beats!</p></li>
<li><p><strong>魔装少女就是本少爷！</strong> —— 这是僵尸吗？</p></li>
<li><p><strong>无法飞翔的翅膀也是有意义的，因为它是曾经翱翔于天空所留下的珍贵回忆。</strong> —— AIR</p></li>
<li><p><strong>勇气，就是即便害怕也会去做。</strong> —— 原创</p></li>
<li><p><strong>如果我不会飞，那我就只是一只普通的猪。</strong> —— 红猪</p></li>
<li><p><strong>要相信同伴，拯救同伴。</strong> —— 绯弹的亚里亚</p></li>
<li><p><strong>男人许下的诺言就一定要遵守。</strong> —— 海贼王</p></li>
<li><p><strong>那是，未满45秒的邂逅。</strong> —— EF</p></li>
<li><p><strong>只要有想见面的人，自己就不再是孤单一人。</strong> —— 夏目友人帐</p></li>
<li><p><strong>如果聚集负的感情，世界就会陷入负的洪流；反之聚集正的感情，世界就会循着正道而行。</strong> —— 钢之炼金术师</p></li>
<li><p><strong>廉价的自尊、粗劣的傲气，无论哪个后生小辈都很重视这些东西。</strong> —— 狼与香辛料</p></li>
<li><p><strong>人不能一个人活下去，不需要任何人的孤独和需要人但得不到的孤独是不一样的。</strong> —— 邻座的怪同学</p></li>
<li><p><strong>一个人吃饭，太寂寞了。</strong> —— 无头骑士异闻录</p></li>
<li><p><strong>欺骗世界，欺骗最初的你。</strong> —— Steins;Gate</p></li>
<li><p><strong>(」?ω?)」うー！(／?ω?)／にゃー！</strong> —— 潜行吧奈亚子</p></li>
<li><p><strong>世界上没有偶然，有的只是必然。</strong> —— XXXHolic</p></li>
<li><p><strong>从小好女色的男人的想像力比不上狗。</strong> —— 寒蝉鸣泣之时</p></li>
<li><p><strong>你愿意陪我走到地狱的底端吗？</strong> —— 魔法禁书目录</p></li>
<li><p><strong>错的不是我， 错的是世界。</strong> —— School Day</p></li>
<li><p><strong>和哥哥的便当比起来夜空的薯片就像大便一样！只会给我大便的大便夜空是笨蛋～笨蛋～</strong> —— 我的朋友很少</p></li>
<li><p><strong>即使如此，我也有我想保护的世界！</strong> —— 高达seed</p></li>
<li><p><strong>我很好奇！</strong> —— 冰菓</p></li>
<li><p><strong>仍是那么熟悉的味道，只是用墓土和骨灰作成的身体，已经不再有体温。</strong> —— 犬夜叉</p></li>
<li><p><strong>我是要成为海贼王的男人！</strong> —— 海贼王</p></li>
<li><p><strong>做不到的话，不过就是一死 。但是，赢了就能活下去，要是不战斗就赢不了。</strong> —— 进击的巨人</p></li>
<li><p><strong>忘记本身就是一件不可能的事。</strong> —— 我们的存在</p></li>
<li><p><strong>我们的夏天仍未结束。</strong> —— 王牌投手</p></li>
<li><p><strong>雨，何时停？</strong> —— 秋之回忆</p></li>
<li><p><strong>在走廊上跌倒会流鼻血，在人生中跌倒会流眼泪。</strong> —— 龙虎斗</p></li>
<li><p><strong>有被杀的觉悟，才有资格开枪。</strong> —— 反叛的鲁路修</p></li>
<li><p><strong>已经无法回到过去了。也不知道将来会是什么模样。</strong> —— 文学少女</p></li>
<li><p><strong>不要哀求，学会争取；若是如此，终有所获。</strong> —— 交响诗篇</p></li>
<li><p><strong>リア充死ね！</strong> —— 我的朋友很少</p></li>
<li><p><strong>拿着刀并且可以让人们变得幸福的只有料理人。</strong> —— 假面骑士kabuto</p></li>
<li><p><strong>我会跟她结婚，并不是因为她是计算机，而是因为她就是她。同样的，我会喜欢你，也是因为你就是你。</strong> —— 人型电脑天使心</p></li>
<li><p><strong>越是试着忘记，越是记得深刻。</strong> —— 天空之城</p></li>
<li><p><strong>喜欢上你，爱上你，真是太好了，谢谢。</strong> —— 龙虎斗</p></li>
<li><p><strong>我对普通的人类没有兴趣，你们只要是有外星人、未来人、异世界人、超能力者， 就尽管来找我吧！以上！</strong> —— 凉宫春日的忧郁</p></li>
<li><p><strong>既然如此，就再努力一次吧。别在这里愁眉不展，也不要再自欺欺人，重新来过！</strong> —— 某科学的超电磁炮</p></li>
<li><p><strong>若隐若现才是艺术！</strong> —— 问题儿童来自异世界</p></li>
<li><p><strong>我想要握紧的并不是匕首或是什么，只不过是他的掌心而已。</strong> —— 空之境界</p></li>
<li><p><strong>下一次重逢，将是何年何月？天空必将见证。</strong> —— SOLA</p></li>
<li><p><strong>就连一直都无容身之地的我……也不是可以任意舍弃的生命。</strong> —— 夏目友人帐</p></li>
<li><p><strong>所以，他们的祭典还没结束。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>比自己，比梦想更重要的东西永远都存在着...</strong> —— 钢之炼金术师</p></li>
<li><p><strong>选择道路的时候怎么犹豫都没有关系，但决定之后就一定要坚持到底！</strong> —— 青之驱魔师</p></li>
<li><p><strong>煩い！煩い！煩い！</strong> —— 灼眼的夏娜</p></li>
<li><p><strong>重要的是无论我们选择哪条路，都要担负起选择的责任。</strong> —— 蜂蜜与四叶草</p></li>
<li><p><strong>因为无法再见面，所以要笑着说再见。</strong> —— AIR</p></li>
<li><p><strong>无论乌云有多浓厚，星星也一定还在，只是暂时看不到了而已。</strong> —— 电波女与青春男</p></li>
<li><p><strong>如果我拥有如同小狗一样的尾巴的话，肯定会高兴得遮掩不住地摇来摇去吧。</strong> —— 秒速五厘米</p></li>
<li><p><strong>在我年轻的时候，不知道什么是恐惧，可偏偏是你的温柔，让我害怕。</strong> —— 东京爱情故事</p></li>
<li><p><strong>你不会死的，因为我会保护你.</strong> —— EVA</p></li>
<li><p><strong>只是相谈就会开心起来，沉浸在温柔的眼神当中，竭尽全力的思念，悄悄地奉献。</strong> —— School Days</p></li>
<li><p><strong>我们虽然距离很远很远，非常非常的远，但是思念或许真的可以穿越时间和距离。</strong> —— 星之声</p></li>
<li><p><strong>梦想是否无聊并不是别人来决定的，不管是什么样的梦想，自己拼命努力去追寻才是最重要的。</strong> —— 守护甜心</p></li>
<li><p><strong>胜而不灭，霸而不辱，这才是真正的征服。</strong> —— fate zero</p></li>
<li><p><strong>我相信十年后的八月，我们还能再相遇。</strong> —— secret base ～君がくれたもの～</p></li>
<li><p><strong>相信十年后的八月，我们还会相遇。</strong> —— 未闻花名</p></li>
<li><p><strong>你的心可以属于耶稣，但你的屁股永远属于陆战队！</strong> —— 魔法少女陆战队</p></li>
<li><p><strong>看到的感受到的永远都不会消失永远都不会忘记，与各种各样的相遇一同永存。</strong> —— 夏目友人帐</p></li>
<li><p><strong>我们走过风走过雨，就是没能走进彼此的内心。</strong> —— 自分</p></li>
<li><p><strong>烦恼这东西，是只有活着的人，才有的特权哦。</strong> —— 我们的存在</p></li>
<li><p><strong>当朋友是不需要什么资格的。</strong> —— 全职猎人</p></li>
<li><p><strong>年华无多时，恋爱吧男子！</strong> —— 源君物语</p></li>
<li><p><strong>求你，保护那孩子，消除灾厄，抹除祸事。哪怕??那是我自己……</strong> —— 食灵</p></li>
<li><p><strong>如果你不能击败你的敌人，那么就加入他们。</strong> —— 加菲猫</p></li>
<li><p><strong>我们都在命运之湖上荡舟划桨，波浪起伏着而我们无法逃脱孤航。但是假使我们迷失了方向，波浪将指引我们穿越另一天的曙光。</strong> —— 死神</p></li>
<li><p><strong>我们所过的每个平凡的日常，也许就是连续发生的奇迹。</strong> —— 日常</p></li>
<li><p><strong>最近困扰我的是小小的分别，总会带来一丝寂寞。短暂的相遇和分别那一分一秒的时间都让我想要无比珍惜。</strong> —— 夏目友人帐</p></li>
<li><p><strong>倘若只是为了驱赶心中的寂寞，找谁都可以的。</strong> —— 秒速5厘米</p></li>
<li><p><strong>即使从梦中醒来，还会有回忆留下。</strong> —— AIR</p></li>
<li><p><strong>能够原谅女人的，才是男人。</strong> —— 海贼王</p></li>
<li><p><strong>我会继续等着你，就算是一万二千年。</strong> —— 创圣的大天使EVOL</p></li>
<li><p><strong>不管看到什么样的过去，都请不要迷失自己，不管你变成什么样子，我都是你的同伴。</strong> —— angel beats</p></li>
<li><p><strong>悲伤教会了我喜悦。</strong> —— 秋之回忆</p></li>
<li><p><strong>我到底要以怎么样的速度生活才能与你再次相遇？</strong> —— 秒速五厘米</p></li>
<li><p><strong>我的船上没有手下，只有伙伴。</strong> —— 海贼王</p></li>
<li><p><strong>就是因为抱有不现实的理想，所以才总是做出如此极端的事情！</strong> —— 逆袭的夏亚</p></li>
<li><p><strong>要是因为烦恼很痛苦，就选择了轻松的选项，将来一定会后悔。</strong> —— 樱花庄的宠物女孩</p></li>
<li><p><strong>呐，知道么，樱花飘落的速度，是每秒五厘米哦~</strong> —— 秒速五厘米</p></li>
<li><p><strong>知道活着的痛苦处的人就能对人温柔，这和软弱是不一样的。</strong> —— eva</p></li>
<li><p><strong>比起悲伤来说，无法分享快乐这件事，要更加的寂寞吧。</strong> —— AIR</p></li>
<li><p><strong>如果你执意追寻着我的幻影，总有一天会被真正的我打败。</strong> —— 棋魂</p></li>
<li><p><strong>乔巴，一个男人，有时候是不能逃避战斗的，尤其是当伙伴的梦想被人嘲笑的时候。</strong> —— 海贼王</p></li>
<li><p><strong>你的那双手呢，是为了紧紧抓住什么而存在的哦。</strong> —— 仰望半月的夜空</p></li>
<li><p><strong>去死两次！</strong> —— 迷途猫</p></li>
<li><p><strong>世界は恋に落ちている。</strong> —— 青春之旅OP（我的世界已坠入爱河）</p></li>
<li><p><strong>自身不先改变的话，一切都不会改变。</strong> —— 银魂</p></li>
<li><p><strong>就算是对我抱有敌意的人，也是被某个人深爱着而降生在这个世界上的。</strong> —— 罪恶王冠</p></li>
<li><p><strong>人生最糟糕的事，一个是饿肚子，一个是孤独。</strong> —— 夏日大作战</p></li>
<li><p><strong>我不是萝莉控，是妹控啊！</strong> —— 我的妹妹不可能那么可爱第二季</p></li>
<li><p><strong>呐，我们好像是，被宇宙和地球拆散的恋人似的。</strong> —— 星之声</p></li>
<li><p><strong>一天吐槽太多次的话，梗也是会用完的。</strong> —— 我的脑内恋爱选项</p></li>
<li><p><strong>自己的感觉，不说出来，别人也不会懂，如果不懂，就应该互相沟通。</strong> —— 好想告诉你</p></li>
<li><p><strong>心，可是很重的。</strong> —— 哈尔的移动城堡</p></li>
<li><p><strong>不能逃避，不能逃避，不能逃避，不能逃避……</strong> —— EVA</p></li>
<li><p><strong>以盐水作配菜，糖水做主食，就有种奢侈的感觉呢。</strong> —— 笨蛋测验召唤兽</p></li>
<li><p><strong>就算鼻血流尽，也不能放弃妄想。</strong> —— 摇曳百合</p></li>
<li><p><strong>爱，其实很简单，困难的是去接受它。</strong> —— 通灵王</p></li>
<li><p><strong>我们不应该根据背负的罪孽来选择道路，而应在选择的道路上背负自己的罪孽。</strong> —— 空之境界</p></li>
<li><p><strong>只要微笑就可以了。</strong> —— EVA</p></li>
<li><p><strong>因为我喜欢你，喜欢得想吃掉你啊！</strong> —— 有顶天家族</p></li>
<li><p><strong>求求你，不要对我这么温柔！</strong> —— 秒速五厘米</p></li>
<li><p><strong>我觉得你很幸福，因为你可以选择爱我或不爱我，而我只能选择爱你或更爱你。</strong> —— School Days</p></li>
<li><p><strong>失去的东西虽然拿不回来，但是，忘记的事情是可以想起来的。</strong> —— TOUCH</p></li>
<li><p><strong>你还是这么冷漠啊。不过，仅此而已的话，我是不会泄气的。</strong> —— 银魂</p></li>
<li><p><strong>我能够允许你逃避过去，不过至少从现在或者明天开始都不要再逃避。</strong> —— 无头骑士异闻录</p></li>
<li><p><strong>正因为听不见和看不到，所以风子才会做这样的事情。</strong> —— clannad</p></li>
<li><p><strong>什么都无所谓只想在你身边，什么都无所谓只想和你说话，什么都无所谓所以请你不要逃避。</strong> —— 好想告诉你</p></li>
<li><p><strong>我并不羡慕别人的人生，这就是所谓幸福。</strong> —— 幸运星</p></li>
<li><p><strong>人能够在心里郁积那么多的事情，而他们又会忘记那么多的事情，真是不可思议……</strong> —— 最终幻想</p></li>
<li><p><strong>我要拼，装上假牙也要拼！</strong> —— 灌篮高手</p></li>
<li><p><strong>人一生会遇到约2920万人，两个人相爱的概率是0.000049。所以你不爱我，我不怪你。</strong> —— 秒速五厘米</p></li>
<li><p><strong>我的内心就和厕纸一样单纯！</strong> —— Little Busters!</p></li>
<li><p><strong>我的眼睛，就是为了寻找你而存在的。</strong> —— H2O</p></li>
<li><p><strong>烈焰中舞动的火花，将赐予邪恶异性交往以天罚。</strong> —— 潜行吧！奈亚子W</p></li>
<li><p><strong>All for one，one for all.</strong> —— 海贼王</p></li>
<li><p><strong>老是低着头，幸福可是会离你而去的喔。</strong> —— 我们的仙境</p></li>
<li><p><strong>羁绊是那不可切断的深切联系。即使分离，心与心也紧紧的连在一起。</strong> —— 假面骑士kabuto</p></li>
<li><p><strong>对不起，风太大，我没有听清楚……</strong> —— 东京巴比伦</p></li>
<li><p><strong>你知道雪为什么是白色的吗？因为她忘记了本来的颜色。</strong> —— 反叛的鲁路修</p></li>
<li><p><strong>人生在世何其痛苦，所以咖啡至少该甜一点。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>我想让自己强大起来，因为至少我已经有幸和想要保护的人相遇了。</strong> —— 夏目友人帐</p></li>
<li><p><strong>我只是做了我能做的事，没有时间想将来。</strong> —— 秒速五厘米</p></li>
<li><p><strong>一天最大任务莫过于，好好睡觉，好好醒来。</strong> —— 火影忍者</p></li>
<li><p><strong>不相信人咬不到肚脐的，咬破肚脐去死如何？</strong> —— 海猫鸣泣之时</p></li>
<li><p><strong>一直保持微笑是有诀窍的，那就是，在想哭的时候放声大哭。</strong> —— 天使领域</p></li>
<li><p><strong>女人的武器不是眼泪，而是微笑。</strong> —— 凉宫春日的忧郁</p></li>
<li><p><strong>十步做一死，千里不留行，事了拂衣去，深藏功与名~</strong> —— 侠客行</p></li>
<li><p><strong>只要有你，我便无所不能。</strong> —— 进击的巨人</p></li>
<li><p><strong>不相信自己的人，连努力的价值都没有。</strong> —— 火影忍者</p></li>
<li><p><strong>我只对现实世界绝望过，却未对自己绝望过！</strong> —— 只有神知道的世界</p></li>
<li><p><strong>虚伪的眼泪，会伤害别人，虚伪的笑容，会伤害自己。</strong> —— 反叛的鲁鲁修</p></li>
<li><p><strong>我除了投三分，就什么都没有了……</strong> —— 灌篮高手</p></li>
<li><p>**(?_?)** —— 进击的巨人</p></li>
<li><p><strong>我在人生的道路上迷失了。</strong> —— 火影忍者</p></li>
<li><p><strong>历史虽然会一再重演，但人类却无法回到过去。</strong> —— 海贼王</p></li>
<li><p><strong>观察铅笔和橡皮，哪个是攻哪个是受，请写出它们晚上的对话。</strong> —— 学生会的一己之见</p></li>
<li><p><strong>龙儿是我的，谁都不准碰！</strong> —— 龙虎斗</p></li>
<li><p><strong>贫乳是社会地位的象征。是具有稀有价值的！</strong> —— 幸运星</p></li>
<li><p><strong>想要试着去相互接近，但最后还是无法敞开心扉，结果就是擦肩而过……</strong> —— 文学少女</p></li>
<li><p><strong>扎古不论怎么化妆都不可能变成高达的。</strong> —— 银魂</p></li>
<li><p><strong>我在未来等你。</strong> —— 穿越时空的少女</p></li>
<li><p><strong>一般来说，时间会把悲伤冲淡，可是在人的生命中，会有那么一两个特殊的存在，他们的逝去，你永远也不会习惯。</strong> —— 冥王神话</p></li>
<li><p><strong>懂得认输是非常重要的，不尝到失败的不甘，也就不会明白跌倒后怎么爬起来，更不可能再向前迈进。</strong> —— 笨蛋测验召唤兽</p></li>
<li><p><strong>要改变别人的心真是件很难办的事，不过改变自己要容易一点。</strong> —— XXXHolic</p></li>
<li><p><strong>我喜欢你们！超喜欢的！大家和我交往吧！绝对会让你们幸福的！</strong> —— 学生会的一己之见</p></li>
<li><p><strong>美丽的不是这个世界，而是看世界的你的眼神。</strong> —— 吸血鬼骑士</p></li>
<li><p><strong>世界这么大，人生这么长，总会有那么一个人，让你想要温柔的对待。</strong> —— 哈尔的移动城堡</p></li>
<li><p><strong>成功率不到2%，那剩下的用勇气来补足吧！</strong> —— 勇者王</p></li>
<li><p><strong>我一直都在你身边 ，一直都在。</strong> —— CLANNAD</p></li>
<li><p><strong>重要的不是你做了多少事，而是你放了多少心思进去。</strong> —— 凉宫春日的忧郁</p></li>
<li><p><strong>哭泣并不能改变任何事情。</strong> —— 推理之绊</p></li>
<li><p><strong>代表月亮消灭你！</strong> —— 美少女战士</p></li>
<li><p><strong>不要，我现在暂时留在他身边，直到那转瞬即逝的日子到来。</strong> —— 夏目友人帐</p></li>
<li><p><strong>就算是自私……我也希望那些人能够永远都有笑容……</strong> —— 夏目友人帐</p></li>
<li><p><strong>我们开始一起攀登，这长长的，长长的坡道。</strong> —— Clannad</p></li>
<li><p><strong>应该可以了吧，我已经很努力了，应该可以抵达终点了……</strong> —— AIR</p></li>
<li><p><strong>离别并不痛苦，因为我们都微笑着。</strong> —— 青之驱魔师</p></li>
<li><p><strong>只要能努力，就应当去努力；只要还能前进，就要向前走去。</strong> —— CLANNAD</p></li>
<li><p><strong>邂逅本身，就是一种奇迹啊。</strong> —— 游魂</p></li>
<li><p><strong>与其被自己的本性牵着走而痛苦，倒不如试着改变自己。</strong> —— 银魂</p></li>
<li><p><strong>爱迪生说过：“要把BOSS打倒就要准备足够的等级。”</strong> —— 学生会的一己之见</p></li>
<li><p><strong>世界并不完美，却因此而美丽。</strong> —— 奇诺之旅</p></li>
<li><p><strong>我们的心就像那天空一样，永不分离。</strong> —— 缘之空</p></li>
<li><p><strong>和我定下契约，成为魔法少女吧！</strong> —— 魔法少女小圆</p></li>
<li><p><strong>一直注视着你，似近似远，总是触碰不到。</strong> —— 来自风平浪静的明天</p></li>
<li><p><strong>我知道的，面码……自己已经死掉这点事，还是知道的……</strong> —— 我们仍未知道那天所看见的花的名字</p></li>
<li><p><strong>共道人间惆怅事，不知今夕是何年。</strong> —— 周秦行纪</p></li>
<li><p><strong>旅行唯有出发前最愉快，狗儿唯有叫声最吓人，女人唯有背影最美丽。</strong> —— 狼与香辛料</p></li>
<li><p><strong>无论你在哪里，就算我看不见你，我也会一直注视着你。</strong> —— 妖精的尾巴</p></li>
<li><p><strong>我不渴望什么在别的城市迎来的春天，只要和你在一起的春天就好，只要和你在一起就好</strong> —— CLANNAD</p></li>
<li><p><strong>我的愿望是—幸福地活着，幸福地死去。</strong> —— 神不在的星期天</p></li>
<li><p><strong>今天你最后遇见的那个人有在微笑吗？</strong> —— 幸运星</p></li>
<li><p><strong>我的终点，与幸福同在。</strong> —— AIR</p></li>
<li><p><strong>隐约雷鸣，阴霾天空，但盼风雨来，能留你在此。</strong> —— 言叶之庭</p></li>
<li><p><strong>我问你：你是我的Master吗？</strong> —— 命运守护夜</p></li>
<li><p><strong>私だって今日こそ... 遠野くんに告白するんだ。</strong> —— 秒速五厘米</p></li>
<li><p><strong>时间并不存在，存在的只有此刻。</strong> —— 魔女猎人</p></li>
<li><p><strong>没有期盼就不会出现奇迹。</strong> —— 古城荆棘王</p></li>
<li><p><strong>受尽苦难而不厌，此乃阿修罗之道。</strong> —— 海贼王</p></li>
<li><p><strong>如果你都不知道自己想去哪里，那去哪里都是一样的。</strong> —— 柴郡猫</p></li>
<li><p><strong>明天，不是你想要就能有的。</strong> —— 未闻花名</p></li>
<li><p><strong>明明只是活着，哀伤却无处不在……</strong> —— 秒速五厘米</p></li>
<li><p><strong>错误可不是为了别人才改的过来的，要为了自己才能改正。</strong> —— XXXHolic</p></li>
<li><p><strong>男人从小的时候就是无药可救的。</strong> —— 秋之回忆</p></li>
<li><p><strong>如果我是那雨滴的话，那么，我能够像把不曾交汇的天空与大地连接起来那样，把某人的心串联起来吗？</strong> —— 死神</p></li>
<li><p><strong>真可悲，你什么都不知道，在这个世界上没有什么是不重要的！</strong> —— 最终幻想</p></li>
<li><p><strong>前天是小兔子，昨天是小鹿，今天是你。</strong> —— CLANNAD</p></li>
<li><p><strong>用我的左手将你那个不可理喻的幻想粉碎掉！</strong> —— 魔法禁书目录</p></li>
<li><p><strong>堕入黑暗裏的可怜影子啊，停止伤害他人的行为吧，犯下罪行的灵魂……想死一次么？</strong> —— 地狱少女</p></li>
<li><p><strong>男人变态有什么错！</strong> —— 寒蝉鸣泣之时</p></li>
<li><p><strong>人们只是用好人来称呼对自己有用的人而以，不存在对所有人都有用的人。</strong> —— 进击的巨人</p></li>
<li><p><strong>真正的危机不是机器人像人一样思考，而是人像机器一样思考。</strong> —— 凉宫春日的忧郁</p></li>
<li><p><strong>人は一生、中二病なんだ。</strong> —— 中二病也要谈恋爱</p></li>
<li><p><strong>能够轻易就放弃的梦想，有存在的价值么？</strong> —— 守护甜心</p></li>
<li><p><strong>没有谁能够永远坚强下去的，每个人都会有疲累的无法站起的时候。世间的故事，就是为了这一刻而存在的哦。</strong> —— 文学少女</p></li>
<li><p><strong>只要你在，我便无所不能。</strong> —— 进击的巨人</p></li>
<li><p><strong>24岁的阿升你好，我是15岁的美加子，我现在也还是非常、非常的喜欢阿升哦！</strong> —— 星之声</p></li>
<li><p><strong>比希望更炙热，比绝望更深邃，这就是爱啊。</strong> —— 魔法少女小圆-叛逆的物语</p></li>
<li><p><strong>如果你愿意的话，让我带您去吧，这座小镇，愿望实现的地方……</strong> —— CLANNAD</p></li>
<li><p><strong>窃人者，自失其宝。</strong> —— 假面骑士kabuto</p></li>
<li><p><strong>有你在的日子才是我的日常。</strong> —— 琴浦小姐</p></li>
<li><p><strong>男人就应该保持冷静，沸腾的水只会被蒸发掉。</strong> —— 假面骑士kabuto</p></li>
<li><p><strong>嗯，一个人也要加油，我是坚强的孩子。</strong> —— AIR</p></li>
<li><p><strong>时间带着明显的恶意，缓缓在我的头顶流逝。</strong> —— 秒速五厘米</p></li>
<li><p><strong>人的记忆本来就是暧昧的，不值得信任。</strong> —— 叛逆的鲁鲁修R2</p></li>
<li><p><strong>有光的地方必有影，有影的地方也必定有光，绝望的颜色越是浓重，一定会有光芒耀眼的希望。</strong> —— 银魂</p></li>
<li><p><strong>时间可以治愈？如果时间也病了怎么办？</strong> —— 寒蝉鸣泣之时</p></li>
<li><p><strong>无论在哪里遇到你，我都会喜欢上你。</strong> —— AngleBeats!</p></li>
<li><p><strong>取少量学生放入试管，加入过量作业，生成学霸溶液和不溶于水的学渣。过滤，在学渣中加入过量浓试卷，学渣迅速溶解且产生气泡，学霸则无明显现象。</strong> —— 网络</p></li>
<li><p><strong>如果你死了，那什么也改变不了，可如果你还活着，那就能改变一些事情。</strong> —— 最游记</p></li>
<li><p><strong>鲁鲁修，你知道雪花为什么是白色的吗？因为已经忘记自己本来是什么颜色啊。</strong> —— 叛逆的鲁鲁修</p></li>
<li><p><strong>燃烧吧，我的小宇宙！</strong> —— 圣斗士星矢</p></li>
<li><p><strong>无法逃避的是自我，而无法挽回的是过去。</strong> —— 机动战士高达</p></li>
<li><p><strong>做出一副温柔的样子来折磨人不是更令人难受吗？</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>有些事情我不看透，不是我笨，只是我太善良。</strong> —— 樱桃小丸子</p></li>
<li><p><strong>有时语言就像把利刃，使用不当，就会成为凶器。</strong> —— 名侦探柯南</p></li>
<li><p><strong>如果能够重生的话，我想，我想成为水母。想成为只是在海里自由地摇摇摆摆的水母。</strong> —— 海月姬</p></li>
<li><p><strong>所谓的人类，可是连短短的十分钟也等不起的。</strong> —— Angel Beats!</p></li>
<li><p><strong>梦总是有会醒来的时候，不会醒的梦总有一天会变成悲伤。</strong> —— AIR</p></li>
<li><p><strong>能哭的地方只有厕所和爸爸的怀里。</strong> —— CLANNAD</p></li>
<li><p><strong>你再怎么称赞我，我也不会高兴的，你这个混蛋~</strong> —— 海贼王</p></li>
<li><p><strong>除了爱你，我什么都可以。</strong> —— 命运守护夜</p></li>
<li><p><strong>败者死于绝望，胜者死于渴望。</strong> —— 戏言系列</p></li>
<li><p><strong>给，一辈子朋友劵。</strong> —— 日常</p></li>
<li><p><strong>一个人走在路上，形单影只。回首望去，大家都留在远方。回过头来继续前行，这便是所谓坚强。</strong> —— AngelBeats</p></li>
<li><p><strong>无知而又纯洁的岁月是任何人都曾拥有的，世界上没有一成不变的事物，所以只要以其他方式找到自己的快乐就行了。</strong> —— CLANNAD</p></li>
<li><p><strong>沒有永远下不停的雨。</strong> —— 秋之回憶</p></li>
<li><p><strong>不习惯的事越来越多，但我仍在前进……就算步伐很小，我也在一步一步的前进。</strong> —— 夏目友人帐</p></li>
<li><p><strong>算了，和你说话感觉就像是大姨妈来了。</strong> —— 龙虎斗</p></li>
<li><p><strong>“像你这样的白痴是怎么活过来的？”“因为我很自信。</strong> —— 海贼王</p></li>
<li><p><strong>梦想是什么，梦想是现实的延续；现实是什么，现实是梦想的终结。</strong> —— EVA</p></li>
<li><p><strong>Time waits for no one.</strong> —— 穿越时空的少女</p></li>
<li><p><strong>时间是伟大的作家，总会写下完美的结局。</strong> —— 秋之回忆</p></li>
<li><p><strong>真正让我难受的，大概是因为让你看到如此狼狈的自己。</strong> —— 元气少女缘结神</p></li>
<li><p><strong>淅淅沥沥的雨，即便能填满路上的水坑，也填不满心中的空洞。</strong> —— 神圣之门</p></li>
<li><p><strong>我们总是在注意错过太多，却不注意自己拥有多少。</strong> —— 我们仍未知道那天所看见的花的名字</p></li>
<li><p><strong>不管前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福。</strong> —— 千与千寻</p></li>
<li><p><strong>活在现实中的人是错的，而那些哭泣的人才是正确的，孤独的我们才有人类的样子</strong> —— angel beats</p></li>
<li><p><strong>不管是怎样的回忆，都是我们活过的人生。</strong> —— angel beats</p></li>
<li><p><strong>我不知道离别的滋味是这样凄凉，我不知道说声再见要这么坚强。</strong> —— 千与千寻</p></li>
<li><p><strong>人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。</strong> —— 千与千寻</p></li>
<li><p><strong>曾经发生过的事情不可能忘记，只不过是想不起而已。</strong> —— 千与千寻</p></li>
<li><p><strong>人永远不知道，谁哪次不经意的跟你说了再见之后，就真的不会再见了。</strong> —— 千与千寻</p></li>
<li><p><strong>有阳光的地方就会有阴影，所以有阴影的地方也一定会有阳光。绝望的颜色越是浓厚，在哪里也一定会存在耀眼的希望之光。</strong> —— 银魂</p></li>
<li><p><strong>与其想着怎么美丽地牺牲,倒不如想着怎么漂亮地活到最后一刻。</strong> —— 银魂</p></li>
<li><p><strong>人就是要以自卑为跳板才能跳得更高。</strong> —— 银魂</p></li>
<li><p><strong>为了终止绝望的连锁，希望她能化为照亮正确道路的灯火。</strong> —— Re：从零开始的异世界生活</p></li>
<li><p><strong>死亡只要在人生的终点尝试一次就够了~</strong> —— Re：从零开始的异世界生活</p></li>
<li><p><strong>真正重要的东西，总是没有的人比拥有的人清楚。</strong> —— 银魂</p></li>
<li><p><strong>吾于冥河沉浮,受尽命运捉弄，纵然汝将忘吾，吾亦伴汝身旁。</strong> —— Re：从零开始的异世界生活</p></li>
<li><p><strong>关于自己的生活，我和你都不是读者，而是作者。至少结局，还是能自己说了算的。</strong> —— 银魂</p></li>
<li><p><strong>努力可是要默默藏起来的。</strong> —— Re：从零开始的异世界生活</p></li>
<li><p><strong>拥有和舍弃都很痛苦，既然无论怎样都会痛苦的话，我宁可选择守护它而痛苦。</strong> —— 银魂</p></li>
<li><p><strong>只要有你想要保护的东西，那就拔剑好了。</strong> —— 银魂</p></li>
<li><p><strong>所谓的王，乃最贪婪，最豪爽，最易怒之人。且清且浊，追求极致人生。为臣者，因之而仰慕，追随其左右。因此，臣民才会有称王之志，追寻自己的理想。</strong> —— fate/zero</p></li>
<li><p><strong>不过傲慢分为两种。一种是能力过于低下，还有一种是志向异常远大的。前者显得非常愚蠢，后者是难得一见的珍贵种类。</strong> —— fate/zero</p></li>
<li><p><strong>梦存高远，志在争霸，这股热情确实值得赞许。但所谓梦，终有一天是要醒来的。</strong> —— fate/zero</p></li>
<li><p><strong>“把剑放下，成为本王的妻子吧。”</strong> —— fate/zero</p></li>
<li><p><strong>区区一只趴在地上的蝼蚁，谁允许你抬起头的， 虫子就要有虫子的样子，低头伏地然后去死。</strong> —— fate/zero</p></li>
<li><p><strong>即使你忘记了我，我也不会遗忘你。</strong> —— Re：从零开始的异世界生活</p></li>
<li><p><strong>不是别人，是我，承认了你的价值。</strong> —— fate/zero</p></li>
<li><p><strong>世界上 ，没有一拳解决不了的事，如果有，那就两拳。</strong> —— 一拳超人</p></li>
<li><p><strong>明天的事，交给明天的我。</strong> —— 一拳超人</p></li>
<li><p><strong>在灾难面前，如果连英雄都逃跑了，那还有谁能站出来？</strong> —— 一拳超人</p></li>
<li><p><strong>我不是因为需要你们评论几句才去当英雄的，而是因为我想去当所以我才当的。</strong> —— 一拳超人</p></li>
<li><p><strong>由变态化身成为变态，也就是真·变态，也就是说，完全变态呢。</strong> —— 一拳超人</p></li>
<li><p><strong>我秃了，我也变强了</strong> —— 一拳超人</p></li>
<li><p><strong>为了做一名真正的绅士，即使明知必输无疑，也要有勇气接受挑战！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>JOJO，我不想再做人了！！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>春天是胖次的季节。</strong> —— 电器街漫画店</p></li>
<li><p><strong>我只是个兴趣使然的英雄。</strong> —— 一拳超人</p></li>
<li><p><strong>不要为自己的努力道歉，这样太对不起自己了！</strong> —— 火影忍者</p></li>
<li><p><strong>这个世界上没有奇迹，有的只是偶然和必然，以及是谁在做些什么。一直期望着能出现奇迹的人们是不会发生奇迹</strong> —— 悠久之翼</p></li>
<li><p><strong>伤害别人的人，就要有被伤害的觉悟！</strong> —— 罪恶王冠</p></li>
<li><p><strong>即使你忘记我，我也不会遗忘你！</strong> —— 从零开始的异世界生活</p></li>
<li><p><strong>我不管这个世上的人怎么说我，我只想依照我的信念做事，绝不后悔，不管现在将来都一样。</strong> —— 火影忍者</p></li>
<li><p><strong>人生中有些事你不竭尽所能去做，你永远不知道自己有多出色！</strong> —— 海贼王</p></li>
<li><p><strong>正因为生命有限，所以才显得重要，正因为生命有限，所以才更应该努力不懈！</strong> —— 名侦探柯南</p></li>
<li><p><strong>人，只有在放弃战斗的时候才算输，只要坚持战斗，就还没输！</strong> —— 进击的巨人</p></li>
<li><p><strong>世间本就没有真实的对与错，也没有绝对的善与恶。地狱天堂，一念之间。</strong> —— 地狱少女</p></li>
<li><p><strong>天才的字典里，没有不可能这三个字。</strong> —— 灌篮高手</p></li>
<li><p><strong>奇迹不是免费的，如果你祈求了希望，也会散播出同等的绝望。</strong> —— 魔法少女小圆</p></li>
<li><p><strong>此生无悔入东方，来世愿生幻想乡！</strong> —— 东方project</p></li>
<li><p><strong>只要是活着的东西，就算是神我也会杀给你看。</strong> —— 空之境界</p></li>
<li><p><strong>我手里拿着刀，没法抱你，我放下刀，没法保护你！</strong> —— 死神</p></li>
<li><p><strong>不好意思，我喜欢的是艾米莉亚</strong> —— Re：从零开始的异世界生活</p></li>
<li><p><strong>前进吧，星星在你的头上闪耀哦！</strong> —— 四月是你的谎言</p></li>
<li><p><strong>星星只有在夜里才璀璨夺目啊。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>Eloim Essaim Eloim Essaim 请聆听我的请求。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>於此漆黑世界之中，直至光明遍地之时！All Hail Lelouch！</strong> —— 反叛的鲁路修</p></li>
<li><p><strong>只有用心才能看到本质，最重要的东西眼睛是无法看到的。</strong> —— LE</p></li>
<li><p><strong>春天的最后一场雪，你我的最后一次相聚，能遇见你是最幸福的事了，就此分别吧！请继续向前，迎接樱花漫溢的四月，但请不要忘记我，友人A……</strong> —— 四月是你的谎言</p></li>
<li><p><strong>喜欢的人喜欢别人不是很正常吗。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>男人只要去行动就好，做得到或做不到，女孩子会来告诉你的。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>英雄意味着强大，英雄意味着孤独，最后一幕一定是英雄渐行渐远，我的英雄也是那样的存在。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>迎接我们的也许是漆黑一片的夜路，即便如此，也要相信自己，勇往直前。 星空会为我们在这条道路上点缀出淡淡星光。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>君の名を 今追いかけるよ</strong> —— 君の名は。</p></li>
<li><p><strong>谢谢你至今为止都容忍我的任性，我是你的妹妹真的太好了。</strong> —— 俺妹</p></li>
<li><p><strong>那东西既然被你知道了，我就没脸活下去了，只有一死了之了！可是我还不想死，所以只好把你杀了啊！</strong> —— 逢坂大河</p></li>
<li><p><strong>笨蛋吉娃娃（バカチワワ）</strong> —— 逢坂大河</p></li>
<li><p><strong>吵死了吵死了!</strong> —— 逢坂大河</p></li>
<li><p><strong>回家后我得好好找你人生咨询一下！</strong> —— 高坂桐乃</p></li>
<li><p><strong>Angel大河大人，为了大家能有一个幸福快乐的圣诞，无论是一层皮还是两层皮都给你剥下来，直到最后全裸都没问题的觉悟都做好了！</strong> —— 逢坂大河</p></li>
<li><p><strong>告白当天就要H什么的，真是没办法的男人呢。</strong> —— 高坂桐乃</p></li>
<li><p><strong>桐乃非常非常不愿意你有女朋友，但是你还愿意和我复合吗。开...开玩笑的，你不要回答我不然我真的会死"</strong> —— 五更琉璃</p></li>
<li><p><strong>“我要诅咒！诅咒所有相爱的情侣！诅咒神圣的夜晚！诅咒这整个世界（世界：怪我咯？）！对所有的现充挥下破坏的铁锤！我会让你尝尝……我生涯最大的诅咒！”</strong> —— 千叶の堕天圣黑猫</p></li>
<li><p><strong>喂？FFF团团长须川亮吗？这有一个要入团的！</strong> —— 五更琉璃</p></li>
<li><p><strong>最有名的莫过于想死一次吗。</strong> —— 阎魔爱</p></li>
<li><p><strong>哥哥也可以喜欢上我之外的女孩子，但只有音梦是不可以的！</strong> —— 芳乃樱对朝仓纯</p></li>
<li><p><strong>我也做个好孩子，成为这幸福光景的一部分，想成为闪耀在圣诞节的城市里，其中一张幸福的笑脸。</strong> —— 逢坂大河</p></li>
<li><p><strong>龙儿是我的！谁都不准碰！</strong> —— 逢坂大河</p></li>
<li><p><strong>以后继续来一起练习打篮球</strong> —— 湊智花</p></li>
<li><p><strong>请不要跟我搭话。我讨厌你！</strong> —— 八九寺真宵</p></li>
<li><p><strong>风子参上！</strong> —— 伊吹风子</p></li>
<li><p><strong>男生送的礼物要方便拿来换钱才好吧！</strong> —— 来栖加奈子</p></li>
<li><p><strong>你是笨蛋吗？</strong> —— 小桐桐（きりりん）</p></li>
<li><p><strong>我跟喜欢成人游戏一样喜欢你</strong> —— 高坂桐乃</p></li>
<li><p><strong>最喜欢你了唷！！ 开玩笑的！！啊--！好害羞 有机会的话会再写信给你。 希望那时，能变得更加坦率捏~</strong> —— 久保由利香致小泉花阳</p></li>
<li><p><strong>最后，士郎……你要去打的話……必须給我贏！你要是死了话……我饶不了你……</strong> —— 遠坂凜</p></li>
<li><p><strong>最后好想有个拥抱....，可是...那种事情怎么能说得出口.....</strong> —— 露西</p></li>
<li><p><strong>受虐狂的娇小美少年……真想带回家去养一段时间啊。</strong> —— 赤井林檎</p></li>
<li><p><strong>希望老师像帮我一样帮帮れいジ</strong> —— 九重凛</p></li>
<li><p><strong>在排练的休息时间里要好好补充水分和盐分哦！</strong> —— 三森铃子致海未</p></li>
<li><p><strong>得到更多人的认可，带著大家的爱意加油哦！</strong> —— 内田彩致南小鸟</p></li>
<li><p><strong>重新再说一次，至今为止，真的谢谢你。 然后，今后也请多指教了。</strong> —— 楠田亞衣奈致东条希</p></li>
<li><p><strong>笨蛋、笨蛋！</strong> —— 星野琉璃</p></li>
<li><p><strong>没问题，绝对没问题</strong> —— 木之本樱（无敌咒语）</p></li>
<li><p><strong>凡人、笨蛋！</strong> —— 维多利加·德·布洛瓦</p></li>
<li><p><strong>笨蛋,蠢货</strong> —— 南千秋</p></li>
<li><p><strong>我绝对会成为火影。我从来都是有话直说，这就是我的忍道！</strong> —— 漩涡鸣人</p></li>
<li><p><strong>Fightだよじゃねつの！</strong> —— 高坂穗乃果</p></li>
<li><p><strong>哦~</strong> —— 袴田日向</p></li>
<li><p><strong>绝对要一起去吃拉面喵~</strong> —— 星空凛</p></li>
<li><p><strong>不管你在世界的哪个地方，我一定会，再次去见你的。</strong> —— 你的名字</p></li>
<li><p><strong>描线一笔接一笔，白色的素描本上渐渐萌生黑意。即便如此，还无法照准记忆中的风景。</strong> —— 你的名字</p></li>
<li><p><strong>你会哭着笑，笑着哭，是因为你的心，早已超越了自己啊。</strong> —— 你的名字</p></li>
<li><p><strong>醒来的时候 不知道自己为什么哭 时常会有的事情 做过的梦总是回想不起 只是 一种有什么消失的丧失感</strong> —— 你的名字</p></li>
<li><p><strong>以彗星为龙，以彗星为绳结。描绘出割裂的彗星舞动的形态。又是一轮岁月。</strong> —— 你的名字</p></li>
<li><p><strong>聚拢，成形，捻转，回绕，时而返回，暂歇，再联结。这就是组纽。这就是时间。这就是，联结</strong> —— 你的名字</p></li>
<li><p><strong>从你的前前前世开始，我就开始找寻你</strong> —— 你的名字</p></li>
<li><p><strong>假如我们相遇，肯定一眼就能认出彼此</strong> —— 你的名字</p></li>
<li><p><strong>从现在开始，我将追寻你的名字。</strong> —— 你的名字</p></li>
<li><p><strong>我，将某个人，唯一的某个人，试图锁定。我，</strong> —— 你的名字</p></li>
<li><p><strong>散落至四方。又或是升起至四方。在无法确认这一事实的浮游感中，彗星耀辉在夜空。彗星裂开，碎片落下。</strong> —— 你的名字</p></li>
<li><p><strong>喜欢喜欢轻飘飘喜欢喜欢轻飘飘让我们一起来！</strong> —— Printemps</p></li>
<li><p><strong>みんなで作る、最高のライブ！</strong> —— LoveLive! The School idol Movie</p></li>
<li><p><strong>凛：450拿来 海：自由女神Shoot！ 希：其实有点像邪神果</strong> —— 乙姬心恋宫殿</p></li>
<li><p><strong>脱！！巨乳！</strong> —— 暗杀教室</p></li>
<li><p><strong>前天是小兔子,昨天是小鹿,今天是你</strong> —— CLANNAD</p></li>
<li><p><strong>有些事情我不看透，不是我太笨，只是我太善良。</strong> —— 樱桃小丸子</p></li>
<li><p><strong>彼方为谁，无我有问 ；九月露湿，待君之前</strong> —— 你的名字</p></li>
<li><p><strong>会起反作用是吧……明明是想保护，却伤害了；明明想要哭泣， 却微笑着。</strong> —— 吸血鬼骑士</p></li>
<li><p><strong>我不是天生的王者 但我骨子里流动着不让我低头的血液</strong> —— 海贼王</p></li>
<li><p><strong>不要停止奔跑，不要回顾来路，来路无可眷恋，值得期待的只有前方。</strong> —— 马男波杰克</p></li>
<li><p><strong>苹果是给那些为了爱选择死亡的人的奖励</strong> —— 回转企鹅罐</p></li>
<li><p><strong>一定要保护自己的梦想，即使牺牲一切。</strong> —— NANA</p></li>
<li><p><strong>喜欢你，因为我喜欢你，比地球上任何人都，喜欢你...</strong> —— 名侦探柯南</p></li>
<li><p><strong>所谓“大家”，就是无视并牺牲了一部分弱势群体后所达到的虚伪的和平与共识。</strong> —— 果然我的青春恋爱喜剧搞错了</p></li>
<li><p><strong>男人至死都是少年</strong> —— 银魂</p></li>
<li><p><strong>润滑油是用来防止磨损的东西。在心中有着润滑油也会活得更加轻松吧。</strong> —— 果然我的青春恋爱喜剧搞错了</p></li>
<li><p><strong>不能逃避，不能逃避，不能逃避，不能逃避…</strong> —— EVA</p></li>
<li><p><strong>我除了投三分，就什么都没有了…</strong> —— 灌篮高手</p></li>
<li><p><strong>我会死在这里，我的每一寸肌肤都会腐烂，除了…一寸，这一寸，它是那么的小，那么的脆弱，却是这世上唯一值得拥有的东西，我们决不能失去或者放弃它，我们决不能让别人把它夺走。</strong> —— 碧之轨迹</p></li>
<li><p><strong>无论是丢下还是被丢下，这两者都是一样痛苦的。</strong> —— 水果篮子</p></li>
<li><p><strong>女生口中的「好人」首先百分之百是「怎样都好的人」的意思，再好也不过止于「方便好使的人」。也就是说，不管怎样都是没戏了。</strong> —— 果然我的青春恋爱喜剧搞错了</p></li>
<li><p><strong>今天的风儿有些喧嚣啊。</strong> —— 男子高中生的日常</p></li>
<li><p><strong>死对任何人都是残酷的，年轻年老、好人坏人都一样。死是平等的，没哪种死亡是特别残酷的，所以死才可怕。品行、年龄、个性、金钱、美貌，这些东西只在生前才有意义。就因能将一切化为乌有，所以怎样的死都是残酷的。</strong> —— 尸鬼</p></li>
<li><p><strong>命运的红线一旦断了，就再也不会接上。</strong> —— 犬夜叉</p></li>
<li><p><strong>活下去的意志是最强的力量！</strong> —— 浪客剑心</p></li>
<li><p><strong>想要试着去相互接近，但最后还是无法敞开心扉，结果就是擦肩而过…</strong> —— 文学少女</p></li>
<li><p><strong>男人的爱情是另存为，女人的爱情是覆盖。</strong> —— 红</p></li>
<li><p><strong>不逆 不耻 不憾</strong> —— 舰队Collection</p></li>
<li><p><strong>有话直说就是我的忍道！</strong> —— 火影忍者</p></li>
<li><p><strong>就连一直都无容身之地的我…也不是可以任意舍弃的生命。</strong> —— 夏目友人帐</p></li>
<li><p><strong>明明只是活着，哀伤却无处不在…</strong> —— 秒速五厘米</p></li>
<li><p><strong>为了你,如果是为了你,即使我被困在永远的迷宫中,也没关系.</strong> —— 魔法少女小圆</p></li>
<li><p><strong>我不渴望什么在别的城市迎来的春天，只要和你在一起的春天就好，只要和你在一起就好…</strong> —— CLANNAD</p></li>
<li><p><strong>“像你这样的白痴是怎么活过来的？”“因为我很自信。“</strong> —— 海贼王</p></li>
<li><p><strong>汝真是个烂好人</strong> —— 狼与香辛料</p></li>
<li><p><strong>我知道的，面码…自己已经死掉这点事，还是知道的…</strong> —— 我们仍未知道那天所看见的花的名字</p></li>
<li><p><strong>不习惯的事越来越多，但我仍在前进…就算步伐很小，我也在一步一步的前进。</strong> —— 夏目友人帐</p></li>
<li><p><strong>刻意保持距离的人是你，虚拟世界里的区区两公尺，对你来说就真的如此遥不可及?</strong> —— 加速世界</p></li>
<li><p><strong>想哭的时候能哭出来，也是一种坚强</strong> —— 翼年代记</p></li>
<li><p><strong>如果你愿意的话，让我带您去吧，这座小镇，愿望实现的地方…</strong> —— CLANNAD</p></li>
<li><p><strong>有伤害人的人存在的话，也会有能抚慰伤痕的人</strong> —— 水果篮子</p></li>
<li><p><strong>会长和往常一样挺着小小的胸部一副自以为了不起的样子套用某本书的内容说道…</strong> —— 学生会的一己之见</p></li>
<li><p><strong>我觉得只要这样继续加油，总有一天能赶上他们的。</strong> —— 刀剑神域</p></li>
<li><p><strong>如果你是魔女，我只要化身魔王就可以了。</strong> —— 反叛的鲁鲁修</p></li>
<li><p><strong>人的一生会遭遇各种各样的事，其中有令人难以置信的事，也有不讲道理的事，但这就是生活。</strong> —— 地狱少女</p></li>
<li><p><strong>挡着在我们面前的是巨大庞然的人生，阻隔在我们中间的是广阔无际的时间，对于他们，我们无能为力…</strong> —— 秒速五厘米</p></li>
<li><p><strong>叶え！私たちの夢ー。</strong> —— ラブライブ！</p></li>
<li><p><strong>人不会对讨厌人要求理由。莫名的生气、莫名的讨厌、莫名的恶心、什么都能成为讨厌人的理由。</strong> —— 果然我的青春恋爱喜剧搞错了</p></li>
<li><p><strong>无论发生什么都不要停下。无论到什么时候都要继续前进。 要一直走下去，直到生命终止的那一刻。</strong> —— 驱魔少年</p></li>
<li><p><strong>堕入黑暗裏的可怜影子啊，停止伤害他人的行为吧，犯下罪行的灵魂…想死一次么？</strong> —— 地狱少女</p></li>
<li><p><strong>我的生命是属于你的，亚丝娜，我将为你而活。</strong> —— 刀剑神域</p></li>
<li><p><strong>“如果我不在了，你会怎样？” “我会去找你” “如果找不见呢？” “我会一直，一直，一直找下去”</strong> —— 人鱼森林</p></li>
<li><p><strong>将愿望倾入不愿忘却的回忆中…</strong> —— ef-a tale of memories</p></li>
<li><p><strong>All for one, one for all.</strong> —— 海贼王</p></li>
<li><p><strong>祈求别人幸福的同时,却不得不去诅咒其他的人,我们魔法少女就是这样的构造吧!</strong> —— 魔法少女小圆</p></li>
<li><p><strong>人的一生会遭遇各种各样的事，其中有令人难以置信的事，也有不讲道理的事，但都必须予以克服，这就是生活</strong> —— 地狱少女</p></li>
<li><p><strong>以为大哭大闹一场就有人来安慰的家伙真是幸福呢。</strong> —— 龙与虎</p></li>
<li><p><strong>时间可以治愈？如果时间也病了怎么办</strong> —— 寒蝉明泣之时</p></li>
<li><p><strong>如果幸福有形状，该是什么样的呢？它就像玻璃，因为平时察觉不到它的存在，而它却时时在我们身边，最有力的证据就是，只要换一个角度，它就会折射出耀眼的光芒，比谁都过分强调自我的存在。</strong> —— 反叛的鲁鲁修</p></li>
<li><p><strong>求你，保护那孩子，消除灾厄，抹除祸事。哪怕…那是我自己…</strong> —— 食灵</p></li>
<li><p><strong>不是我，都是社会的错</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>El Psy Congroo..</strong> —— 命运石之门</p></li>
<li><p><strong>红茶的温度和女人心在任何时代都是难以琢磨呢。</strong> —— 海猫鸣泣之时</p></li>
<li><p><strong>并非喜欢、也不是爱。而是更加深刻而沉重的——</strong> —— SWEET POOL</p></li>
<li><p><strong>Oh,please don't let me die. Waiting for your touch.</strong> —— Re：从零开始的异世界生活</p></li>
<li><p><strong>You Are (Not) Alone;You Can (Not) Advance;You Can (Not) Redo</strong> —— EVA</p></li>
<li><p><strong>禁忌算什么！那难道比爱丽丝的命还重要吗？</strong> —— 刀剑神域</p></li>
<li><p><strong>MAKE OUR DREAMS ALIVE</strong> —— ラブライブ！</p></li>
<li><p><strong>什么都无法舍弃的人，什么都无法改变 。</strong> —— 进击的巨人</p></li>
<li><p><strong>知道人的眼睛为什么长在前面吗？那是因为如果想看到远处的风景的话，就只能向前前进。</strong> —— 天元突破：红莲螺岩</p></li>
<li><p><strong>春天 马上就要来了 让我与你相遇的春天 就要来了 再也没有你的春天 就要来了</strong> —— 四月是你的谎言</p></li>
<li><p><strong>世间万物，如果一直放着不管的话，便一定会向不好的方向发展。就像即使如何的努力也无法阻止宇宙变冷一样。只是按照‘常理进行’不断积累而构筑出的世界，无论如何也无法脱离物理法则的束缚。</strong> —— 虚渊玄</p></li>
<li><p><strong>无可替代的存在什么的不是很可怕吗？一旦失去就再也无法取回；绝对不能容忍失败；无法再一次得到。</strong> —— 果然我的青春恋爱喜剧搞错了</p></li>
<li><p><strong>其实...根本就没有什么天堂和地狱吧....</strong> —— 死亡笔记</p></li>
<li><p><strong>真正重要的东西，永远都是非常简单的。</strong> —— Clannad</p></li>
<li><p><strong>我已经准备好了足够挡雨的伞，可是却迟迟没有等到雨的到来，这样的尴尬只是我漫长人生中的小插曲罢了。</strong> —— 千与千寻</p></li>
<li><p><strong>我觉得在这里干尽坏事的玩家，都是些在现实世界中也烂到骨子里的家伙。</strong> —— 刀剑神域</p></li>
<li><p><strong>是你赢了...哲...</strong> —— 黑子的篮球</p></li>
<li><p><strong>我们一直在一起，所以最后也想在你身旁。</strong> —— 火影忍者</p></li>
<li><p><strong>人们只是用好人来称呼对自己有用的人而以，不存在对所有人都有用的人</strong> —— 进击的巨人</p></li>
<li><p><strong>要是太勉强自己的话，总有一天会受伤的</strong> —— 吸血鬼骑士</p></li>
<li><p><strong>我本身得不到答案。所以，我希望有能够答出来之物的诞生。</strong> —— Fate/Stay Night</p></li>
<li><p><strong>最初的一步，泪水之后再一次，雕刻的风景线，消逝在黄昏中的风，直到梦的最后。</strong> —— Clannad</p></li>
<li><p><strong>应该可以了吧，我已经很努力了，应该可以抵达终点了…</strong> —— AIR</p></li>
<li><p><strong>所谓的奇迹就是要发生之后才会有价值存在的吧</strong> —— EVA</p></li>
<li><p><strong>笑是对身边的事物感到一瞬间的幸福而表现出来的东西。</strong> —— CLANNAD</p></li>
<li><p><strong>休息对于生存而言，也是紧要问题</strong> —— 虫师</p></li>
<li><p><strong>比自己,比梦想更重要的东西永远都存在着...</strong> —— 钢之炼金术师</p></li>
<li><p><strong>失礼。噛みました</strong> —— 化物语(上)</p></li>
<li><p><strong>驱动着这个世界的，并非只有眼睛能够看到的东西。就像只观察结晶回路的轮盘是无法知晓齿轮的运动一样……</strong> —— 空之轨迹</p></li>
<li><p><strong>是个男人就要对自己的人生负责</strong> —— 麻辣教师</p></li>
<li><p><strong>我们不是狼，我们只是长着獠牙的羊......</strong> —— 羊之歌</p></li>
<li><p><strong>没有偶然的必然，只有必然的偶然</strong> —— 魔卡少女樱</p></li>
<li><p><strong>我觉得你很幸福，因为你可以选择爱或者不爱我，而我只能选择爱或者更爱你</strong> —— 草莓100%</p></li>
<li><p><strong>前天是兔子，昨天是小鹿，今天是你</strong> —— Clannad</p></li>
<li><p><strong>ご無事で何よりです。</strong> —— 妖狐X僕ss</p></li>
<li><p><strong>少年少女 向前走吧。</strong> —— 阳炎PROJECT</p></li>
<li><p><strong>过分的神圣，往往比恶魔更加恶质。</strong> —— 黑执事</p></li>
<li><p><strong>正因生来一无所有，因此我们能拥有一切。</strong> —— 游戏人生</p></li>
<li><p><strong>我从来都不是什么天才，只是一个普通人，是一个连一个小女孩都保护不了的普通的、渺小的人类啊。</strong> —— 钢之炼金术师</p></li>
<li><p><strong>我不会去统治这片大海，在这片大海上，最自由的人就是海贼王！</strong> —— 海贼王</p></li>
<li><p><strong>失礼、噛みました</strong> —— 化物语</p></li>
<li><p><strong>她有心，她的心在我这里。</strong> —— 人形电脑天使心</p></li>
<li><p><strong>努力不会背叛自己，虽然有时会背叛梦想</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>超频链接</strong> —— 加速世界</p></li>
<li><p><strong>若没有可依靠之处，便也找不到自己的归宿，躲躲藏藏随波逐流，依附于某物，却又一头撞在看不见的墙壁上。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>就算是自私…我也希望那些人能够永远都有笑容…</strong> —— 夏目友人帐</p></li>
<li><p><strong>挚友的执念烙印此身，无尽的黑暗化为光明，天上天下，一骑当神！</strong> —— 天元突破：红莲螺岩</p></li>
<li><p><strong>人在直面恐惧的时候，自身的灵魂将会受到考验。降生于这世界，究竟有何所求，要成何事，其本性会暴露无遗。</strong> —— PSYCHO-PASS</p></li>
<li><p><strong>整个社会对我都很苛刻。所以至少让我自己宽容一下我自己吧。如果大家都对自己更宽容一点的话。大家都变成废柴就没有废柴了。</strong> —— 果然我的青春恋爱喜剧搞错了</p></li>
<li><p><strong>还能再见面吗? 一定能见面的</strong> —— Fantastic Children</p></li>
<li><p><strong>即使你忘却了我，我也不会遗忘你。</strong> —— 菜月昂</p></li>
<li><p><strong>不要伤害自己，别人总会这样做。</strong> —— 天国王朝</p></li>
<li><p><strong>我喜欢你，比世界上任何人都喜欢你。</strong> —— 名侦探柯南</p></li>
<li><p><strong>人是可以改变一切的，世上的一切。</strong> —— 吹响！上低音号</p></li>
<li><p><strong>所谓的「改变自己，世界就会随之改变」这种事，是不可能的。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>我想成为一个温柔的人，因为曾被温柔的人那样对待，深深了解那种被温柔相待的感觉。</strong> —— 夏目友人帐</p></li>
<li><p><strong>你喜欢的人已经心有所属不是正常的吗，因为你喜欢他，所以你的眼中就只有她。人啊，总是盲目地去爱。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>忍者的才能不在于所掌握忍术的多少，而在于永不放弃的毅力.笔直向前绝不违背自己的誓言，还有不管何时都不放弃.</strong> —— 火影忍者</p></li>
<li><p><strong>我动身踏上旅程，是为了与你道别。</strong> —— 追逐繁星的孩子</p></li>
<li><p><strong>大家即将各自展开旅程，挥别这个没落的城镇。</strong> —— 仰望半月的夜空</p></li>
<li><p><strong>正气和狂气，理性和知性，自信和确信，在悲剧性的不合理世界，故事开始了。</strong> —— 绝园的暴风雨</p></li>
<li><p><strong>将所有人类当成玩偶的神,本身居然也是个小丑啊。</strong> —— Fate/Zero</p></li>
<li><p><strong>即使想放弃，也没法放弃最想要的东西，这就是人</strong> —— 悠久之翼</p></li>
<li><p><strong>拿起武器，无论顺从还是逃跑，都无法得到自由，既然如此，我们只能战斗，为了自由，站起来吧。</strong> —— 妖精的尾巴</p></li>
<li><p><strong>所谓长大成人，就是不断聚了散，散了又聚。为了让彼此不会受伤害而保持一个适当的距离。</strong> —— 新世纪福音战士</p></li>
<li><p><strong>如果说怪盗是一个技艺精湛，盗取财宝的艺术家，那么侦探就只是跟在怪盗后面吹毛求疵，充其量不过是个评论家。</strong> —— 名侦探柯南</p></li>
<li><p><strong>我不相信人类......但是，我相信人类的“可能性”</strong> —— 游戏人生</p></li>
<li><p><strong>即使作为代价要夺走我什么，即使接下来等待我的是什么，即使那样，我无论如何都不想失去他。</strong> —— 少年阴阳师</p></li>
<li><p><strong>据说之所以有人出现在梦中，是因为对方想见你的心情穿过身体，飞进了你的梦中。</strong> —— 蜂蜜与四叶草</p></li>
<li><p><strong>好梦向来易醒。</strong> —— 风之谷</p></li>
<li><p><strong>追逐梦想的人比抓住梦想的人更能发挥实力。</strong> —— 银魂</p></li>
<li><p><strong>因为世界并不如你想象的那样坏。</strong> —— 无头骑士异闻录</p></li>
<li><p><strong>人只会看到自己想看到的、听到自己想听到的，我也并不例外。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>美丽的不是这个世界，而是接受了这个世界的你的眼睛。</strong> —— 吸血鬼骑士</p></li>
<li><p><strong>干燥的冷气，尘埃的味道，我在其中……踏上旅途。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>人总有一天都会死的，但正因为生命是有限的，才能够欢喜和悲伤。</strong> —— 通灵王</p></li>
<li><p><strong>舞台上演员不能无视剧本随便演，华丽地退场才是完成使命。</strong> —— 绝园的暴风雨</p></li>
<li><p><strong>只顾着追求新事物，却不回顾历史，怎么会有未来。</strong> —— 虞美人盛开的山坡</p></li>
<li><p><strong>为什么妈妈就不明白无所事事的忙碌呢。</strong> —— 白熊咖啡屋</p></li>
<li><p><strong>好红，每当想起你，枫叶就会被染红。</strong> —— 银仙</p></li>
<li><p><strong>也许正义并非太阳，而是如同星星一般的东西，天空中有无数的星星，彼此不断抵消着其他星星的光芒。</strong> —— 亚尔斯兰战纪</p></li>
<li><p><strong>起风了,唯有努力生存。</strong> —— 起风了</p></li>
<li><p><strong>走过一段路 回头看 原来那些痛得快要死去的事情是可以一笑而过的。</strong> —— 黑子的篮球</p></li>
<li><p><strong>我们都在梦中，一个叫青春的梦里。梦总有一天会醒来，而回忆会一直闪烁。</strong> —— 校园迷糊大王</p></li>
<li><p><strong>王冠会让戴上它的人高人一头，是地位的象征。但王冠真正的意义是：当灾难从天而降时，我会为你们抵挡一切，永远让你们只看到金色的希望。</strong> —— 星游记</p></li>
<li><p><strong>只要怀着理想而行动，就算结果不尽如人意也没有关系。但是如果失去了理想，那就真的一无所有了，连自己珍视的人都保护不了。</strong> —— 境界的彼方</p></li>
<li><p><strong>如果要伤害别人的感情才能实现的话，对那个人来说梦想就已经不能称之为梦想了。</strong> —— 名侦探柯南</p></li>
<li><p><strong>我不会忘记，一直，都留在我的心间。</strong> —— 文学少女</p></li>
<li><p><strong>当一个胖纸没有什么不好，最起码可以温暖其他的人。</strong> —— 龙猫</p></li>
<li><p><strong>是鸣人改变了我！是鸣人的笑脸拯救了我！所以，如果是为了保护鸣人，就算死，我也无可畏惧，因为我，最喜欢鸣人了。</strong> —— 火影忍者</p></li>
<li><p><strong>总在不停寻觅你的踪影，无论十字路口抑或梦境之中，明知你不在，却依然不停地找寻。</strong> —— 秒速五厘米</p></li>
<li><p><strong>你受伤的时候，我永远都在。</strong> —— 多啦A梦</p></li>
<li><p><strong>在未知的未来将要发生的事，一定有它的意义</strong> —— 火影忍者</p></li>
<li><p><strong>那只萤火虫在很长很长的时间里都是独自一人生活，甚至忘了自己是只萤火虫。</strong> —— 小鸠</p></li>
<li><p><strong>最近的烦恼是小小的离别带来的寂寞，一瞬间的邂逅与分别，这一个一个的刹那，我想好好珍惜起来。</strong> —— 夏目友人帐</p></li>
<li><p><strong>如果基拉被抓住了，那他就是邪恶，如果基拉统治了世界，那他就是正义。</strong> —— 死亡笔记</p></li>
<li><p><strong>无论最终的结果是什么，只要这是自己选择的道路。</strong> —— 龙与虎</p></li>
<li><p><strong>在面对这些强敌之前...一定要先将眼前敌人逐个打败吧。</strong> —— 网球王子</p></li>
<li><p><strong>物转星移，花开花落，周而复始，生生不息，但今昔已非昨日，然今日花容依旧。</strong> —— 虫师</p></li>
<li><p><strong>隐藏的是心中的秘密，照耀两人的是star和snow……</strong> —— 名侦探柯南</p></li>
<li><p><strong>从进入厨房的瞬间开始，你们就肩负着烹饪美食的责任。</strong> —— 食戟之灵</p></li>
<li><p><strong>生活坏到一定程度就会好起来，因为它无法更坏。</strong> —— 龙猫</p></li>
<li><p><strong>当你决定了要向前迈进的那一刻, 你就已经踏出前进的一步了。</strong> —— Canvas2 ～七彩的素描～</p></li>
<li><p><strong>我再也不要看见她哭的样子了，就算我从此从她心目中消失。</strong> —— 名侦探柯南</p></li>
<li><p><strong>无限接近于零，却又不等于零的可能性。</strong> —— 游戏人生</p></li>
<li><p><strong>在弱者眼里可能是这样，不过，我的确很强。</strong> —— 蔷薇少女</p></li>
<li><p><strong>我无法抗拒泡面这种没营养又廉价的口感。</strong> —— 银仙</p></li>
<li><p><strong>荣耀就在彼方，遥不可及才要挑战，歌颂霸道，展现霸道，为了守护我背影的臣子。</strong> —— RIDER Fate/Zero</p></li>
<li><p><strong>活着本身就是一种价值，因为还有明天。</strong> —— 高达</p></li>
<li><p><strong>大家互相帮助，一起成功，一起幸福什么的，不过是种理想。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>话说回来，现充还真是麻烦啊。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>重逢的时候没想到我会这样喜欢他，虽然你不是我交往的第一人，可却是我的初恋，虽然你可能并不知道。</strong> —— 世界第一初恋</p></li>
<li><p><strong>有了喜欢的人，就会在意各种小事，感觉很不自由，但是，为了那些小事左思右想，心里竟然会这么快乐。</strong> —— 闪烁的青春</p></li>
<li><p><strong>就算世上有着所谓的“好女人”，也不会有着“和我关系好的女人”。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>必须洗净一切往事，否则你永远无法清楚自由地看这个世界</strong> —— 死神</p></li>
<li><p><strong>己所欲者，杀而夺之，亦同天赐</strong> —— 游戏人生</p></li>
<li><p><strong>即使你已经习惯了受伤害，也有人看了会心疼的。</strong> —— 我的恋爱物语果然有问题</p></li>
<li><p><strong>这个世界上没有完美的人类，所以，人无法自己一个人活著。</strong> —— 不可思议游戏</p></li>
<li><p><strong>我们会，慢慢长大成人，随着季节的不停变换 路边盛开的鲜花也在不断变化。</strong> —— 未闻花名</p></li>
<li><p><strong>只要一天活著,难过的事总有一天会让你笑著说出来。</strong> —— 天空之城</p></li>
<li><p><strong>命运的红线一旦断了，就再也接不上了。</strong> —— 犬夜叉</p></li>
<li><p><strong>一举一动，都是承诺，会被另一个人看在眼里，记在心上的。</strong> —— 悬崖上的金鱼姬</p></li>
<li><p><strong>如果你一个人把什么都做完了，那我做什么？</strong> —— 元气少女缘结神</p></li>
<li><p><strong>在自称善意的之时，即存恶意。</strong> —— 罪恶王冠</p></li>
<li><p><strong>正因为生命有限，所以才显得更重要，正因为生命有限，所以才更应该努力不懈。</strong> —— 名侦探柯南</p></li>
<li><p><strong>总觉得跟你在一起，不管多高的地方都可以到达。</strong> —— 网球王子</p></li>
<li><p><strong>人这种东西，除了为了永不满足的欲望追求新的刺激之外，也是重视稀少价值之物的奇怪生物。</strong> —— gosick</p></li>
<li><p><strong>那些坚定决心的人们，会展现出好脸色。</strong> —— 闪电十一人</p></li>
<li><p><strong>世界不完美 所以才显得美丽</strong> —— 钢之炼金术士</p></li>
<li><p><strong>即使匍匐在地，也要持续前进，这才是你的作风。现在的你只靠一些漂亮话当借口，在高墙前使性子，不过是个小鬼罢了。</strong> —— 银魂</p></li>
<li><p><strong>明明喜欢的不得了，可是看到对方幸福洋溢的表情，却觉得很难过、很痛苦，胸口发疼。</strong> —— 彩云国物语</p></li>
<li><p><strong>失望了吗？没错，世上或许有些东西别打开比较好，真正把心打开的人多么麻烦啊！</strong> —— 绝望先生</p></li>
<li><p><strong>哭也不会改变什么，这个世界从来不会对任何人温柔。</strong> —— 黑执事</p></li>
<li><p><strong>不论是过去还是未来，我都会保护你！</strong> —— 旋风管家</p></li>
<li><p><strong>自己的过去会被当做笑话或者捏他的形式，被他人随随便便的共有化。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>因为等待的越久，重逢时就越幸福啊。</strong> —— 名侦探柯南</p></li>
<li><p><strong>我在时光斑驳深处，聆听到花开的声音。</strong> —— 未闻花名</p></li>
<li><p><strong>神会对努力之人微笑，这是骗人的，但我们偶然会被命运之神垂青。</strong> —— 吹响吧！上低音号</p></li>
<li><p><strong>大国战争之后还会繁荣富强，而只有小国涂炭遭殃，让世界感受痛苦吧。</strong> —— 火影忍者</p></li>
<li><p><strong>人生最糟糕的事，一个是饿肚子，一个是孤独。</strong> —— 夏日大作战</p></li>
<li><p><strong>你指尖跳动的电光，是我此生不变的信仰</strong> —— 某科学的超电磁炮</p></li>
<li><p><strong>温柔解救不了这个世界</strong> —— 罪恶王冠</p></li>
<li><p><strong>代你见证世界的终结，来世再续梦之伊甸</strong> —— Eden*/b站弹幕</p></li>
<li><p><strong>今日已成往昔，明日即将到来，为此理所当然之事，感到无比痛心。</strong> —— 寻找失去的未来</p></li>
<li><p><strong>我活在我的时间里，她活在她的时间里，因此，我们时间交错的瞬间，对我而言比任何事物都宝贵。</strong> —— 她与她的猫</p></li>
<li><p><strong>人类，在决战之时难道会选择自己不擅长的武器来战斗吗？</strong> —— 只有神知道的世界</p></li>
<li><p><strong>这只手，暂时不洗了</strong> —— 小林家的龙女仆</p></li>
<li><p><strong>重要的人，不能忘记的人，不想忘记的人。 你，是谁？</strong> —— 你的名字</p></li>
<li><p><strong>正是在对未来没有任何希望的时候，一个人能坚持到什么地步，才真正体现出这个人有多坚强。</strong> —— 来自新世界</p></li>
<li><p><strong>除了这一颗心，都是你的。</strong> —— 人渣的本愿</p></li>
<li><p><strong>正是因为这一点一滴觉得还有希望的自己，才是最无可救药的吧。</strong> —— 人渣的本愿</p></li>
<li><p><strong>我们都很执着,而且思念的越深,越是绝望。</strong> —— 人渣的本愿</p></li>
<li><p><strong>一个人觉得寂寞，和另一个人相互依偎又有什么错</strong> —— 人渣的本愿</p></li>
<li><p><strong>想象力足以改变一切。</strong> —— 来自新世界</p></li>
<li><p><strong>越是珍惜呆在这里的时间，今后就越是悲伤吧。但是我认为不能称之为「后悔」。</strong> —— 小林家的龙女仆</p></li>
<li><p><strong>大部分人并不想长大，只是没办法继续当一个小孩子</strong> —— 小林家的龙女仆</p></li>
<li><p><strong>不得了不得了</strong> —— 小林家的龙女仆</p></li>
<li><p><strong>你已经不是我的狗了。</strong> —— 龙与虎</p></li>
<li><p><strong>正因为有忘也忘不了的回忆，才会变得坚强，这就是所谓的成长吧！</strong> —— 火影忍者</p></li>
<li><p><strong>其实我对混合咖啡还是很有自信的</strong> —— 珈百璃的堕落</p></li>
<li><p><strong>如果当初握住的不是硬币，而是勇者的手......</strong> —— 中二病也要谈恋爱 恋！</p></li>
<li><p><strong>只要是正义的一方，无论手段多么卑鄙都可以被原谅</strong> —— 东京喰种</p></li>
<li><p><strong>你偶尔也该回头看看，那些在你身后的人，说不定已经追到你脚边了！！！</strong> —— 妖精的尾巴</p></li>
<li><p><strong>因为喜欢你，所以想继续相信下去。</strong> —— 空之境界</p></li>
<li><p><strong>自杀是没有理由的，只是今天没有飞起来罢了。</strong> —— 空之境界</p></li>
<li><p><strong>听说，樱花花瓣飘落的速度，是每秒5厘米，思念的距离到底有多远。如果樱花下落时是有声音的，你会不会听到我对你的思念</strong> —— 秒速五厘米</p></li>
<li><p><strong>在下雪时。第一次相会时。雪白的夜与漆黑的伞。只要有你在身边。只要你露出微笑。就是幸福。</strong> —— 空之境界</p></li>
<li><p><strong>身体被冻僵了，仅有吐出的气息略带热度。望着彼此即将停止的心脏鼓动。 然后，极为珍惜的记忆随即就会消失而化为眷恋。</strong> —— 空之境界</p></li>
<li><p><strong>对于虚伪而言，真实的光明或许过于耀眼了</strong> —— 蔷薇少女</p></li>
<li><p><strong>好了 接下来就让你们见识一下程序员的本事</strong> —— 骑士与魔法</p></li>
<li><p><strong>如果结果不如你所愿，就在尘埃落定前奋力一搏。</strong> —— 夏目友人帐</p></li>
<li><p><strong>如果因为害怕失败，而不去努力，那就不会有能够成功的人。</strong> —— 樱花庄的宠物女孩</p></li>
<li><p><strong>你一直相信的事，也让我相信吧。活着，是件美好的事。</strong> —— Angle Beats</p></li>
<li><p><strong>我只希望，我喜欢的人可以健康的活着。</strong> —— 人渣的本愿</p></li>
<li><p><strong>正因为生来什么都没有，因此我们能拥有一切。</strong> —— 游戏人生</p></li>
<li><p><strong>未来的事无人知晓，所以它才如同这重逢一般，拥有着无限的可能性。</strong> —— 命运石之门</p></li>
<li><p><strong>只要努力活下去，总有一天会笑着回忆。</strong> —— 不可思议游戏</p></li>
<li><p><strong>想说什么就说，想做什么就做，我们不就是这么一直过来的吗？</strong> —— LoveLive!</p></li>
<li><p><strong>也许一个人的快乐会建立在另一个人或者很多人的痛苦之上。但是，自己种下的祸根终有一天会报应在自己的身上的。</strong> —— 地狱少女</p></li>
<li><p><strong>何必去在意自己与别人相比是否特别呢？即便只有一个人也好。只要有一个认为自己特别的人，我觉得那就足够了。</strong> —— 冰菓</p></li>
<li><p><strong>虚伪的眼泪，会伤害别人，虚伪的笑容，会伤害自己。</strong> —— 叛逆的鲁鲁修</p></li>
<li><p><strong>空太是笨蛋！</strong> —— 樱花庄的宠物女孩</p></li>
<li><p><strong>不敢反抗压迫的心理将伴你一生</strong> —— 狂赌深渊</p></li>
<li><p><strong>未来的旅程是如此遥远，能见到的光明却是如此稀少。即使如此——我仍然没有完全放弃希望。</strong> —— 刀剑神域</p></li>
<li><p><strong>契约者不会做梦。</strong> —— 黑之契约者</p></li>
<li><p><strong>不可结缘</strong> —— 夏目友人帐</p></li>
<li><p><strong>去做你喜欢做的事吧 这就是所谓的那啥...青春嘛</strong> —— 月色真美</p></li>
<li><p><strong>重要的感情总是非常单纯 自然脱口而出的</strong> —— GAMERS电玩咖！</p></li>
<li><p><strong>This is your dream! Anything you can do in your dreams, you can do now!</strong> —— My Little Pony: Friendship is Magic</p></li>
<li><p><strong>What about super-ultra-extreme-awesomazing?</strong> —— My Little Pony: Friendship is Magic</p></li>
<li><p><strong>We've learned that friendship isn't always easy, but there's no doubt it's worth fighting for!</strong> —— My Little Pony: Friendship is Magic</p></li>
<li><p><strong>今宵之月，绝不西沉。只此美梦，不再苏醒。从今往后，生生世世，长相厮守，为你立誓。</strong> —— 银魂</p></li>
<li><p><strong>打架这玩意，不就是为了守护什么东西吗？</strong> —— 银魂</p></li>
<li><p><strong>届けて— 切なさには 名前をつけようか“Snow halation”</strong> —— Snow Halation</p></li>
<li><p><strong>我是想被包养，但不会接受施舍</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>善于破坏气氛的人，不仅能破坏好的气氛，其实也能把坏的气氛破坏掉。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>为什么要称赞他人？那是为了把对方捧到更高的地方更容易绊他的脚，为了把他从高处摔下来。这就叫做称赞杀人法。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>女生口中的「好人」首先百分之百是「怎样都好的人」的意思，再好也不过止于「方便好使的人」。也就是说，不管怎样都是没戏了</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>夜晚还远远没有结束!</strong> —— 春宵苦短，少女前进吧！</p></li>
<li><p><strong>只要世间有酒,我就喝不够!</strong> —— 春宵苦短，少女前进吧！</p></li>
<li><p><strong>如果我们能活着出去，千山万水，你愿意陪我一起看吗？</strong> —— 狐妖小红娘</p></li>
<li><p><strong>不可结缘,徒增寂寞</strong> —— 夏目友人帐</p></li>
<li><p><strong>就算世界终结，也无所谓</strong> —— 少女终末旅行</p></li>
<li><p><strong>遇到事情不能坐以待毙！</strong> —— 捷德奥特曼</p></li>
<li><p><strong>为了爱，与梦想！</strong> —— 眼大人</p></li>
<li><p><strong>今日的余晖和你最后那天给我的拥抱，同一个温度</strong> —— Myself</p></li>
<li><p><strong>想和你重新认识一次 从你叫什么名字说起。</strong> —— 你的名字</p></li>
<li><p><strong>不管你在世界的哪个地方，我一定会，再次去见你的。</strong> —— 你的名字</p></li>
<li><p><strong>只要记住你的名字，不管你在世界的哪个地方 ，我一定会，去见你。</strong> —— 你的名字</p></li>
<li><p><strong>和绝望，和睦相处</strong> —— 少女终末旅行</p></li>
<li><p><strong>愿你有一天，能与你最重要的人重逢</strong> —— 可塑性记忆</p></li>
<li><p><strong>不相信人咬不到肚脐的，咬破肚脐去死如何？</strong> —— 海猫鸣泣之时</p></li>
<li><p><strong>梦想是否无聊并不是别人来决定的，不管是什么样的梦想，自己拼命努力去追寻才是最重要的。</strong> —— 守护甜心</p></li>
<li><p><strong>将愿望倾入不愿忘却的回忆中??</strong> —— ef-a tale of memories</p></li>
<li><p><strong>倘若只是为了驱赶心中的寂寞，找谁都可以的。</strong> —— 秒速5厘米</p></li>
<li><p><strong>什么都无法舍弃的人，什么都无法改变 。</strong> —— 进击的巨人</p></li>
<li><p><strong>比希望更炙热，比绝望更深邃，这就是爱啊。</strong> —— 魔法少女小圆-叛逆的物语</p></li>
<li><p><strong>我们都在命运之湖上荡舟划桨，波浪起伏着而我们无法逃脱孤航。但是假使我们迷失了方向，波浪将指引我们穿越另一天的曙光。</strong> —— 死神</p></li>
<li><p><strong>懂得认输是非常重要的，不尝到失败的不甘，也就不会明白跌倒后怎么爬起来，更不可能再向前迈进。</strong> —— 笨蛋测验召唤兽</p></li>
<li><p><strong>重要的不是你做了多少事，而是你放了多少心思进去。</strong> —— 凉宫春日的忧郁</p></li>
<li><p><strong>就算是自私??我也希望那些人能够永远都有笑容??</strong> —— 夏目友人帐</p></li>
<li><p><strong>(」?ω?)」うー！(／?ω?)／にゃー！</strong> —— 潜行吧奈亚子</p></li>
<li><p><strong>欺骗世界，欺骗最初的你。</strong> —— Steins;Gate</p></li>
<li><p><strong>在走廊上跌倒会流鼻血，在人生中跌倒会流眼泪。</strong> —— 龙虎斗</p></li>
<li><p><strong>相信十年后的八月，我们还会相遇。</strong> —— 未闻花名</p></li>
<li><p><strong>男人就应该保持冷静，沸腾的水只会被蒸发掉。</strong> —— 假面骑士kabuto</p></li>
<li><p><strong>不管看到什么样的过去，都请不要迷失自己，不管你变成什么样子，我都是你的同伴。</strong> —— angel beats</p></li>
<li><p><strong>想要试着去相互接近，但最后还是无法敞开心扉，结果就是擦肩而过??</strong> —— 文学少女</p></li>
<li><p><strong>不能逃避，不能逃避，不能逃避，不能逃避??</strong> —— EVA</p></li>
<li><p><strong>我终不能改变那个开始，何不忘了那个结局呢。</strong> —— 悟空传</p></li>
<li><p><strong>因为我想活着，我不能掩藏我心中的本欲，正如我心中爱你美丽,又怎能嘴上装四大皆空。</strong> —— 悟空传</p></li>
<li><p><strong>这短短的一生，我们最终都会失去。你不妨大胆一些，爱一个人，攀一座山，追一个梦。</strong> —— 大鱼海棠</p></li>
<li><p><strong>出来吧，刻刻帝！</strong> —— 时崎狂三</p></li>
<li><p><strong>翠星石最喜欢苍星石的说,所以到死也要在一起的说...</strong> —— Rozen Maiden</p></li>
<li><p><strong>都是时辰的错！</strong> —— Fate/Zero</p></li>
<li><p><strong>鸣神の　少しとよみて　さし昙り　雨も降らんか　君を留めん</strong> —— 言叶之庭</p></li>
<li><p><strong>所谓爱情，是对对自己最重要的人，以慈悲的心保护他的想法。</strong> —— 火影忍者</p></li>
<li><p><strong>旅行唯有出发前最愉快，狗儿唯有叫声最吓人，女人唯有背影最美丽。</strong> —— 狼与香辛料</p></li>
<li><p><strong>让我们开始我们的约会（战争）吧</strong> —— 约会大作战</p></li>
<li><p><strong>连我爸都没打过我</strong> —— 高达0079</p></li>
<li><p><strong>这是你所不能理解的，人类感情的极致，比希望更热烈，比绝望更深邃——爱！</strong> —— 魔法少女小圆新篇 叛逆的物语</p></li>
<li><p><strong>What, so everyone's supposed to sleep every single night now? You realize that nighttime makes up half of all time?</strong> —— Rick</p></li>
<li><p><strong>人生没有彩排，只有现场直播，所以做最好的自己。</strong> —— Internet</p></li>
<li><p><strong>对自己有自信时，不能对别人说「期待」。所谓的「期待」是放弃时的托词，因为别无选择。若缺少这种无奈感，这个词就太虚伪了。</strong> —— 冰菓</p></li>
<li><p><strong>人难免伤害别人,也难免受伤,不过,人是不会轻易讨厌别人的.</strong> —— 火影忍者</p></li>
<li><p><strong>以智者之名，为愚者代辩。</strong> —— Gosick</p></li>
<li><p><strong>清算，终将到来。</strong> —— Stellaris</p></li>
<li><p><strong>据说啊 叹气会让幸福溜走的</strong> —— 再见了 我们的幼儿园</p></li>
<li><p><strong>你将不再是道具，而是人如其名的人。</strong> —— 紫罗兰永恒的花园</p></li>
<li><p><strong>人没有回忆是无法活下去的哟</strong> —— AIR</p></li>
<li><p><strong>只要万事俱备，就能一直保持冷静，无论发生什么事，都不会害怕。</strong> —— 银魂</p></li>
<li><p><strong>正因为不会发生，人们才称它为”奇迹“</strong> —— KANON</p></li>
<li><p><strong>我想成为一个温柔的人,因为曾被温柔的人那样对待,深深了解那种被温柔相待的感觉。</strong> —— 夏目友人帐</p></li>
<li><p><strong>我喜欢的人…也能喜欢上自己，我认为这就是奇迹。</strong> —— 月色真美</p></li>
<li><p><strong>大圣此去欲何? 踏南天，碎凌霄！若一去不回.... 便一去不回！</strong> —— 影视</p></li>
<li><p><strong>我们一直在离别中，比如和爱的人，和伤害，甚至和时光。</strong> —— 萤火虫之墓</p></li>
<li><p><strong>至少恋爱不是种机会，我认为它是一种意志。</strong> —— 月色真美</p></li>
<li><p><strong>幸福感就如沉积在悲哀之河底下 隐隐发光的金砂</strong> —— 月色真美</p></li>
<li><p><strong>有样东西是其他生物绝对没有，只有人类才有 那就是人有秘密。</strong> —— 月色真美</p></li>
<li><p><strong>爱一定存在于世上 一定存在 无从寻觅的是爱的表现 是它的表达方式</strong> —— 月色真美</p></li>
<li><p><strong>把同班的可爱女同学娶回家就是我最大的梦想</strong> —— 月色真美</p></li>
<li><p><strong>在狂热思绪下喊出的爱情宣言中，存在着爱情的实体</strong> —— 月色真美</p></li>
<li><p><strong>回首前尘，尽是可耻的过往</strong> —— 月色真美</p></li>
<li><p><strong>月色如水，虽不如阳光般耀眼，但我的眼中却只有比那月色更可爱的你。心跳不知不觉中加速，嘴角也绷不住那溢出来的幸福笑意。月色确实醉人，却是因为你才显得更美</strong> —— 月色真美</p></li>
<li><p><strong>“不管你我相距多远，我都想告诉你 我对你的心意不会变，给即将去到陌生城市的你 ，我永远喜欢你”</strong> —— 月色真美</p></li>
<li><p><strong>我们人是需要吃饭、工作和休息的生物，只要满足了其中一项，其他两项也会逐渐满足，而当这三项都满足后，就会得到强烈的存在感。</strong> —— 银魂</p></li>
<li><p><strong>看来这世界 似乎还想要驯服我 那就如你所愿吧 我会美丽地挣扎到底</strong> —— 你的名字</p></li>
<li><p><strong>如果，樱花掉落的速度是每秒5厘米，那么两颗心需要多久才能靠近？</strong> —— 秒速五厘米</p></li>
<li><p><strong>坐上与学校相反方向的电车，展开没有目标的旅行，去往那从未见过的地方</strong> —— 比宇宙更远的地方</p></li>
<li><p><strong>不是为了战斗而活着，而是为了活着而战斗。</strong> —— 《DARLING in the FRANXX》</p></li>
<li><p><strong>幸福的回忆，美满的回忆不一定会成为救赎，有时候，回忆越是美满便越痛苦，也有时候，会越害怕，无论是对于将要离开的人来说，还是对于被留下的人来说，都不可能会成为一种救赎。</strong> —— 可塑性记忆</p></li>
<li><p><strong>恋爱不是谈出来的，而是陷进去的。</strong> —— GAMER电玩咖！</p></li>
<li><p><strong>我们的哀伤和年龄是没有关系的。</strong> —— 樱桃小丸子</p></li>
<li><p><strong>总在不停寻觅你的踪影，无论十字路口抑或梦境之中，明知你不在，却依然不停地找寻。</strong> —— 秒速五厘米</p></li>
<li><p><strong>我想你们的努力一定会有回报的</strong> —— 龙与虎</p></li>
<li><p><strong>人生不如意十有八九！</strong> —— 龙与虎</p></li>
<li><p><strong>此身为剑所天成，身如钢铁，心似琉璃。</strong> —— Fate</p></li>
<li><p><strong>我的梦想实现了，也留下了美好的回忆，我已经没有任何遗憾了。</strong> —— 末日时在做什么?有没有空?可以来拯救吗?</p></li>
<li><p><strong>死者的血泪混入滚滚的流沙之中...将会赐予修罗更强的力量...</strong> —— 火影忍者</p></li>
<li><p><strong>有型的东西终究会消逝，不过……终于，这份回忆还是永远不朽的…</strong> —— 火影忍者</p></li>
<li><p><strong>人啊...想要保护重要东西的时候，就真的能变得很坚强。</strong> —— 火影忍者</p></li>
<li><p><strong>寂寞阴暗中度过，孤单孕育了怨与悲凉。锋利的伤痛刺入了我们彼此胸膛，这是我们无法躲避的惩罚，是我们不该任人生撩拨忧伤，不该走过之后又往回看。</strong> —— 火影忍者</p></li>
<li><p><strong>哪怕是打断你的手脚，也要把你带回去。</strong> —— 火影忍者</p></li>
<li><p><strong>从你站在桥上看我的 那一刻起你就是我的世界。</strong> —— 火影忍者</p></li>
<li><p><strong>龙儿是我的，谁都不许碰。</strong> —— 龙与虎</p></li>
<li><p><strong>卧龙低伏，入我阵来。</strong> —— 一人之下</p></li>
<li><p><strong>好红，每当想起你，枫叶就会被染红。</strong> —— 银仙</p></li>
<li><p><strong>相信十年后的八月，我们还会相遇。</strong> —— 未闻花名</p></li>
<li><p><strong>应该可以了吧，我已经很努力了，应该可以抵达终点了……</strong> —— AIR</p></li>
<li><p><strong>殺してあげる</strong> —— 緋色月下、狂咲ノ絶</p></li>
<li><p><strong>能力越大,责任越大</strong> —— 蜘蛛侠</p></li>
<li><p><strong>不要随便贬低自己</strong> —— 终将成为你</p></li>
<li><p><strong>我不喜欢这世界，我只喜欢你</strong> —— 乔一</p></li>
<li><p><strong>神啊 我的人生到底为何而存在呢</strong> —— 蜂蜜与四叶草</p></li>
<li><p><strong>想象力是武器，没有想象力的人会先死。</strong> —— 哥布林杀手</p></li>
<li><p><strong>我们只是历史的过客，目标渺茫，无地自容。我们没有世界大战可以经历，也没有经济大萧条可以恐慌。我们的战争充其量不过是内心之战，我们最大的恐慌就是自己的生活。</strong> —— 搏击俱乐部</p></li>
<li><p><strong>有的只是很简单的唯一的思想…只此一个！“胜利然后支配”！仅此而已...这才是我唯一的满足感！…至于过程和方法之类…并不重要！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>王有王的才能，厨师有厨师的才能，替身之间是没有强弱之分的</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>如果我们能活着出去的话，千山万水，你愿意陪我一起看吗？</strong> —— 狐妖小红娘</p></li>
<li><p><strong>如果可以，愿来生你不要忘记我，我也不要忘记你那熟悉的温柔。</strong> —— 狐妖小红娘</p></li>
<li><p><strong>我愿意呀，五十年前就愿意了。</strong> —— 狐妖小红娘</p></li>
<li><p><strong>而我不知不觉把自己遗忘，只想为你完成那个梦想。</strong> —— 狐妖小红娘</p></li>
<li><p><strong>让我成为你的双眼，把那世界万千，描绘在你面前。</strong> —— 狐妖小红娘</p></li>
<li><p><strong>有很多辛苦的事情，从结果上来说并不好。但是一起努力的过程，绝对不是没用的。我是这么想的。所以现在不是停滞不前的时候。</strong> —— 如果有个妹妹就好了</p></li>
<li><p><strong>你们这些天才止步不前的时候，我会走得更远。</strong> —— 如果有个妹妹就好了</p></li>
<li><p><strong>有些景色必须前进才能看到，那么只有勇往直前。</strong> —— 如果有个妹妹就好了</p></li>
<li><p><strong>果然啊，创造一样东西很开心。让别人享受自己创造的东西，是一种幸福呢。</strong> —— 如果有个妹妹就好了</p></li>
<li><p><strong>世界上哪有不会输的英雄啊</strong> —— 凸变英雄</p></li>
<li><p><strong>我怕失去了你，我的世界就没有了光明</strong> —— 凸变英雄</p></li>
<li><p><strong>虽然有时候，不知道要写些什么，有时候，却有很多想说的，来不及记录。回忆一转身，就悄悄溜走了。</strong> —— 凸变英雄</p></li>
<li><p><strong>哭过喊过便会停止哭泣</strong> —— 从零开始的异世界生活</p></li>
<li><p><strong>很抱歉，前面是单行道，你就乖乖的夹着尾巴耸拉着脑袋返回原点吧！</strong> —— 一方通行</p></li>
<li><p><strong>即便我弱了，也并不代表你强了。</strong> —— 魔法禁书目录</p></li>
<li><p><strong>小鬼，你为坠入不幸深渊之人而心痛 我不会多言，只不过周遭充斥不幸，而你的小船仅能载一人，若救助其他人，只会让彼此沉没。</strong> —— 文豪野犬</p></li>
<li><p><strong>死亡不是终点，被遗忘才是。</strong> —— 寻梦环游记</p></li>
<li><p><strong>世界上的人都变成废柴，这个世界就没有废柴了。</strong> —— 春物</p></li>
<li><p><strong>青春是谎言，是邪恶。</strong> —— 春物</p></li>
<li><p><strong>纵使日薄西山。</strong> —— 末日时在做什么</p></li>
<li><p><strong>孤高的游荡灵魂不需要羁绊之地</strong> —— 春物</p></li>
<li><p><strong>我的金子，只给千寻。</strong> —— 千与千寻</p></li>
<li><p><strong>步伐虽小，密而不停</strong> —— 实验品家庭</p></li>
<li><p><strong>只会比大小真是没品</strong> —— 某科学的超电磁炮S</p></li>
<li><p><strong>问灵十三载，等一不归人。</strong> —— 魔道祖师</p></li>
<li><p><strong>如果我是雨的话，也能像连接那永远都不将交汇的天空和大地一样，去连接某个人的心吗。</strong> —— BLEACH</p></li>
<li><p><strong>你还是...笑起来...最棒了</strong> —— 最终幻想XIV</p></li>
<li><p><strong>'Cause rainbow won't light up the sky unless you let it rain.</strong> —— My Little Pony: Friendship is Magic</p></li>
<li><p><strong>千山万水，因你不过毫厘</strong> —— 狐妖小红娘</p></li>
<li><p><strong>古往传奇多少别离，我 只是不经意 遇到了你</strong> —— 狐妖小红娘</p></li>
<li><p><strong>或许，你认为你的心已经给了他。但是，我会证明……我有一颗爱你的心！</strong> —— 狐妖小红娘</p></li>
<li><p><strong>你相信时间会抚平一切，可时过境迁，你已不复醒</strong> —— 动画</p></li>
<li><p><strong>不拼尽全力去试一下，又怎么会知道啊</strong> —— 刺客伍六七</p></li>
<li><p><strong>我今天就要带她走，我看谁敢拦我！</strong> —— 刺客伍六七</p></li>
<li><p><strong>你们人类让我明白了一个道理，那就是这个世界是不讲道理的</strong> —— 刺客伍六七</p></li>
<li><p><strong>人各有命，上天注定。有人天生为王，有人落草为寇。脚下的路如果不是你自己的选择，那么旅程的终点在哪儿也没人知道，你会走到哪儿，会碰到谁，都不一定。</strong> —— 镇魂街</p></li>
<li><p><strong>世界是无情的，并不存在与生俱来的英雄。 所以只能由刚好在旁边的人粉墨登场， 演一出英雄的戏码。</strong> —— 魔法禁书目录</p></li>
<li><p><strong>樱花满地集于我心，楪舞纷飞祈愿相随</strong> —— 罪恶王冠</p></li>
<li><p><strong>人的能力是有极限的。我从短暂的人生当中学到一件事……越是玩弄计谋,就越会发现人类的能力是有极限的……除非超越人类。</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>那似乎是比翼鸟。这种鸟天生单翼，须靠雌雄二鸟相互依偎才能翱翔天际，是种有缺陷的生物。但是，不知为何，我却感受到了这种生活方式的美妙。</strong> —— Darling in the FRANXX</p></li>
<li><p><strong>追寻只是因为无法抓获，想要触碰，只是因为知道自己触碰不到。</strong> —— FLCL Progressive</p></li>
<li><p><strong>世界上所有的不利情况都是因为当事者的能力不足造成的</strong> —— 东京喰种</p></li>
<li><p><strong>一个人有表里两面，你能看到的，仅仅是其中一面而已。</strong> —— 零的执行人</p></li>
<li><p><strong>不知彼此来世相逢。是否还能记得我是谁？</strong> —— 狐妖小红娘</p></li>
<li><p><strong>与其因为不信任而后悔，不如因为相信而后悔。</strong> —— 刀剑神域</p></li>
<li><p><strong>人生没有那么多的捷径，你不知道路的尽头是什么，但你必须向前走。</strong> —— 刀剑神域</p></li>
<li><p><strong>一个人决定寂寞，和另一个人相互依偎又有什么错</strong> —— 人渣的本愿</p></li>
<li><p><strong>我可从来不认为恐惧可以成为舍弃他人的借口，人不能因为恐惧，就连身为人类的品性都丢掉。</strong> —— 铁甲城的卡巴内瑞</p></li>
<li><p><strong>你知道吗？从人眼的高度能看到的地平线，是离自身的距离大约是4公里。</strong> —— 青春猪头少年不会梦到兔女郎学姐</p></li>
<li><p><strong>梦想是一个天真的词，实现梦想是一个残酷的词</strong> —— 哆啦A梦</p></li>
<li><p><strong>既然今天是昨天，那么睡到明天就好。</strong> —— 青春猪头少年不会梦到兔女郎学姐</p></li>
<li><p><strong>做不到的事没必要勉强去做，不也挺好吗？</strong> —— 青春猪头少年不会梦到兔女郎学姐</p></li>
<li><p><strong>给我高高的飞起来啊！</strong> —— 星游记</p></li>
<li><p><strong>要是眼睁睁的看着重要的同伴死去，就算是死，我也不能瞑目。</strong> —— 家庭教师</p></li>
<li><p><strong>你的败因只有一个，就是与我为敌。 -</strong> —— 家庭教师</p></li>
<li><p><strong>如果真是这样， 就由我来把彭格列毁灭！</strong> —— 家庭教师</p></li>
<li><p><strong>十代目的意志就是我们的意志！</strong> —— 家庭教师</p></li>
<li><p><strong>但我拒绝！我岸边露伴最喜欢的事情之一，就是向那些自以为是的家伙说，NO！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>人类的赞歌就是勇气的赞歌！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>大家都是伪善者，世间充斥着不真实。</strong> —— 无头骑士异闻录</p></li>
<li><p><strong>不服从命令的人是人渣，抛弃同伴的人连人渣都不如。</strong> —— 火影忍者</p></li>
<li><p><strong>砸瓦鲁多！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>背后即是祖国，我们无路可退。</strong> —— 那年那兔那些事</p></li>
<li><p><strong>不能输，笑吧！</strong> —— 约定的梦幻岛</p></li>
<li><p><strong>不管是怎样的回忆，都是我们活过的人生。</strong> —— Angel Beats!</p></li>
<li><p><strong>孤独的我们才有人类的样子。</strong> —— Angel Beats!</p></li>
<li><p><strong>声起立华乐独奏，曲末音无心结弦。</strong> —— Angel Beats!</p></li>
<li><p><strong>不愿意的时候，逃跑也没有关系！</strong> —— 灵能百分百</p></li>
<li><p><strong>邪王真眼是最强的</strong> —— 中二病也要谈恋爱</p></li>
<li><p><strong>大部分人并不想长大 只是没办法继续当一个小孩子。</strong> —— 小林家的龙女仆</p></li>
<li><p><strong>从开始的第一天起，就回不去了。</strong> —— 流浪地球</p></li>
<li><p><strong>欧拉欧拉欧拉欧拉！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>一举一动，都是承诺，会被另一个人看在眼里，记在心上的。</strong> —— 悬崖上的金鱼姬</p></li>
<li><p><strong>人各有命，上天注定。有人天生为王，有人落草为寇。脚下的路，如果不是自己的选择，那旅程的终点在哪儿，也没人知道，你会走到哪儿，会碰到谁，都不一定。</strong> —— 镇魂街</p></li>
<li><p><strong>成一事者，是失之不渝的愚者；毁一事者，是停滞不前的贤者。</strong> —— 不正经的魔法讲师</p></li>
<li><p><strong>到底是，为什么呢？</strong> —— 金木研</p></li>
<li><p><strong>我爱你，与你何干？</strong> —— 歌德</p></li>
<li><p><strong>即使我弱了，也并不代表你强了</strong> —— 魔法禁书目录 第二季</p></li>
<li><p><strong>正因为有了音乐，才有了相遇的瞬间，有了相会的感动，有了相逢的人们，有了邂逅的思念。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>你驻足于春色中，于那独一无二的春色之中。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>每当心情郁闷的时候，用手托腮就好，手臂会因为帮上忙而开心的。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>你的所言所行，全都闪烁着光芒，太过刺目，于是我闭上双眼，但内心还是无法停止对你的憧憬。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前途。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>九月是蒲公英漫飞的季节，我喜欢这个季节，只可惜今天是九月的最后一天了</strong> —— 我是江小白</p></li>
<li><p><strong>不辜负年华，做自己想做的事，唱自己想唱的歌</strong> —— 我是江小白</p></li>
<li><p><strong>世间有很多事情，人们无法从它寂静的表象，猜测到暗涌，就像一个人和另一个人的相遇</strong> —— 我是江小白</p></li>
<li><p><strong>用我那牵强的微笑，活出无人能比的骄傲。</strong> —— 黑执事</p></li>
<li><p><strong>人类的赞歌就是勇气的赞歌</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>我没有任何理由为了那些人让自己的人生付之一炬！</strong> —— 三月的狮子</p></li>
<li><p><strong>但是，我没有后悔，不能后悔，因为，我所做的事情一定没有错！</strong> —— 三月的狮子</p></li>
<li><p><strong>相信奇迹的人，本身就和奇迹一样了不起。</strong> —— 星游记</p></li>
<li><p><strong>即使天无雨，我亦留此地。</strong> —— 言叶之庭</p></li>
<li><p><strong>有些梦想虽然遥不可及，但不是不可能实现。只要我足够的强。</strong> —— 秦时明月</p></li>
<li><p><strong>有一天，你到了人类的世界，不要去爱上一个人，因为，爱上一个人，会让你真正变成孤单一人。</strong> —— 朝花夕誓</p></li>
<li><p><strong>经为流逝的日月。纬为人们的生业。</strong> —— 朝花夕誓</p></li>
<li><p><strong>悲痛的事，温柔以对；难过的事，坚强以对。</strong> —— 朝花夕誓</p></li>
<li><p><strong>叫做妈妈的人，是不会哭的。</strong> —— 朝花夕誓</p></li>
<li><p><strong>每一个兔子都有一个大国梦</strong> —— 那年那兔那些事</p></li>
<li><p><strong>乘上与平时相反的列车，为了去见从未见过的风景。</strong> —— 比宇宙更远的地方</p></li>
<li><p><strong>我不做人了！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>我是否住进了某人的心房呢？</strong> —— 四月是你的谎言</p></li>
<li><p><strong>那么难受，那么痛苦，可是 世界这么美丽...让我如何能够忘记！</strong> —— 朝花夕誓</p></li>
<li><p><strong>雁过拔毛，兽走留皮。涂山，我罩的，懂？</strong> —— 狐妖小红娘</p></li>
<li><p><strong>那天，我见过的最强剑客，提起了天下最强的宝剑······却早已没了剑心。</strong> —— 狐妖小红娘</p></li>
<li><p><strong>知识是很美的，它们可以让你不出家门就了解这世上的许多事。</strong> —— 妖精的尾巴</p></li>
<li><p><strong>尽情的依靠我吧，因为总有一天我也会依靠你的。</strong> —— 妖精的尾巴</p></li>
<li><p><strong>电助！凉子，看到了吗！</strong> —— 电脑线圈</p></li>
<li><p><strong>I met the girl under full-bloomed cherry blossoms, and my fate has begun to change.</strong> —— 四月是你的谎言</p></li>
<li><p><strong>不相信自己的人，连努力的价值都没有。</strong> —— 火影忍者</p></li>
<li><p><strong>我一点也不走运。</strong> —— Fairy gone</p></li>
<li><p><strong>我从未让你们骄傲，你们却待我如宝。</strong> —— Az殇芯的chx</p></li>
<li><p><strong>错的不是我，而是这个世界！</strong> —— 东京喰种</p></li>
<li><p><strong>你驻足于春色中，于那独一无二的春色之中。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>和她相遇的瞬间，我的人生就改变了。所见所闻所感，目之所及全都开始变得多姿多彩起来。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>やり遂げたよ、最後まで。</strong> —— ラブライブ</p></li>
<li><p><strong>要把所有的夜归还给星河，把所有的春光归还给疏疏篱落，把所有的慵慵沉迷与不前，归还给过去的我。</strong> —— 德卡先生的信箱</p></li>
<li><p><strong>总有一天，我要撕碎这片虚伪的星空。</strong> —— 黑之契约者</p></li>
<li><p><strong>那么，开始实验吧！</strong> —— 假面骑士Build</p></li>
<li><p><strong>我看到这个世界的恶意，我们正在接受考验。</strong> —— 机动战士高达00</p></li>
<li><p><strong>喜欢上一个人就是变得束手无策。</strong> —— 悠久之翼2</p></li>
<li><p><strong>所谓人，无论是谁到了最后，都会形单影只。</strong> —— 悠久之翼2</p></li>
<li><p><strong>长大了，才能体会什么是责任！</strong> —— 家庭</p></li>
<li><p><strong>你是否会等待着我?我还想变的更加完美...</strong> —— LoveLive!Sunshine!</p></li>
<li><p><strong>我只是想要得到「我没有逃避」的记忆吧。</strong> —— 三月的狮子</p></li>
<li><p><strong>人生海海，敢死不叫勇气，活着才需要勇气。</strong> —— 麦家-人生海海</p></li>
<li><p><strong>我无知又愚蠢，世界残酷又疯狂。</strong> —— 进击的巨人</p></li>
<li><p><strong>我的面包！</strong> —— Clannad</p></li>
<li><p><strong>是我，是我先，明明都是我先来的，接吻也好，拥抱也好，还是喜欢上那家伙也好。</strong> —— 白色相簿2</p></li>
<li><p><strong>一旦醉心于狩猎，不到最后关头不会发现自己才是猎物。</strong> —— 来自新世界</p></li>
<li><p><strong>人类这种生物，不管有过多少不得不伴着泪水吞咽的教训，只要过了咽喉，所有教训便又会被彻底遗忘。</strong> —— 来自新世界</p></li>
<li><p><strong>即使我变弱了，也不代表你变强了。</strong> —— 魔法禁书目录</p></li>
<li><p><strong>喜欢和不讨厌之间可是有着数亿光年的距离的。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>痛苦着痛苦着，满脑子只能想我的事。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>我拼命地挣扎，我对活下去的执著，都是因为你，是你让我，对和你一起度过的那段时光无比留恋。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>站起来！站起来啊！你是我的腿吧！站起来啊！</strong> —— 四月是你的谎言</p></li>
<li><p><strong>我不甘心，明明你为我做了那么多，我却什么都不能为你做。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>等着我，有马，不对，别回头，向前进，你要一直向前，我一定会追上来的。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>就此分别吧！请继续向前，迎接樱花漫溢的四月，但请不要忘记我，友人A……</strong> —— 四月是你的谎言</p></li>
<li><p><strong>那里还有——医生的房间啊！</strong> —— Fate / Grand Order</p></li>
<li><p><strong>因为我...我希望不做任何的努力，让对方喜欢上最真实的我。</strong> —— 女高中生的无所事事</p></li>
<li><p><strong>没有一封信是不必被送达的。</strong> —— 紫罗兰永恒花园</p></li>
<li><p><strong>我觉得，不改变也很好。</strong> —— 来自风平浪静的明天</p></li>
<li><p><strong>痴情的妖怪啊,请再等一世吧。</strong> —— 狐妖小红娘</p></li>
<li><p><strong>你从我的手中展翅高飞，我深受打击。在这世上的某处，再次寻找崭新的你的影子，那就是我们之间的美好结局。</strong> —— 骚动时节的少女们啊</p></li>
<li><p><strong>一旦你尝试过天空的味道，你就会永远向上仰望</strong> —— 列奥那多·达芬奇</p></li>
<li><p><strong>人间不温柔</strong> —— 李诞</p></li>
<li><p><strong>知道和感觉到是两码事。</strong> —— 《看见》</p></li>
<li><p><strong>只要学不死，就往死里学。</strong> —— 网络热语</p></li>
<li><p><strong>我是奥尔加·伊滋卡，几颗子弹不要紧的！</strong> —— 机动战士高达：铁血的孤儿</p></li>
<li><p><strong>死亡的尽头，没有神</strong> —— 机动战士高达00:先驱者的觉醒</p></li>
<li><p><strong>只要能和大家一起唱歌，大概就算毕业以后我们分开了，只要听见这首歌就能回想起现在。</strong> —— TARI TARI</p></li>
<li><p><strong>我没能说出口，不管是那句「我走了」，还是那句「对不起」，或者那句「谢谢」...</strong> —— TARI TARI</p></li>
<li><p><strong>现世为梦，夜梦为真。</strong> —— 《xxxholic》</p></li>
<li><p><strong>隐约雷鸣阴霾天空即使风无雨我亦留此地</strong> —— 言叶之庭</p></li>
<li><p><strong>今天不想做，所以才要做</strong> —— 春上村树</p></li>
<li><p><strong>嗯，明白。我们是天人的Gundam Meister</strong> —— 机动战士高达00</p></li>
<li><p><strong>不动身的话就永远无法追寻，哪怕是休息也不会就此停下。</strong> —— Aqours</p></li>
<li><p><strong>朝着下一道光芒横渡大海吧！</strong> —— Aqours</p></li>
<li><p><strong>这个世界啊，很美丽的，很广大的，很辽阔的！</strong> —— Darling in the FRANXX</p></li>
<li><p><strong>我对Darling啊，最喜欢了。我们从今以后，都要在一起哦。</strong> —— Darling in the FRANXX</p></li>
<li><p><strong>为了传达不到的思念而苦恼，只会感到痛不欲生。</strong> —— WHITE FIRST LOVE</p></li>
<li><p><strong>千军万马滚滚来，不知何人留情怀！</strong> —— Other</p></li>
<li><p><strong>用决斗......给大家......带来笑容......</strong> —— 游戏王<A-RCV></p></li>
<li><p><strong>别人的看法都是狗屁，你是谁只有你自己说了才算，这是爹教我的道理。</strong> —— 哪吒之魔童降世</p></li>
<li><p><strong>或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路。</strong> —— 四月是你的谎言</p></li>
<li><p><strong>这个世上没有无用的齿轮，也只有齿轮本身能决定自己的用途。</strong> —— 嫌疑人x的献身</p></li>
<li><p><strong>光就是羁绊之力，它会再度被某人继承，散发出耀眼的光。</strong> —— 奈克瑟斯奥特曼</p></li>
<li><p><strong>人们渴望像鸟儿一样自由自在地飞翔，可他们并没有想过，鸟儿也并不自由，它们之所以飞翔，是为了生存。</strong> —— 奈克瑟斯奥特曼</p></li>
<li><p><strong>记忆是不会消失的，只是一时想不起来了而已。</strong> —— 千与千寻</p></li>
<li><p><strong>我不借助别人的力量就没办法跟仰慕的人聊天吗？</strong> —— 女高中生的虚度日常</p></li>
<li><p><strong>强韧，无敌，最强！玉碎，粉碎，大喝彩！</strong> —— 海马濑人</p></li>
<li><p><strong>人的好意是沉重的。</strong> —— 黑神</p></li>
<li><p><strong>我们所度过的每个平凡的日常，也许就是连续发生的奇迹。</strong> —— 日常</p></li>
<li><p><strong>我最喜欢三月的风，四月的雨，不落的太阳和最好的你</strong> —— 闺密</p></li>
<li><p><strong>在末日中，人们总想寻找希望，但要真有希望的话，那还叫希望吗？</strong> —— 灵笼</p></li>
<li><p><strong>可爱即是正义。</strong> —— 游戏人生</p></li>
<li><p><strong>在末日中，人们总想寻找希望，但要真有希望的话，那还叫末日吗？</strong> —— 灵笼</p></li>
<li><p><strong>只要抗争下去就能带来奇迹，这是恐怖分子的教诲，你给我记清楚了。</strong> —— 未来日记</p></li>
<li><p><strong>相信奇迹的人本身就和奇迹一样了不起啊</strong> —— 星游记</p></li>
<li><p><strong>人类的赞歌就是勇气的赞歌。</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>你们腌太监也不会动人脑子啊！</strong> —— 铁心搏奕</p></li>
<li><p><strong>这是你所不能理解的，人类感情的极致，比希望更热烈，比绝望更深邃——爱！</strong> —— 魔法少女小圆新篇</p></li>
<li><p><strong>我不要你觉得，我要我觉得。</strong> —— 中餐厅</p></li>
<li><p><strong>神啊，求求你。已经足够了。已经没事了。我们都会熬过去的。</strong> —— 天气之子</p></li>
<li><p><strong>自古以来，天空上就是另一个世界。</strong> —— 天气之子</p></li>
<li><p><strong>在东京的天空上，我们决定性的改变了世界的模样。</strong> —— 天气之子</p></li>
<li><p><strong>向天空拼命伸出的双手，发射那么巨大的东西，只是为了寻找超出想象的彼岸所存在的东西。</strong> —— 秒速五厘米</p></li>
<li><p><strong>你是否会等待着我？我会变得更加完美！</strong> —— Aqours</p></li>
<li><p><strong>さあ，Games始めましょうか</strong> —— 游戏人生</p></li>
<li><p><strong>被一个自己不感兴趣的人示好，你不觉得没有比这更恶心的事吗</strong> —— 人渣的本愿</p></li>
<li><p><strong>世界上所有的不利状况都是因为当事者的能力不足</strong> —— 东京喰种</p></li>
<li><p><strong>在虚构现实里寻求现实感的人才有问题</strong> —— 凉宫春日的忧郁</p></li>
<li><p><strong>Ex - ploooosion !</strong> —— 为美好的世界献上祝福</p></li>
<li><p><strong>是我，是我先，明明都是我先来的……接吻也好，拥抱也好，还是喜欢上那家伙也好</strong> —— 白色相簿2</p></li>
<li><p><strong>没有一个世界会比活在这个世界痛苦</strong> —— 黑岩射手</p></li>
<li><p><strong>如果把那一端的敌人全部杀掉的话，我们就能自由了吗？</strong> —— 进击的巨人</p></li>
<li><p><strong>今后我们来度过满是愉快之事的人生吧</strong> —— Charlotte</p></li>
<li><p><strong>如果一切都是镜花水月，那就让这万物走向终结。如果一切皆是命中注定，那就让这世界消失殆尽。</strong> —— 失落的歌谣</p></li>
<li><p><strong>能够用自己喜欢的工作维持生活是件很幸福的事情</strong> —— 白箱</p></li>
<li><p><strong>有的鱼是永远关不住的，因为他们属于天空。</strong> —— 大鱼海棠</p></li>
<li><p><strong>我会化作人间的风雨陪在你的身边</strong> —— 大鱼海棠</p></li>
<li><p><strong>你以为你接受的是谁的爱，是一个天神的爱！他背叛所有神灵去爱你，为你忍受一切痛苦。</strong> —— 大鱼海棠</p></li>
<li><p><strong>深藏不露是一种卓越的才能</strong> —— 欢迎来到实力至上主义的教室</p></li>
<li><p><strong>这样叹气的话，幸福会像四处逃散的小蜘蛛一样溜走的。</strong> —— 辉夜大小姐想让我告白</p></li>
<li><p><strong>世上所以不公平之事是由于当事人能力不足所致。</strong> —— 金木研</p></li>
<li><p><strong>雨滴降落的速度是每秒十米，我该用怎么样的速度，才能将你挽留？</strong> —— 言叶之庭</p></li>
<li><p><strong>樱花落下的速度是每秒五厘米， 我该用怎么样的速度，才能与你相遇。</strong> —— 秒速五厘米</p></li>
<li><p><strong>如果当时我们说了再见，后来是不是就可以再见</strong> —— 昨日青空</p></li>
<li><p><strong>音无结弦之日 跃动天使之心 立于浮华之世 奏响天籁之音</strong> —— Angel Beats!</p></li>
<li><p><strong>温柔正确的人总是难以生存，因为这世界既不温柔，也不正确。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>我一直注视着你，似近，似远。但你永远，看不见我……</strong> —— 来自风平浪静的明天</p></li>
<li><p><strong>与其被人扯碎校服，撕破心灵，倒不如直接剁碎自己的躯体，来得痛快。</strong> —— 黑岩射手</p></li>
<li><p><strong>目标是以科学的力量凌驾于超能力之上，为了伯伦希尔的荣耀。</strong> —— 小绿和小蓝</p></li>
<li><p><strong>这东西是越嚼越有味哦~</strong> —— BanG Dream! 2nd Season</p></li>
<li><p><strong>即使再也没有晴天也没有关系.</strong> —— 天气之子</p></li>
<li><p><strong>我一直以为最糟糕的情况是你离开我，其实最令我难过的，是你不快乐。</strong> —— 精灵旅社</p></li>
<li><p><strong>キラキラ☆ドキドキ</strong> —— 戸山香澄</p></li>
<li><p><strong>我下定决心要当海贼王，就算因此而战死，那也无所谓。</strong> —— 海贼王</p></li>
<li><p><strong>规则是用来被打破的。</strong> —— 机械公敌</p></li>
<li><p><strong>木叶飞舞之处，火亦生生不息</strong> —— 火影忍者</p></li>
<li><p><strong>当我拔出第二把剑时，就是为了我所爱之人</strong> —— 刀剑神域</p></li>
<li><p><strong>你指尖跃动的电光，是我此生不变的信仰，唯我超电磁炮永世长存。</strong> —— 某科学的超电磁炮</p></li>
<li><p><strong>遇事不决，量子力学。</strong> —— 青春期猪头少年不会梦到兔女郎学姐</p></li>
<li><p><strong>我们终会相遇相知，在那悠远的苍穹。</strong> —— 缘之空</p></li>
<li><p><strong>Star Burst Stream!</strong> —— 刀剑神域</p></li>
<li><p><strong>虽然想做一团火，却成了一块透视苦难的冰</strong> —— 卡夫卡研究</p></li>
<li><p><strong>生命可以随心所欲，但不能随波逐流</strong> —— 猫的报恩</p></li>
<li><p><strong>我们所度过的每个平凡的日常，也许就是连续发生的奇迹</strong> —— 日常</p></li>
<li><p><strong>加油</strong> —— 自编</p></li>
<li><p><strong>夕阳真是耀眼无比啊。</strong> —— 女高中生的虚度日常</p></li>
<li><p><strong>今天我就要带她走，我看谁敢拦我</strong> —— 刺客伍六七</p></li>
<li><p><strong>这里有你,他现在只有我了。</strong> —— 罗小黑战记</p></li>
<li><p><strong>星空之所以美丽，就是因为在无限的宇宙中，不管黑暗如何蔓延，都有星星的光芒去把它照亮。世界也是这样，有绝望的地方，就会有希望产生。</strong> —— 星游记</p></li>
<li><p><strong>我来做最不想做的事情了。</strong> —— 22/7</p></li>
<li><p><strong>你只见树，未见森林</strong> —— 火影忍者</p></li>
<li><p><strong>你就赌我会死吧，因为你逢赌必输。</strong> —— 火影忍者</p></li>
<li><p><strong>奶奶说过，男人有两件事不能做——绝不能让女孩子流泪和浪费食物。</strong> —— 假面骑士Kabuto</p></li>
<li><p><strong>正因为这样，我才决定任何时候都要尽全力享受人生，这样的话，无论什么时候死去，都是最幸福的一生了吧</strong> —— 恋爱随意链接</p></li>
<li><p><strong>正因为有了所有的过去，才成就了现在的我。否定自己所走过的路途，就意味着否定现在的自己。</strong> —— 恋爱随意链接</p></li>
<li><p><strong>每个人每一天的价值都是完全相等的，无论做什么，都不会改变我今天活着的价值。</strong> —— 我想吃掉你的胰脏</p></li>
<li><p><strong>我这个人呀，能过着这样平凡普通的日子就很开心了。</strong> —— 我想吃掉你的胰脏</p></li>
<li><p><strong>每个人能走到现在，都是自己选择的结果。</strong> —— 我想吃掉你的胰脏</p></li>
<li><p><strong>都说樱花飘落时让人伤感，而我看到樱花盛开也觉得伤感，因为我会计算，我还能再看几次樱花盛开呢。</strong> —— 我想吃掉你的胰脏</p></li>
<li><p><strong>只要人活在这世上就一定是有意义的，怎么活是自己选的。</strong> —— 我想吃掉你的胰脏</p></li>
<li><p><strong>人生，一半是现实，一半是梦想。一念花开，一念花落。</strong> —— 火影忍者</p></li>
<li><p><strong>我希望，我能完全信任你，我还从来没有能这样信任过谁。我也希望，你将给我最大的支持。</strong> —— 安妮日记</p></li>
<li><p><strong>愿你有一天，能和你最重要的人重逢。</strong> —— 可塑性记忆</p></li>
<li><p><strong>告诉我，神会流血吗？——神不会，但你会。</strong> —— 烦人的村民</p></li>
<li><p><strong>さあ、始めようか。(那么，游戏开始吧。)</strong> —— No Game No Life</p></li>
<li><p><strong>我讨厌温柔的女孩子，温柔的女孩子其实对所有人都温柔，而我却会误以为只对自己温柔，然后沾沾自喜得意忘形，最后弄得不欢而散，双方都受到伤害，所以我才讨厌温柔的女孩子。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>无知而又纯洁的岁月。是任何人都曾拥有的。世界上没有一成不变的事务。所以只要以其他方式找到自己的快乐就行了。</strong> —— CLANNAD</p></li>
<li><p><strong>粉色蓝宝石的宝石语是「献给弱者的正义」。</strong> —— 宝石商人理查德的谜鉴定</p></li>
<li><p><strong>喂，前面可是地狱啊！おい、この先は地狱だぜ！</strong> —— Fate/stay night</p></li>
<li><p><strong>Steel is my body, and fire is my blood.</strong> —— Fate/stay night</p></li>
<li><p><strong>游龙当归海，海不迎我自来也。</strong> —— 火影鸣人</p></li>
<li><p><strong>孩子，我愿意为你而前行。</strong> —— 灵笼</p></li>
<li><p><strong>世界上一切不利状况，都是因为当事人的能力不足。</strong> —— 东京食尸鬼</p></li>
<li><p><strong>隐约雷鸣，阴霾天空，即使天无雨，我亦留此地。</strong> —— 言叶之庭</p></li>
<li><p><strong>没有未来的未来不是我想要的未来。</strong> —— 境界的彼方</p></li>
<li><p><strong>只要怀着理想而行动，就算结果不尽如人意也没有关系。但是如果失去了理想，那就真的一无所有了，连自己珍视的人都保护不了。</strong> —— 境界的彼方</p></li>
<li><p><strong>我喜欢你，比这个世界上其他任何人都喜欢你，我永远都会喜欢你的。只有我的这份心情是不会输给任何人的，即使我的这个身体毁灭了、从世界上消失了，来世我肯定还是会喜欢上你的。</strong> —— 境界的彼方</p></li>
<li><p><strong>愿有朝一日与你见面还能释放温暖拥你入怀。</strong> —— 境界的彼方</p></li>
<li><p><strong>已经没什么好害怕了。</strong> —— 魔法少女小圆</p></li>
<li><p><strong>声起立华乐独奏，曲末音无心结弦。</strong> —— Angel Beats!</p></li>
<li><p><strong>总在不停寻觅你的踪影，无论十字路口抑或梦境之中，明知你不在，却依然不停地找寻。</strong> —— 秒速5厘米</p></li>
<li><p><strong>只要引导着二人的两把命运之剑还在身边，我们就绝不会失败。</strong> —— 刀剑神域</p></li>
<li><p><strong>这虽然这是游戏，但可不是闹着玩的。</strong> —— 刀剑神域</p></li>
<li><p><strong>花开得太好，所以摇摇欲坠；这一切的事情，老得这样快；世间一直熙攘着。</strong> —— 素年锦时</p></li>
<li><p><strong>人要意识到自己过得悲哀，需要很长时间；要意识到其实不必如此，则需要更久。</strong> —— 马男波杰克</p></li>
<li><p><strong>从这里（太空）根本看不到什么国境线，只有地球。</strong> —— 星空清理者</p></li>
<li><p><strong>你那无聊的幻想，就由我来打破！</strong> —— 魔法禁书目录</p></li>
<li><p><strong>正义不是行使武力的理由，而是正相反——为了将动武的理由正当化，人们才会高喊正义。</strong> —— 末日时在做什么？有没有空？可以来拯救吗？</p></li>
<li><p><strong>君子无争，含光无形，坐忘无心。</strong> —— 秦时明月</p></li>
<li><p><strong>我在这里只学会一件事，那就是不到最后绝不轻言放弃。如果回到了现实世界，我一定会再度和桐人你相遇，然后重新喜欢上你。</strong> —— 刀剑神域</p></li>
<li><p><strong>最近我很喜欢明天见这句话，因为只要许下约定，就能期待明天的到来。</strong> —— 结城友奈是勇者</p></li>
<li><p><strong>就算没有意义，偶尔也会有好事发生。</strong> —— 终末少女旅行</p></li>
<li><p><strong>你将不再是道具，而是成为人如其名的人。</strong> —— 紫罗兰的永恒花园</p></li>
<li><p><strong>大家热爱的事物，擅长的事物都不同，都拥有自己的世界，一个人一个世界，这些互相连接的话，就会展开许多的可能性，广大、未知，就像是宇宙一样。</strong> —— 恋爱小行星</p></li>
<li><p><strong>无论人生过得怎么样，都不要失去自己活着的意义，努力的去追逐心中的梦想，留下自己曾经在这个世界活过的痕迹，不要等到一切都失去了才追悔莫及。</strong> —— 天使的心跳</p></li>
<li><p><strong>人生没有那么多预算，不要等到到死后世界叹息，珍惜眼前所有。相信每天都是新的开始，都充满希望.</strong> —— 天使的心跳</p></li>
<li><p><strong>真真需要记住的不是立华奏，而是天使身体里跳动的那颗永不结弦之心。</strong> —— 天使的心跳</p></li>
<li><p><strong>人总有一天会孤独一人，然后活在自己的回忆中。为了能笑着于孤独相依为命，我决定战斗下去，决定不会再以泪洗面。</strong> —— 天使的心跳</p></li>
<li><p><strong>与绝望~和睦相处。</strong> —— 少女终末旅行</p></li>
<li><p><strong>人类的赞歌是勇气的赞歌，人类的伟大是勇气的伟大！</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>孤独的人不会伤害别人，只会不断地伤害自己罢了。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>枷锁，自然规律，时光的流逝，名为身体的容器，名为心灵的自我。</strong> —— 四月一日灵异事件薄</p></li>
<li><p><strong>没事没事，不同朋友擅长的事情也不同。</strong> —— 兽娘动物园</p></li>
<li><p><strong>如果有人对我说抱有希望是错误的花，我会无数次回答“不是这样的”，无论什么时候都一定会这样撑下去。</strong> —— 魔法少女小圆</p></li>
<li><p><strong>这么温暖的世界里有我，要感谢神明了。</strong> —— Comic Girls</p></li>
<li><p><strong>Don't forget. Always,somewhere,someone is fighting for you. As long as you remember her,you are not alone.</strong> —— 魔法少女小圆</p></li>
<li><p><strong>这就是人类感情的极致，比希望更炽热，比绝望更深邃的，爱哟！</strong> —— 魔法少女小圆</p></li>
<li><p><strong>露珠落去花留着，花萎露珠未消去。奈何露已随风去，花间寻觅不见珠。</strong> —— 学园孤岛</p></li>
<li><p><strong>波，高低起伏的东西；波，产生后开始扩散；波，自己无法抵抗的东西。</strong> —— 四月一日灵异事件薄</p></li>
<li><p><strong>在這手心之中的，就是“心”啊。</strong> —— 死神</p></li>
<li><p><strong>木叶飞舞之处，火亦生生不息。</strong> —— 火影忍者</p></li>
<li><p><strong>你以为我是谁？这是我埋下的因，我要亲手解决这一切。</strong> —— 某科学的超电磁炮</p></li>
<li><p><strong>只要呼唤你的名字，我们的牵绊就永远不会消逝。</strong> —— 紫罗兰永恒花园外传：永远与自动手记人偶</p></li>
<li><p><strong>我也许能再一次找到活着的目的，也许能再一次找到活着的意义，为了那些人，奉献出我的人生的话……</strong> —— Angelbeats</p></li>
<li><p><strong>别低下头 排球是一门积极向上的运动！</strong> —— 排球少年</p></li>
<li><p><strong>理解何为孤单，努力想得到爱的你，内心的悲伤是否稍微宣泄了呢？</strong> —— 夏目友人帐</p></li>
<li><p><strong>自己不经意的一句话，触动了别人的心。</strong> —— 恋如雨止</p></li>
<li><p><strong>游荡的孤高灵魂不需要羁绊之处。</strong> —— 我的青春恋爱物语果然有问题</p></li>
<li><p><strong>如果说现在的日子过得很穷困，那我就去喜欢上穷困。</strong> —— 隐瞒之事</p></li>
<li><p><strong>人和人之间就像这风筝一样，拉的太紧就飞不远，放的太松又掉下来，而当它飞的很高很高你还拽着不放，它就有可能会断掉，再也回不来了。</strong> —— 灵契</p></li>
<li><p><strong>一日为灵，终生为影，灵气共生，魂命无分，阴阳调和，万物皆宁。</strong> —— 灵契</p></li>
<li><p><strong>端木熙，别忘了，你是我的祭司，谁也别来跟我争，他神龙章轩不可以，神也不行。</strong> —— 灵契</p></li>
<li><p><strong>从今往后，你不能斩的人我来斩，你不能伤的人我来杀，既然你要保护这个世界，那我便保护你，这就是我的信念！</strong> —— 灵契</p></li>
<li><p><strong>千载流年一如梦，月落山河一世倾。</strong> —— 灵契</p></li>
<li><p><strong>不可结缘，徒留寂寞……</strong> —— 夏目友人帐</p></li>
<li><p><strong>一代锤子一代皇，代代锤子教做人！</strong> —— 斗罗大陆</p></li>
<li><p><strong>花早晚会凋谢，记忆最终也会消散。</strong> —— 镇魂街</p></li>
<li><p><strong>所谓首领，只不过是被势力绑架上制高点的走狗而已。而且，都是身不由己的走狗。</strong> —— 狐妖小红娘</p></li>
<li><p><strong>无论是人类还是妖怪，只要内心希望他人接触，那么就是相同的存在；会因独处而感到寂寞，也会害怕踏出第一步。</strong> —— 夏目友人帐</p></li>
<li><p><strong>未来始终掌握在自己手中，从中滑落的，我们称之为过去。</strong> —— 末日时在做什么？有没有空？可以来拯救吗？</p></li>
<li><p><strong>我不努力，就见不到你了啊。</strong> —— 昨日之歌</p></li>
<li><p><strong>无可取代的东西要到失去后才知道珍惜呢。</strong> —— 干物妹小埋</p></li>
<li><p><strong>没有什么背叛，只不过是忠诚过期了而已。</strong> —— 凹凸世界</p></li>
<li><p><strong>Ko no Dio da!</strong> —— JOJO的奇妙冒险</p></li>
<li><p><strong>我们不是大人，而是同学吧。</strong> —— 恋如雨止</p></li>
<li><p><strong>今天的我，凌驾于阿修罗之上！</strong> —— 机动战士高达00</p></li>
<li><p><strong>Exia，驱逐目标！</strong> —— 机动战士高达00</p></li>
<li><p><strong>花无凋零之时，爱无传达之期，爱情亘古不变，紫罗兰永世长存。</strong> —— 紫罗兰永恒花园</p></li>
<li><p><strong>相比昨日明日，今天更适合开始。</strong> —— Comic Girls</p></li>
<li><p><strong>呐~~凯利，你想成为怎样的大人。</strong> —— Fate/Zero</p></li>
<li><p><strong>当敌人变成战友多半是为了生存，而战友变成敌人多半是为了金钱。</strong> —— 端脑</p></li>
<li><p><strong>正因为听不见和看不到，所以风子才会做这样的事情。</strong> —— Clannad</p></li>
<li><p><strong>我们开始一起攀登，这长长的，长长的坡道。</strong> —— Clannad</p></li>
<li><p><strong>无知而又纯洁的岁月是任何人都曾拥有的，世界上没有一成不变的事物，所以只要以其他方式找到自己的快乐就行了。</strong> —— Clannad</p></li>
<li><p><strong>前天是小兔子，昨天是小鹿，今天是你。</strong> —— Clannad</p></li>
<li><p><strong>能哭的地方只有厕所和爸爸的怀里。</strong> —— Clannad</p></li>
<li><p><strong>美好的事情，现在才开始呐。</strong> —— Clannad</p></li>
<li><p><strong>什么叫忍者？学会忍耐的人就叫忍者。</strong> —— 哔哩哔哩</p></li>
</ul>
]]></content>
      <tags>
        <tag>持续更新</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Mst | BZOJ 2238</title>
    <url>/BZ2238/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://darkbzoj.tk/problem/2238">题目链接</a><br />
给出 <span class="math inline">\(n\)</span> 个点，<span class="math inline">\(m\)</span> 条边的无向带权图，<span class="math inline">\(q\)</span> 次询问，询问在图中删掉一条边后的 <span class="math inline">\(\text{MST}\)</span> 的边权和。询问独立。<br />
<span class="math inline">\(n \leq 5 \times 10^4, m \leq 10^5\)</span>。</p>
</blockquote>
<p>记原图的 <span class="math inline">\(\text{MST} = (E_{\text{MST}}, V_{\text{MST}})\)</span>。</p>
<p>对于 <span class="math inline">\(e(u, v, w) \not \in E_{\text{MST}}\)</span>（下文称为非树边），将它删去后显然不会对答案造成任何影响。</p>
<p>对于 <span class="math inline">\(e(u, v, w) \in E_{\text{MST}}\)</span>（下文称为树边），将它删去后，为了使得点 <span class="math inline">\(u, v\)</span> 仍然连通，我们必须要找一条非树边代替之，且这条非树边 <span class="math inline">\(e&#39;(u&#39;, v&#39;, w&#39;)\)</span> 所连接的顶点 <span class="math inline">\((u&#39;, v&#39;)\)</span>，在 <span class="math inline">\(\text{MST}\)</span> 上的路径必定覆盖了 <span class="math inline">\((u, v)\)</span>。</p>
<p>自然的，我们想到枚举每一条非树边，并将其所连接的两个节点在 <span class="math inline">\(\text{MST}\)</span> 上的路径中的所有树边更新。</p>
<p>更具体的，记 <span class="math inline">\(f_e\)</span>（其中 <span class="math inline">\(e\)</span> 为一条树边）为能代替 <span class="math inline">\(e\)</span> 的非树边的最小权值。一开始 <span class="math inline">\(f_e = +\infty\)</span>。对于枚举到的非树边 <span class="math inline">\(e&#39;(u&#39;, v&#39;, w&#39;)\)</span>，更新所有 <span class="math inline">\(e \in E&#39;\)</span>（其中 <span class="math inline">\(E&#39;\)</span> 代表 <span class="math inline">\((u&#39;, v&#39;)\)</span> 在 <span class="math inline">\(\text{MST}\)</span> 上的路径）的 <span class="math inline">\(f_e \leftarrow \min(f_e, w&#39;)\)</span>。</p>
<p>问题转化为如何维护这个过程。</p>
<p>一个经典的解法是利用树链剖分与线段树，网络上大多数的题解也是如此。不过这样做的复杂度是 <span class="math inline">\(O(n \log^2 n)\)</span> 的，且代码长度较长。</p>
<p>我们采用一种码量更少，复杂度更为优秀的 <span class="math inline">\(O(n \log n)\)</span> 算法，树上倍增来解决。</p>
<p>记录倍增数组 <span class="math inline">\(\text{fa}(u, k)\)</span> 表示 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(2^k\)</span> 级祖先。</p>
<p>令标记 <span class="math inline">\(\text{tag}(u, k)\)</span> 表示从 <span class="math inline">\(u\)</span> 到其 <span class="math inline">\(2^k\)</span> 级祖先的链上被更新的延时标记。易知整个算法就是要回答 <span class="math inline">\(\text{tag}(u, 0)\)</span>。</p>
<p>考虑倍增求 LCA 的过程，同样的，我们不断从 <span class="math inline">\(u&#39;, v&#39;\)</span> 向上跳，直到相遇，同时打上标记即可。</p>
<p>最后将标记下传，即</p>
<p><span class="math display">\[\text{tag}(u, i - 1) \leftarrow \min(\text{tag}(u, i - 1), \text{tag(u, i)})\\ \]</span> <span class="math display">\[\text{tag}(\text{fa}(u, i - 1), i - 1) \leftarrow \min(\text{tag}(\text{fa}(u, i - 1), i - 1), \text{tag}(u, i))\]</span></p>
<p>感性理解起来就是将 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(\text{fa}(u, i)\)</span> 的标记下传给上下两半。</p>
<p>至此，对于删除树边 <span class="math inline">\(e(u, v, w)\)</span>，其答案为:</p>
<p><span class="math display">\[
\text{MST}_w - w + \text{tag}(u, 0)
\]</span></p>
<p>（这里我们假设 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(\text{MST}\)</span> 上的深度更深一点）。</p>
<p>代码实现上有一些区别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd(a, b) a = min(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, MI = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* Nc = <span class="string">&quot;Not connected&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, cnt, mst, head[N], d[N], fa[N][<span class="number">16</span>], tag[N][<span class="number">16</span>], dwn[N*<span class="number">2</span>], pr[N], w[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge&amp; b)<span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; b.w; &#125;</span><br><span class="line">&#125; E[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> v, nxt, id; &#125; e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == pr[x] ? x : pr[x] = <span class="built_in">find</span>(pr[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (edge)&#123; v, head[u], id &#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">// 求 d, fa, dwn 数组, dwn[i] 是第 i 条边的下端点 </span></span><br><span class="line">    d[u] = d[fa[u][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">15</span>) fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[dwn[e[i].id] = v][<span class="number">0</span>] = u;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; <span class="comment">// 倍增打标记 </span></span><br><span class="line">    <span class="keyword">if</span>(d[u] &lt; d[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="built_in">per</span>(j, <span class="number">15</span>, <span class="number">0</span>) <span class="keyword">if</span>(d[u] - (<span class="number">1</span> &lt;&lt; j) &gt;= d[v])</span><br><span class="line">        <span class="built_in">upd</span>(tag[u][j], w), u = fa[u][j];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">per</span>(j, <span class="number">15</span>, <span class="number">0</span>) <span class="keyword">if</span>(fa[u][j] != fa[v][j]) &#123;</span><br><span class="line">        <span class="built_in">upd</span>(tag[u][j], w), <span class="built_in">upd</span>(tag[v][j], w);</span><br><span class="line">        u = fa[u][j], v = fa[v][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">upd</span>(tag[u][<span class="number">0</span>], w); <span class="built_in">upd</span>(tag[v][<span class="number">0</span>], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w[i]);</span><br><span class="line">        E[i] = (Edge)&#123; u, v, w[i], i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(E + <span class="number">1</span>, E + m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) pr[i] = i;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="built_in">find</span>(E[i].u), f2 = <span class="built_in">find</span>(E[i].v);</span><br><span class="line">        <span class="keyword">if</span>(f1 == f2) <span class="keyword">continue</span>;</span><br><span class="line">        pr[f2] = f1; mst += E[i].w; </span><br><span class="line">        <span class="built_in">add</span>(E[i].u, E[i].v, E[i].id); <span class="built_in">add</span>(E[i].v, E[i].u, E[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">if</span>(cnt / <span class="number">2</span> &lt; n - <span class="number">1</span>) &#123; <span class="keyword">while</span>(q--) <span class="built_in">puts</span>(Nc); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(tag, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> tag);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) <span class="keyword">if</span>(!dwn[E[i].id]) <span class="built_in">update</span>(E[i].u, E[i].v, E[i].w);</span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">15</span>, <span class="number">1</span>) <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123; <span class="comment">// 标记下传到底 </span></span><br><span class="line">        <span class="built_in">upd</span>(tag[j][i<span class="number">-1</span>], tag[j][i]);</span><br><span class="line">        <span class="built_in">upd</span>(tag[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>], tag[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">        <span class="keyword">if</span>(!dwn[T]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mst);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = tag[dwn[T]][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(Nc);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mst + ans - w[T]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
</search>
