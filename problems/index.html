<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="懒得分开写咕咕咕。 TC13459 “1”的限制分两种，在同一行或在同一列，但 “1” 的数量很多，不能枚举每个“1”是哪一种，设“在同一行”的边为白边，“在同一列的”的边为黑白，考虑边之间的约束关系。 考虑两条边 \((i,j),(i,k)\)，当边 \((j,k)\) 存在时说明 \((i,j)\) 和 \((i,k)\) 的颜色相同，反之亦然。 这样就可以表示出所有的约束，必要性显然，充分性">
<meta property="og:type" content="article">
<meta property="og:title" content="部分题解合集">
<meta property="og:url" content="http://example.com/problems/index.html">
<meta property="og:site_name" content="platelet&#39;s blog">
<meta property="og:description" content="懒得分开写咕咕咕。 TC13459 “1”的限制分两种，在同一行或在同一列，但 “1” 的数量很多，不能枚举每个“1”是哪一种，设“在同一行”的边为白边，“在同一列的”的边为黑白，考虑边之间的约束关系。 考虑两条边 \((i,j),(i,k)\)，当边 \((j,k)\) 存在时说明 \((i,j)\) 和 \((i,k)\) 的颜色相同，反之亦然。 这样就可以表示出所有的约束，必要性显然，充分性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/09/08/4ragjEUYIev5wot.png">
<meta property="og:image" content="https://i.loli.net/2021/09/08/a4fEq6tJWRbrxDy.png">
<meta property="article:published_time" content="2021-09-08T07:09:11.000Z">
<meta property="article:modified_time" content="2021-09-08T07:09:11.000Z">
<meta property="article:author" content="platelet">
<meta property="article:tag" content="platelet">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/09/08/4ragjEUYIev5wot.png">


<link rel="canonical" href="http://example.com/problems/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/problems/","path":"problems/","title":"部分题解合集"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>部分题解合集 | platelet's blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">platelet's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">精于心，简于形</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-template"><a href="/template/" rel="section"><i class="fa fa-code fa-fw"></i>模板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#tc13459"><span class="nav-number">1.</span> <span class="nav-text">TC13459</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tc12909"><span class="nav-number">2.</span> <span class="nav-text">TC12909</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tc13692"><span class="nav-number">3.</span> <span class="nav-text">TC13692</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc017f"><span class="nav-number">4.</span> <span class="nav-text">AGC017F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arc078d"><span class="nav-number">5.</span> <span class="nav-text">ARC078D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tc10727"><span class="nav-number">6.</span> <span class="nav-text">TC10727</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tc10993"><span class="nav-number">7.</span> <span class="nav-text">TC10993</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gym102391e"><span class="nav-number">8.</span> <span class="nav-text">Gym102391E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zoj3970"><span class="nav-number">9.</span> <span class="nav-text">ZOJ3970</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zoj3989"><span class="nav-number">10.</span> <span class="nav-text">ZOJ3989</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A5%E6%BA%90%E4%B8%8D%E6%98%8E%E7%9A%84%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">来源不明的题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arc107f"><span class="nav-number">12.</span> <span class="nav-text">ARC107F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gym101471j"><span class="nav-number">13.</span> <span class="nav-text">Gym101471J</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cf1307f"><span class="nav-number">14.</span> <span class="nav-text">CF1307F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc038e"><span class="nav-number">15.</span> <span class="nav-text">AGC038E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc037d"><span class="nav-number">16.</span> <span class="nav-text">AGC037D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc043d"><span class="nav-number">17.</span> <span class="nav-text">AGC043D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc049d"><span class="nav-number">18.</span> <span class="nav-text">AGC049D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc050d"><span class="nav-number">19.</span> <span class="nav-text">AGC050D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noi2021day1t1"><span class="nav-number">20.</span> <span class="nav-text">NOI2021Day1T1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noi2021day1t2"><span class="nav-number">21.</span> <span class="nav-text">NOI2021Day1T2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noi2021day1t3"><span class="nav-number">22.</span> <span class="nav-text">NOI2021Day1T3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noi2021day2t1"><span class="nav-number">23.</span> <span class="nav-text">NOI2021Day2T1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noi2021day2t2"><span class="nav-number">24.</span> <span class="nav-text">NOI2021Day2T2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noi2021day2t3"><span class="nav-number">25.</span> <span class="nav-text">NOI2021Day2T3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cf1548d2"><span class="nav-number">26.</span> <span class="nav-text">CF1548D2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cf1548e"><span class="nav-number">27.</span> <span class="nav-text">CF1548E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minieye%E6%9D%AF%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B5t1"><span class="nav-number">28.</span> <span class="nav-text">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minieye%E6%9D%AF%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B5t2"><span class="nav-number">29.</span> <span class="nav-text">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minieye%E6%9D%AF%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B5t9"><span class="nav-number">30.</span> <span class="nav-text">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T9</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%9A%E6%B3%95-1"><span class="nav-number">30.1.</span> <span class="nav-text">做法 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%9A%E6%B3%95-2"><span class="nav-number">30.2.</span> <span class="nav-text">做法 2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minieye%E6%9D%AF%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%B6%85%E7%BA%A7%E8%81%94%E8%B5%9B5t13"><span class="nav-number">31.</span> <span class="nav-text">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc041d"><span class="nav-number">32.</span> <span class="nav-text">AGC041D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc027d"><span class="nav-number">33.</span> <span class="nav-text">AGC027D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc025d"><span class="nav-number">34.</span> <span class="nav-text">AGC025D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc036d"><span class="nav-number">35.</span> <span class="nav-text">AGC036D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc045d"><span class="nav-number">36.</span> <span class="nav-text">AGC045D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc041e"><span class="nav-number">37.</span> <span class="nav-text">AGC041E</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E-t1"><span class="nav-number">37.1.</span> <span class="nav-text">对于 \(T&#x3D;1\)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E-t2"><span class="nav-number">37.2.</span> <span class="nav-text">对于 \(T&#x3D;2\)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abc214g"><span class="nav-number">38.</span> <span class="nav-text">ABC214G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abc214h"><span class="nav-number">39.</span> <span class="nav-text">ABC214H</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sol-1"><span class="nav-number">39.1.</span> <span class="nav-text">Sol 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sol-2"><span class="nav-number">39.2.</span> <span class="nav-text">Sol 2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc027e"><span class="nav-number">40.</span> <span class="nav-text">AGC027E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gym101667g"><span class="nav-number">41.</span> <span class="nav-text">Gym101667G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gym101667j"><span class="nav-number">42.</span> <span class="nav-text">Gym101667J</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abc215h"><span class="nav-number">43.</span> <span class="nav-text">ABC215H</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agc020e"><span class="nav-number">44.</span> <span class="nav-text">AGC020E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cf1562e"><span class="nav-number">45.</span> <span class="nav-text">CF1562E</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">45.1.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cf1562f"><span class="nav-number">46.</span> <span class="nav-text">CF1562F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auoj1760"><span class="nav-number">47.</span> <span class="nav-text">AUOJ1760</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="nav-number">48.</span> <span class="nav-text">思路一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="nav-number">49.</span> <span class="nav-text">思路二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%89"><span class="nav-number">50.</span> <span class="nav-text">思路三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auoj1761"><span class="nav-number">51.</span> <span class="nav-text">AUOJ1761</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#codechef-btree"><span class="nav-number">52.</span> <span class="nav-text">CodeChef-btree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sol-1-1"><span class="nav-number">52.1.</span> <span class="nav-text">Sol 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sol-2-1"><span class="nav-number">52.2.</span> <span class="nav-text">Sol 2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ural2118"><span class="nav-number">53.</span> <span class="nav-text">URAL2118</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#graph-subpaths"><span class="nav-number">54.</span> <span class="nav-text">Graph Subpaths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sol-1-2"><span class="nav-number">55.</span> <span class="nav-text">Sol 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sol-2-2"><span class="nav-number">56.</span> <span class="nav-text">Sol 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zoj3390"><span class="nav-number">57.</span> <span class="nav-text">ZOJ3390</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#izho-2020-d1t3"><span class="nav-number">58.</span> <span class="nav-text">IZhO 2020 D1T3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cf566c"><span class="nav-number">59.</span> <span class="nav-text">CF566C</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="platelet"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">platelet</p>
  <div class="site-description" itemprop="description">天地不仁<br>platelet.top | 血小板.top<br>song-jx.github.io</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/problems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="platelet">
      <meta itemprop="description" content="天地不仁<br>platelet.top | 血小板.top<br>song-jx.github.io">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="platelet's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          部分题解合集
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-08 15:09:11" itemprop="dateCreated datePublished" datetime="2021-09-08T15:09:11+08:00">2021-09-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/problems/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="problems/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>56k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>50 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>懒得分开写咕咕咕。</p>
<h3 id="tc13459">TC13459</h3>
<p>“1”的限制分两种，在同一行或在同一列，但 “1” 的数量很多，不能枚举每个“1”是哪一种，设“在同一行”的边为白边，“在同一列的”的边为黑白，考虑边之间的约束关系。</p>
<p>考虑两条边 <span class="math inline">\((i,j),(i,k)\)</span>，当边 <span class="math inline">\((j,k)\)</span> 存在时说明 <span class="math inline">\((i,j)\)</span> 和 <span class="math inline">\((i,k)\)</span> 的颜色相同，反之亦然。</p>
<p>这样就可以表示出所有的约束，必要性显然，充分性是因为合法解中同色边一定构成了若干不含公共点的团，这种对于相邻两条边的约束关系就很充分了。</p>
<p>在所有的约束条件下，所有的边及其约束关系构成类似二分图的结构，联通块分两类，一类是整个连通块一定同色，另一类是一定包含两种颜色。</p>
<p>设第一类连通块有 <span class="math inline">\(x\)</span> 个，第二类连通块有 <span class="math inline">\(y\)</span> 个，枚举第一类连通块有 <span class="math inline">\(i\)</span> 个白色，即可得到答案： <span class="math display">\[
\sum_{i=0}^x\binom xi2^yn^{\underline{i+y}}n^{\underline{x-i+y}}
\]</span> 复杂度 <span class="math inline">\(O(n^3)\)</span>（DFS 求连通块）或 <span class="math inline">\(O(n^3\alpha(n^2))\)</span>（并查集求连通块）。</p>
<h3 id="tc12909">TC12909</h3>
<p>任意时刻局面的样子都是若干个连续段，我们只关心每个连续段的样子和它们在环上的相对顺序，而不关心空白的位置，因为只有知道前者的方案数，当前局面的方案数是可以算的。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示当前已经来了 <span class="math inline">\(i\)</span> 个朋友，共构成 <span class="math inline">\(j\)</span> 个连续段的方案数，转移分三种：</p>
<ul>
<li>第 <span class="math inline">\(i+1\)</span> 个朋友新开一个连续段，<span class="math inline">\(f_{i+1,j+1} \leftarrow j \cdot f_{i,j}\)</span>。</li>
<li>第 <span class="math inline">\(i+1\)</span> 个朋友加入一个连续段的开头或结尾，<span class="math inline">\(f_{i+1,j} \leftarrow 2j \cdot f_{i,j}\)</span>。</li>
<li>第 <span class="math inline">\(i+1\)</span> 个朋友将两个连续段接在了一起，<span class="math inline">\(f_{i+1,j-1} \leftarrow j \cdot f_{i,j}\)</span>。</li>
</ul>
<p>只需要保证 <span class="math inline">\(j \le G\)</span> 就行了，而不需要考虑连续段过多而导致前两种转移不合法，因为不合法了贡献系数一定为 <span class="math inline">\(0\)</span>。</p>
<p>最后是贡献系数，假设 <span class="math inline">\(K\)</span> 个人到齐后有 <span class="math inline">\(x\)</span> 个连续段，则贡献系数为 <span class="math inline">\(N\binom{N-K-1}{K-1}\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<h3 id="tc13692">TC13692</h3>
<p>搬家具的排列很像拓扑序，但又有点区别。</p>
<p>枚举 <span class="math inline">\(S_1-S_2\)</span> 路径上第一个选的点 <span class="math inline">\(u\)</span>，再对每条边定向定向，然后就转化成了一张图的拓扑序，记这个东西为 <span class="math inline">\(f_u\)</span>。当 <span class="math inline">\(u=S_1\)</span> 或 <span class="math inline">\(S_2\)</span> 时这张图就是树，否则这张图和树唯一的区别是点 <span class="math inline">\(u\)</span> 有两个父亲，但这张图的拓扑序并不好算，单次复杂度只能做到 <span class="math inline">\(O(n^2)\)</span>，无法通过。</p>
<p>注意到这题只需要求出 <span class="math inline">\(S_1-S_2\)</span> 路径上每个点 <span class="math inline">\(f\)</span> 的总和。</p>
<p>枚举 <span class="math inline">\(S_1-S_2\)</span> 路径上的一条边 <span class="math inline">\((u,v)\)</span>，然后断开 <span class="math inline">\((u,v)\)</span>，再对每条边定向定向，然后就转化成了两棵树的拓扑序，这个是可以 <span class="math inline">\(O(n)\)</span> 算的，发现算出来的正好是 <span class="math inline">\(f_u+f_v\)</span>。</p>
<p>最后把前一步骤的计算结果加起来，再加上 <span class="math inline">\(f_{S_1}+f_{S_2}\)</span> 并除以二，即是答案。</p>
<h3 id="agc017f">AGC017F</h3>
<p>容易想到用位向量来表示折线，<span class="math inline">\(0\)</span> 表示这一步向左走，<span class="math inline">\(1\)</span> 表示向右，容易得到折线的形态只有 <span class="math inline">\(2^{N-1}\)</span> 种。</p>
<p>由于相邻两条折线 <span class="math inline">\(S,T\)</span> 的约束关系是 <span class="math inline">\(T\)</span> 的每个前缀后都大于等于 <span class="math inline">\(S\)</span> 的对应前缀和。</p>
<p>不难想到轮廓线 <code>DP</code>，设 <span class="math inline">\(f_{i,j,k,S}\)</span> 表示满足以下条件的方案数：</p>
<ul>
<li>第 <span class="math inline">\(i\)</span> 条折线已经填了前 <span class="math inline">\(j\)</span> 位。</li>
<li><span class="math inline">\(S\)</span> 的前 <span class="math inline">\(j\)</span> 位是第 <span class="math inline">\(i\)</span> 条折线的，后 <span class="math inline">\(N-1-j\)</span> 位是第 <span class="math inline">\(i-1\)</span> 条折线的。</li>
<li>第 <span class="math inline">\(i-1\)</span> 条折线前 <span class="math inline">\(j\)</span> 位之和为 <span class="math inline">\(k\)</span>。</li>
</ul>
<p>转移就枚举第 <span class="math inline">\(i\)</span> 条折线第 <span class="math inline">\(j+1\)</span> 为填什么。</p>
<p>复杂度 <span class="math inline">\(O(n^32^n)\)</span>，无法通过。</p>
<p>再次考虑相邻两条折线 <span class="math inline">\(S,T\)</span> 的约束关系，发现从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 是以下过程：</p>
<ul>
<li><p>把每个 <span class="math inline">\(1\)</span> 都往前移或不动，并且不改变相对顺序。</p></li>
<li><p>最后一个 <span class="math inline">\(1\)</span> 之后的 <span class="math inline">\(0\)</span> 任意变成 <span class="math inline">\(1\)</span>。</p></li>
</ul>
<p>重新定义 <code>DP</code> 状态 <span class="math inline">\(f_{i,j,S}\)</span> 表示正在确定了第 <span class="math inline">\(i\)</span> 条折线，当前为 <span class="math inline">\(S\)</span>，已经固定了前 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(1\)</span> 的方案数。</p>
<p>转移为：</p>
<ul>
<li>如果存在第 <span class="math inline">\(j+1\)</span> 个 <span class="math inline">\(1\)</span>，就枚举它往前移多少位，不能跨过前一个 <span class="math inline">\(1\)</span>，这个枚举量平均是 <span class="math inline">\(O(1)\)</span> 的。</li>
<li>如果不存在，要么确定第 <span class="math inline">\(i\)</span> 条折线，要么枚举最后一个 <span class="math inline">\(1\)</span> 之后的一个 <span class="math inline">\(0\)</span> 把它变成 <span class="math inline">\(1\)</span>，这个枚举量平均也是 <span class="math inline">\(O(1)\)</span> 的。</li>
</ul>
<p>当确定第 <span class="math inline">\(i\)</span> 条折线后把不合法的状态置成 <span class="math inline">\(0\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(n^22^n)\)</span>。</p>
<h3 id="arc078d">ARC078D</h3>
<p>考虑从 <span class="math inline">\(1-n\)</span> 只有一条点不重复的路径的充要条件：</p>
<ul>
<li>把这条唯一路径上的边都断开后路径上的点两两不连通。</li>
</ul>
<p>假设知道这条唯一路径是 <span class="math inline">\(u_1,u_2,\cdots,u_k\)</span>（<span class="math inline">\(u_1=1,u_k=n\)</span>），要将点集划分成 <span class="math inline">\(k\)</span> 份，第 <span class="math inline">\(i\)</span> 份包含 <span class="math inline">\(u_k\)</span>，最大化每个点集内部的边权之和。</p>
<p>可以得到一个状压做法：</p>
<ul>
<li>设 <span class="math inline">\(g_S\)</span> 表示两个端点都在点集 <span class="math inline">\(S\)</span> 内部的所有边的权值之和。</li>
<li>设 <span class="math inline">\(f_S\)</span> 表示点集 <span class="math inline">\(S\)</span> 已经被考虑时，最大的保留边权之和。</li>
<li>转移为：<span class="math inline">\(f_S \leftarrow f_{S-T} + g_T({T \subseteq S})\)</span>，其中 <span class="math inline">\(T\)</span> 恰好包含一个关键点。</li>
</ul>
<p>由于并不知道这条路径，所以需要该一下 <code>DP</code> 状态：</p>
<p>设 <span class="math inline">\(f_{i,S}\)</span> 表示点集 <span class="math inline">\(S\)</span> 已经被考虑且 <span class="math inline">\(1-i\)</span> 只有一条路径时，最大的保留边权之和。</p>
<p>转移为:</p>
<ul>
<li><span class="math inline">\(f_{i,S \cup \{i\}} \leftarrow f_{j,S} + w(j,i)(j \not\in S)\)</span>。</li>
<li><span class="math inline">\(f_{i,S\cup T} \leftarrow f_{i,S}+g_{T\cup\{i\}}(S \cap T = \varnothing)\)</span>。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n3^n)\)</span>。</p>
<p>ARC068D</p>
<p>AGC004F</p>
<p>ARC097D</p>
<p>TC10265</p>
<p>TC9844</p>
<p>ARC067C</p>
<p>ARC097C</p>
<h3 id="tc10727">TC10727</h3>
<p>根据“跳跳棋”的结论，所有的三元组构成二叉森林的形态，于是问题就转化成了：</p>
<ul>
<li>在一棵无限满二叉树上，从点 <span class="math inline">\(u\)</span> 走到点 <span class="math inline">\(v\)</span> 长度恰好为 <span class="math inline">\(k\)</span> 的路径条数。</li>
</ul>
<p>直接算感觉很困难，考虑 <code>DP</code>，容易想到记录当前步数和所在点 <span class="math inline">\(x\)</span>，但 <span class="math inline">\(x\)</span> 显然是记不了的。考虑用关键信息来替代 <span class="math inline">\(x\)</span>，记录 <span class="math inline">\(\text{dis}(x,\text{lca}(x,v)),\text{dis}(v,\text{lca}(x,v))\)</span> 就够了。</p>
<p>状态 <span class="math inline">\(f_{i,j,k}\)</span> 为走了 <span class="math inline">\(i\)</span> 步，<span class="math inline">\(\text{dis}(x,\text{lca}(x,v))=j,\text{dis}(v,\text{lca}(x,v))=k\)</span> 的路径条数。</p>
<p>转移为：</p>
<ul>
<li><span class="math inline">\(f_{i+1,j+1,k} \leftarrow 2f_{i,j,k},f_{i+1,j-1,k} \leftarrow f_{i,j,k}(j&gt;0)\)</span></li>
<li><span class="math inline">\(f_{i+1,1,k} \leftarrow f_{i,0,k},f_{i+1,\max(1-k,0),\max(k-1,0)} \leftarrow f_{i,0,k}(k&gt;0)\)</span></li>
<li><span class="math inline">\(f_{i+1,0,k+1} \leftarrow f_{i,0,k}(k &lt; \text{depth}_v)\)</span></li>
</ul>
<p>TC10664</p>
<p>TC10566</p>
<p>TC10773</p>
<h3 id="tc10993">TC10993</h3>
<p>容易发现把所有的环缩成点之后这张图就变成的一棵树，把 <span class="math inline">\(0\)</span> 结点所在的环看出根。树边和环边分开考虑。</p>
<p>对于树边，显然所有人都只会向上走，最坏情况就是 <span class="math inline">\(C\)</span> 个人全在这条树边的下面，故每条树边需要 <span class="math inline">\(C\)</span> 个急救仓。</p>
<p>对于一个环，子树中的人都是先向上走到这个环上，再聚集到向上的树边的下端点，最后一起离开这个环。</p>
<p>可以看出环之间是独立的，考虑一个环怎么做。对于一个环来说，最坏的情况肯定是 <span class="math inline">\(C\)</span> 个人聚集在一个点上，然后这 <span class="math inline">\(C\)</span> 个人再分成两批，一批从左边绕到终点，另一批从右边绕到终点，要求 <span class="math inline">\(\min 左边 + \min 右边 \ge C\)</span>。</p>
<p>方法是 <code>DP</code>，设 <span class="math inline">\(f_{i,j}\)</span> 表示已经确定了从终点开始向左的 <span class="math inline">\(i\)</span> 条边，它们的 <span class="math inline">\(\min\)</span> 为 <span class="math inline">\(j\)</span> 时的最小代价。</p>
<p>转移时枚举第 <span class="math inline">\(i+1\)</span> 条边的急救仓数 <span class="math inline">\(k\)</span>：<span class="math inline">\(f_{i+1,\min(j,k)} \leftarrow f_{i,j}(j+k \ge C)\)</span>。因为 <span class="math inline">\(j\)</span> 只会变小，所以对于第 <span class="math inline">\(i+1\)</span> 条之后的边，它们的限制会更严，所以转移只需要使第 <span class="math inline">\(i+1\)</span> 条边满足限制。</p>
<p>复杂度 <span class="math inline">\(O(nC^2)\)</span>，无法通过。</p>
<p>考虑将这个转移拆开：</p>
<ul>
<li><span class="math inline">\(f_{i+1,j} \leftarrow f_{i,j}(k \ge \max(j,C-j))\)</span>，此时肯定要最小化 <span class="math inline">\(k\)</span>。</li>
<li><span class="math inline">\(f_{i+1,k} \leftarrow f_{i,j}(k \le j \le C -k)\)</span>，考虑 <span class="math inline">\(k\)</span> 从小到大时，可行的 <span class="math inline">\(j\)</span> 组成的区间在扩展，容易做到均摊 <span class="math inline">\(O(1)\)</span> 转移。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(nC)\)</span>。</p>
<p>TC10741</p>
<p>TC10854</p>
<p>TC10848</p>
<p>TC10902</p>
<p>TC10737</p>
<p>TC10758</p>
<p>TC11003</p>
<p>TC11026</p>
<p>TC11032</p>
<p>TC10748</p>
<p>TC11213</p>
<p>TC11305</p>
<p>TC12620</p>
<p>TC10758</p>
<p>TC11032</p>
<h3 id="gym102391e">Gym102391E</h3>
<p>先二分一个直径 <span class="math inline">\(D\)</span>，建出圆方树，设 <span class="math inline">\(f_u\)</span> 表示：</p>
<ul>
<li>已经确定了 <span class="math inline">\(u\)</span> 子树内的所有方点表示的环怎么断。</li>
<li>子树内直径不超过 <span class="math inline">\(D\)</span>。</li>
<li><span class="math inline">\(f_u\)</span> 为子树内到 <span class="math inline">\(u\)</span>（圆点）/ <span class="math inline">\(fa_u\)</span>（方点）的最大距离。</li>
</ul>
<p>转移分两种：</p>
<ul>
<li><p><span class="math inline">\(u\)</span> 为圆点，判断一下儿子 <span class="math inline">\(f\)</span> 最大的两个之和是否小于等于 <span class="math inline">\(D\)</span>，大于 <span class="math inline">\(D\)</span> 说明 <span class="math inline">\(D\)</span> 小了，停止 <code>DP</code>，否则继承儿子 <span class="math inline">\(f\)</span> 的最大值。</p></li>
<li><p><span class="math inline">\(u\)</span> 为方点，设 <span class="math inline">\(fa\)</span> 为 <span class="math inline">\(u\)</span> 的父亲，枚举一下断该环上的哪条边，然后算一下子树内直径，直径有两种可能情况。</p>
<ul>
<li>一个儿子 <span class="math inline">\(v\)</span> 到断边的较大环上距离 <span class="math inline">\(+f_v\)</span>。</li>
<li>两个儿子 <span class="math inline">\(v_1,v_2\)</span> 在不跨过断边时的环上距离 <span class="math inline">\(+f_{v_1}+f_{v_2}\)</span>。</li>
</ul>
<p>如果直径大于 <span class="math inline">\(D\)</span>，就说明这条边不能断，否则</p>
<p><span class="math inline">\(f_u \leftarrow \max\limits_vf_v+\)</span> <span class="math inline">\(v\)</span> 在不跨过断边时到 <span class="math inline">\(fa\)</span> 的环上距离。</p>
<p><span class="math inline">\(f_u \leftarrow\)</span> 断边到 <span class="math inline">\(fa\)</span> 的环上距离。</p>
<p>直接转移复杂度为 <span class="math inline">\(O(儿子数量^2)\)</span>，记录一些儿子前后缀信息就可以优化到线性，以前缀为例：</p>
<ul>
<li>第 <span class="math inline">\(i\)</span> 个儿子向左绕到 <span class="math inline">\(fa\)</span> 的距离。</li>
<li>前 <span class="math inline">\(i\)</span> 个儿子子树内在不跨过 <span class="math inline">\(fa\)</span> 时到第 <span class="math inline">\(i\)</span> 个儿子的最大距离。</li>
<li>前 <span class="math inline">\(i\)</span> 个儿子子树内和断边向左绕到 <span class="math inline">\(fa\)</span> 的最大距离。</li>
<li>前 <span class="math inline">\(i\)</span> 个儿子子树内的直径。</li>
</ul></li>
</ul>
<p>复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<h3 id="zoj3970">ZOJ3970</h3>
<p>考虑在操作序列中有相邻的加减操作并且加操作在前面，应用如下调整：</p>
<ul>
<li>如果两个操作区间无交，则交换操作顺序。</li>
<li>如果有交，那么相交的部分相当于什么都没做，直接去掉相交部分，变成上一种情况。</li>
</ul>
<p>经过有限步调整，操作序列变成了若干减后若干加。</p>
<p>假设已知第 <span class="math inline">\(i\)</span> 个位置需要进行 <span class="math inline">\(a_i\)</span> 次减操作，那么最小操作次数为 <span class="math inline">\(\sum_{i=2}^n\max(0,a_i-a_{i-1})\)</span>。</p>
<p>加操作同理。</p>
<p>设 <span class="math inline">\(pre_i\)</span> 表示上一个满足 <span class="math inline">\(t_j&gt;0\)</span> 的位置 <span class="math inline">\(j\)</span>。</p>
<p><span class="math inline">\(f_{i,j}\)</span> 表示考虑了前 <span class="math inline">\(i\)</span> 个位置，其中第 <span class="math inline">\(i\)</span> 个位置被 <span class="math inline">\(j\)</span> 个减操作覆盖时的最小操作次数。</p>
<p>转移为：</p>
<p><span class="math display">\[
f_{i,j}=\min_kf_{pre_i,k}+\max(0,j-k)+\max(0,t_i-s_i+j-t_{pre_i}+s_{pre_i}-k)+\max(0,\max_{pre_i&lt;x&lt;i}s_x-\max(j,k))
\]</span></p>
<p>其中最后一项表示将区间 <span class="math inline">\((pre_i,i)\)</span> 减成 <span class="math inline">\(0\)</span> 需要的额外减操作次数。</p>
<p>复杂度 <span class="math inline">\(O(nV^2)\)</span>，无法通过。</p>
<p>打表发现函数 <span class="math inline">\(f_i\)</span> 分三段，每一段都是一次函数，并且斜率递增。</p>
<p>注意到转移方程后面的每一项都是分段一次函数，因此它们的和也是分段一次函数，所以 <span class="math inline">\(\min\)</span> 只会在拐点处取到，这样就可以 <span class="math inline">\(O(1)\)</span> 算出一个 <span class="math inline">\(f_{i,j}\)</span>。</p>
<p>求函数 <span class="math inline">\(f_i\)</span> 的两个拐点？考虑分治，对于一个区间 <span class="math inline">\([l,r]\)</span>，如果 <span class="math inline">\(f_{i,l},f_{i,mid},f_{i,r}\)</span> 等差，说明 <span class="math inline">\([l,r]\)</span> 一定在同一个段，否则递归左右两半。</p>
<p>复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<h3 id="zoj3989">ZOJ3989</h3>
<p>为了方便处理，先对所有点旋转一个角度，使所有点横坐标两两不同。</p>
<p>对于一个三角剖分，考虑一个维护折线过程：</p>
<ul>
<li>初始为下凸包。</li>
<li>每次将折线上一条边换成它上方三角形的另外两条边，要保证这两条边不在折线上。</li>
<li>或者将折线上在同一三角形内的相邻两条边换成第三条边，要保证三角形在原来两条边的上方。</li>
<li>最终为上凸包。</li>
</ul>
<p>这个过程会遍历三角剖分中的所有边，容易想到把折线作为 <code>DP</code> 状态，但折线数量太大了。</p>
<p>给折线加一条限制：折线上的拐点横坐标递增。但这样可能会导致折线找不到合法的转移。</p>
<p>事实上这种情况不存在：</p>
<ul>
<li>对于二换一的转移，显然合法，所以考虑只能进行一换二的时候。</li>
<li>对于最左边的折线，假设它的横坐标区间为 <span class="math inline">\([l,r]\)</span>，进行一换二后新的拐点横坐标为 <span class="math inline">\(x\)</span>，要么 <span class="math inline">\(l &lt; x &lt; r\)</span>，这时可以直接转移，否则 <span class="math inline">\(x &gt; r\)</span>，即它上方的三角形向右偏。</li>
<li>对于最右边的折线，如果它不能直接转移，同理可以得到它上方的三角形向左偏。</li>
<li>最左边的折线上方的三角形向右偏，最右边的折线上方的三角形向左偏，故中间一定存在一条折线可以进行合法的一换二。</li>
</ul>
<p>这样的折线就可以用拐点集合来表示了，状态数为 <span class="math inline">\(2^{n-2}\)</span>，转移时不能跨过点。</p>
<p>这样就解决了最优化问题，但计数会算重。</p>
<p>定义一次转移的「横坐标」为它涉及到的两个或三个点中横坐标的最大值，所有当前能进行的转移的「横坐标」一定两两不同。</p>
<p>考虑将折线的转移序列标准化，使得转移序列与三角剖分一一对应：每次进行「横坐标」最大的合法转移。</p>
<p>另一个等价的定义是每次转移的「横坐标」单调不减。</p>
<p>设 <span class="math inline">\(f_{S,i}\)</span> 表示当前折线为 <span class="math inline">\(S\)</span>，上次转移的「横坐标」为 <span class="math inline">\(i\)</span> 时的最小代价及其方案数。</p>
<p>复杂度 <span class="math inline">\(O(n^22^n)\)</span>。</p>
<h3 id="来源不明的题">来源不明的题</h3>
<blockquote>
<p>给定一个二分图，左右各 <span class="math inline">\(n\)</span> 个点。对于左部点的一个集合 <span class="math inline">\(S\)</span>，设 <span class="math inline">\(f(S)\)</span> 表示与 <span class="math inline">\(S\)</span> 中至少一个点相邻的右部点集合。判断是否存在一个集合 <span class="math inline">\(S \ne \{1,2,\cdots,n\}\)</span>，使得 <span class="math inline">\(|f(S)| \le |S|\)</span>，输出方案。</p>
<p><span class="math inline">\(n, m \le 10^5\)</span></p>
</blockquote>
<p>Hall 定理：一个二分图存在完美匹配的充要条件是对于任意 <span class="math inline">\(S\)</span>，<span class="math inline">\(|f(S)| \ge |S|\)</span>。</p>
<p>如果不存在完美匹配，就存在 <span class="math inline">\(S\)</span> 使得 <span class="math inline">\(|f(S)| \le |S|\)</span>，考虑求出一个这样的 <span class="math inline">\(S\)</span>。</p>
<p>先求出一个最大匹配，找一个未匹配点为根建匈牙利树，树上所有的左部点就是 <span class="math inline">\(S\)</span>。</p>
<p>如果存在完美匹配，解的形式一定是一个左部点集合 <span class="math inline">\(S\)</span>，它们的匹配点集合为 <span class="math inline">\(f(S)\)</span>。</p>
<p>所以如果选了右部点 <span class="math inline">\(v\)</span>，就一定会选它的匹配点 <span class="math inline">\(\text{match}(v)\)</span>。</p>
<p>把原来的每条边 <span class="math inline">\((u,v)\)</span> 换成 <span class="math inline">\((u,\text{match}(v))\)</span> 再求出拓扑序最小的强连通分量即可。</p>
<h3 id="arc107f">ARC107F</h3>
<p>由于一个连通块的贡献带有绝对值符号，不太好处理，变成枚举符号不会影响答案。</p>
<p>现在变成如下问题：</p>
<ul>
<li>每个点有三种状态：正、负、删，代价分别为 <span class="math inline">\(-B_i,A_i,B_i\)</span>。</li>
<li>对于相邻的点 <span class="math inline">\(u,v\)</span>，如果它们的状态都不是删，就必须相同。</li>
<li>求最小代价。</li>
</ul>
<p>想到最小割模型，由于每个点有三种状态，所以把每个点 <span class="math inline">\(i\)</span> 变成两个点 <span class="math inline">\(U_i,V_i\)</span>。</p>
<p>用 <span class="math inline">\((S,U_i),(U_i,V_i),(V_i,T)\)</span> 三条边表示三种状态。</p>
<p>令它们的代价分别为 <span class="math inline">\(\infty-B_i,\infty+A_i,\infty+B_i\)</span>，那么这三条边一定恰好割掉一条。</p>
<p>对于相邻的点 <span class="math inline">\((i,j)\)</span>，有两个约束关系：</p>
<ul>
<li>不能同时割 <span class="math inline">\((S,U_i),(V_j,T)\)</span>，如果要割 <span class="math inline">\((S,U_i)\)</span>，说明 <span class="math inline">\(U_i\)</span> 能到达 <span class="math inline">\(T\)</span>，如果要割 <span class="math inline">\((V_j,T)\)</span>，说明 <span class="math inline">\(S\)</span> 能到达 <span class="math inline">\(V_j\)</span>，所以连一条 <span class="math inline">\((V_j,U_i)\)</span>，代价为 <span class="math inline">\(\infty^2\)</span> 的边。</li>
<li>不能同时割 <span class="math inline">\((S,U_j),(V_i,T)\)</span>，同理连一条 <span class="math inline">\((V_i,U_j)\)</span>，代价为 <span class="math inline">\(\infty^2\)</span> 的边。</li>
</ul>
<p>最后答案为最小割减去 <span class="math inline">\(n\infty\)</span>。</p>
<figure>
<img src="https://i.loli.net/2021/09/08/4ragjEUYIev5wot.png" alt=".png" /><figcaption aria-hidden="true">.png</figcaption>
</figure>
<h3 id="gym101471j">Gym101471J</h3>
<p>CF1307G</p>
<h3 id="cf1307f">CF1307F</h3>
<p>P3980</p>
<p>CF1368H2</p>
<h3 id="agc038e">AGC038E</h3>
<p>先考虑一个弱化版问题：<span class="math inline">\(B_i=1\)</span> 时怎么做。</p>
<p>这是一个经典问题，一般做法有两种：状压 <code>DP</code> 和 <code>min-max</code> 容斥。</p>
<p>它们的复杂度都是 <span class="math inline">\(O(n2^n)\)</span> 或 <span class="math inline">\(O(2^n)\)</span> 的，然而这题数据范围是 <span class="math inline">\(400\)</span>，说明需要用的此题的特殊性质。</p>
<p>通过 <code>min-max</code> 容斥可以得出答案为 <span class="math display">\[
\sum_{S}(-1)^{|S|}\frac{\sum_{i=1}^n A_i}{\sum_{i \in S} A_i}
\]</span> 发现分母是小于 <span class="math inline">\(400\)</span> 的非负整数！可以用背包数出每种分母的贡献 <span class="math inline">\(\sum_S(-1)^{|S|}\)</span>。</p>
<p>设 <span class="math display">\[
f_{i,j} = \sum_{S \subseteq \{1,2,\cdots,i\}}(-1)^{|S|}[\sum_{i \in S}A_i=j]
\]</span> 转移为 <span class="math inline">\(f_{i,j}=f_{i-1,j}-f_{i-1,j-A_i}\)</span>，答案为 <span class="math display">\[
(\sum_{i=1}^n A_i)\sum_{i=0}^{400}\frac{f_{n,i}}i
\]</span> 现在回到原问题，还是考虑 <code>min-max</code> 容斥，答案就是 <span class="math display">\[
\sum_{S}(-1)^{|S|}[S 中第一次有元素达到目标时的期望步数]
\]</span></p>
<p>设 <span class="math inline">\(p_i=\frac{A_i}{\sum_{j \in S}A_j}\)</span>。</p>
<p>根据期望的线性性质，期望步数可以分摊到经过每个状态上。所以后面那坨东西为： <span class="math display">\[
\begin{aligned}
&amp;\sum_{\forall i \in S,c_i&lt;B_i}[到达c状态的概率]\cdot[离开c状态的期望步数]\\
&amp;=\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{\prod_{i \in S} c_i!}\prod_{i \in S}p_i^{c_i} \cdot \frac{\sum_{i=1}^n A_i}{\sum_{i \in S} A_i}\\
&amp;=\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{\prod_{i \in S} c_i!}\prod_{i \in S}A_i^{c_i} \cdot \frac{\sum_{i=1}^n A_i}{(\sum_{i \in S} A_i)^{(\sum_{i \in S}c_i)+1}}
\end{aligned}
\]</span></p>
<p>把前面说的东西拼起来，答案为： <span class="math display">\[
\begin{aligned}
&amp;\sum_S(-1)^{|S|}\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{\prod_{i \in S} c_i!}\prod_{i \in S}A_i^{c_i} \cdot \frac{\sum_{i=1}^n A_i}{(\sum_{i \in S} A_i)^{(\sum_{i \in S}c_i)+1}}\\
&amp;=(\sum_{i=1}^n A_i)\sum_S(-1)^{|S|}\sum_{\forall i \in S,c_i&lt;B_i}\frac{(\sum_{i \in S}c_i)!}{(\sum_{i \in S} A_i)^{(\sum_{i \in S}c_i)+1}} \cdot \prod_{i \in S}\frac{A_i^{c_i}}{c_i!}
\end{aligned}
\]</span></p>
<p>式子中比较难转移的东西就是 <span class="math inline">\(\sum_{i \in S} A_i\)</span> 和 <span class="math inline">\(\sum_{i \in S}c_i\)</span>，把它们记状态里就行了。</p>
<p>状态为 <span class="math display">\[
f_{i,j,k}=\sum_{S \subseteq \{1,2,\cdots,i\}}(-1)^{|S|}\sum_{\forall i \in S,c_i&lt;B_i}\prod_{i \in S}\frac{A_i^{c_i}}{c_i!}[\sum_{i \in S} A_i=j \land \sum_{i \in S}c_i=k]
\]</span> 转移为 <span class="math display">\[
f_{i,j,k}=f_{i-1,j,k}-\sum_{c=0}^{B_i-1}f_{i-1,j-A_i,k-c}\frac{A_i^c}{c!}
\]</span> 答案为 <span class="math display">\[
(\sum_{i=1}^n A_i)\sum_{i=0}^{400}\sum_{j=0}^{400}\frac{j!f_{n,i,j}}{i^{j+1}}
\]</span> 分析一下时间复杂度，虽然每次转移的枚举量是 <span class="math inline">\(B_i\)</span>，但由于 <span class="math inline">\(\sum_{i=1}^nB_i\)</span> 是 <span class="math inline">\(O(n)\)</span> 的，所以总复杂度是 <span class="math inline">\(O(n^3)\)</span>，空间复杂度可以用滚动数组优化到 <span class="math inline">\(O(n^2)\)</span>。</p>
<hr />
<h3 id="agc037d">AGC037D</h3>
<p>考虑第三次操作前第 <span class="math inline">\(i\)</span> 行一定由 <span class="math inline">\((i-1)m+1\)</span> 到 <span class="math inline">\(im\)</span> 构成，记 <span class="math inline">\((i-1)m+1\)</span> 到 <span class="math inline">\(im\)</span> 的颜色为 <span class="math inline">\(i\)</span>。</p>
<p>第二次操作的目标就是使颜色为 <span class="math inline">\(i\)</span> 的数在第 <span class="math inline">\(i\)</span> 行，所以第一次操作的目标就是使每一列 <span class="math inline">\(n\)</span> 种都颜色各有一个。</p>
<p>先考虑如何确定第一列的颜色，这显然是一个行与颜色的完美匹配问题。由于任意选 <span class="math inline">\(i\)</span> 行，这 <span class="math inline">\(i\)</span> 行的颜色数至少为 <span class="math inline">\(i\)</span>，根据 Hall 定理，一定存在完美匹配。每一列依次求完美匹配就可以构造出一组解。</p>
<p>然后第二三次操作就非常简单了，复杂度 <span class="math inline">\(O(n^4)\)</span>。</p>
<h3 id="agc043d">AGC043D</h3>
<p>考虑什么样的排列 <span class="math inline">\(P\)</span> 是能被造出来的。</p>
<p>考虑构造过程：每次选择一个头元素最小的序列 <span class="math inline">\(A_i\)</span>，删除 <span class="math inline">\(A_i\)</span> 开头单调递减的一段，再继续找头元素最小的序列。</p>
<p>这启发我们把同时删除的元素看成一段，分段具有如下性质：</p>
<ul>
<li>每一段是长度不超过 <span class="math inline">\(3\)</span> 的单调递减序列。</li>
<li>每一段的头元素递增。</li>
<li>长度为 <span class="math inline">\(1\)</span> 的段不少于长度为 <span class="math inline">\(2\)</span> 的段（因为每一个长度为 <span class="math inline">\(2\)</span> 的段必须要对应一个长度为 <span class="math inline">\(1\)</span> 的段来一起构成一个 <span class="math inline">\(A_i\)</span>）。</li>
</ul>
<p>同时，只要满足上面三个条件，这个 <span class="math inline">\(P\)</span> 就能被造出来的，将每个段配配对就可以得到一个生成 <span class="math inline">\(P\)</span> 的 <span class="math inline">\(A\)</span> 序列。</p>
<p>由于 <span class="math inline">\(P\)</span> 和分段内容是一一对应的，问题转化为对合法的分段内容计数。</p>
<p>枚举长度分别为 <span class="math inline">\(1,2,3\)</span> 的段数 <span class="math inline">\(cnt_1,cnt_2,cnt_3\)</span>，满足 <span class="math inline">\(cnt_1+2cnt_2+3cnt_3=3n\)</span> 和 <span class="math inline">\(cnt_1 \ge cnt_2\)</span>。</p>
<p>贡献即为 <span class="math display">\[
\binom{cnt_1+cnt_2+cnt_3}{cnt_1,cnt_2,cnt_3}\frac{(3n)!}{(cnt_1+cnt_2+cnt_3)!2^{cnt_2}3^{cnt_3}}
\]</span> 前面的组合数是划分出每一段的方案数，除以 <span class="math inline">\((cnt_1+cnt_2+cnt_3)!\)</span> 是保证每一段的头元素递增，除以 <span class="math inline">\(2^{cnt_2}3^{cnt_3}\)</span> 是保证每一段的头元素为最大值。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc049d">AGC049D</h3>
<p>考虑如何描述一个非负凸序列。</p>
<ul>
<li>枚举最小值 <span class="math inline">\(c\)</span>，以及取到最小值的第一个位置 <span class="math inline">\(i\)</span>，令 <span class="math inline">\(A=(c,c,\cdots,c)\)</span>。</li>
<li>多次选一个位置 <span class="math inline">\(j&lt;i\)</span>，将 <span class="math inline">\(A_j,A_{j-1},A_{j-2},\cdots,A_1\)</span> 分别加上 <span class="math inline">\(1,2,3,\cdots,j\)</span>。</li>
<li>多次选一个位置 <span class="math inline">\(j&gt;i\)</span>，将 <span class="math inline">\(A_j,A_{j+1},A_{j+2},\cdots,A_n\)</span> 分别加上 <span class="math inline">\(1,2,3,\cdots,n-j+1\)</span>，若 <span class="math inline">\(i&gt;1\)</span> 则 <span class="math inline">\(i-1\)</span> 必须被选到一次。</li>
</ul>
<p>第三步可以事先选 <span class="math inline">\(i-1\)</span> 一次，对总和产生 <span class="math inline">\(\frac {i(i-1)}2\)</span> 的贡献，然后第三步就和第二步一样了。</p>
<p>先枚举 <span class="math inline">\(i\)</span>，第二三步本质上就是完全背包，由于体积的特性，有用的物品数量是 <span class="math inline">\(O(\sqrt m)\)</span> 的，可以 <span class="math inline">\(O(m\sqrt m)\)</span> 预处理出背包数组，然后 <span class="math inline">\(O(\frac mn)\)</span> 枚举 <span class="math inline">\(c\)</span>，计算贡献。</p>
<p>这样做的复杂度为 <span class="math inline">\(O(nm\sqrt m)\)</span>，无法通过。</p>
<p>考虑 <span class="math inline">\(i \rightarrow i+1\)</span> 时，物品最多删一个，也最多添一个，并且总改变次数是 <span class="math inline">\(O(\sqrt m)\)</span> 的，动态维护背包即可做到 <span class="math inline">\(O(m\sqrt m)\)</span> 的复杂度。</p>
<h3 id="agc050d">AGC050D</h3>
<p>设 <span class="math inline">\(f_{i,a,b,j}\)</span> 表示从以下局面出发，还没有赢的人中从左到右第 <span class="math inline">\(j\)</span> 个人最终赢的概率。</p>
<ul>
<li>有 <span class="math inline">\(a\)</span> 个人还没有赢且已经排除了 <span class="math inline">\(i\)</span> 个错误选项。</li>
<li>有 <span class="math inline">\(b\)</span> 个人还没有赢且已经排除了 <span class="math inline">\(i+1\)</span> 个错误选项。</li>
</ul>
<p>转移就枚举这 <span class="math inline">\(a\)</span> 个人中下一个人是赢还是输即可（这里 <span class="math inline">\(f_{i,0,b,j}=f_{i+1,b,0,j}\)</span>）。</p>
<ul>
<li><span class="math inline">\(f_{i,a,b,j}=win \cdot f_{i,a-1,b,j-[j&gt;b]} + lost \cdot f_{i,a-1,b+1,j}(j\ne b+1)\)</span></li>
<li><span class="math inline">\(f_{i,a,b,b+1}=win + lost \cdot f_{i,a-1,b+1,b+1}(j\le b)\)</span></li>
</ul>
<p>复杂度 <span class="math inline">\(O(n^4)\)</span>。</p>
<h3 id="noi2021day1t1">NOI2021Day1T1</h3>
<p>如果把修改操作看成把路径上的点染成一种新的颜色，那么重边就是两端同色的边，轻边就是两端异色的边。</p>
<p>所以询问操作就是查询路径上两端同色的边数，这个可以用树链剖分和线段树维护。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="noi2021day1t2">NOI2021Day1T2</h3>
<p>当 <span class="math inline">\(k=2\)</span> 时，交点就是逆序对，自然联想到行列式，发现答案就是行列式。</p>
<p>当 <span class="math inline">\(n_1=n_2=\cdots=n_k\)</span> 时，答案就是把每相邻两层邻接矩阵的行列式乘起来。</p>
<p>对于原问题，答案就是相邻两层邻接矩阵乘积的行列式。</p>
<p>证明：</p>
<ul>
<li><p>对于一个合法的路径组，考虑两条路径 <span class="math inline">\((P_1,P_2,\cdots,P_k)\)</span> 和 <span class="math inline">\((Q_1,Q_2,\cdots,Q_k)\)</span>，两条路径有奇数个交点 <span class="math inline">\(\iff\)</span> <span class="math inline">\((P_1,Q_1)\)</span> 和 <span class="math inline">\((P_k,Q_k)\)</span> 逆序。</p></li>
<li><p>对于一个不合法的路径组，考虑对其进行以下变换：</p>
<ul>
<li>找到最靠上的一个点被覆盖多次，多个在同一层时取最靠左的一个。</li>
<li>找到经过此点的编号最小两条路径，将它们的下一半交换。</li>
</ul>
<p>这样的变换是相互的，并且会使每条路径头尾形成的逆序对总数的奇偶性改变，故不合法的路径组的贡献会两两抵消。</p></li>
</ul>
<p>复杂度 <span class="math inline">\(O(n^4)\)</span>。</p>
<h3 id="noi2021day1t3">NOI2021Day1T3</h3>
<p>容易发现对于一次询问，答案为 <span class="math inline">\(s\)</span> 能到达且能到达 <span class="math inline">\(t\)</span> 的点数。</p>
<p>由于研究的是可达性，先进行强连通分量缩点。</p>
<p>再考虑限制：若 <span class="math inline">\(x\Rightarrow z\)</span> 且 <span class="math inline">\(y\Rightarrow z\)</span>，则 <span class="math inline">\(x\Rightarrow y\)</span> 或 <span class="math inline">\(y\Rightarrow x\)</span>。这说明能到达 <span class="math inline">\(z\)</span> 的点在一条链上，进一步，整张图是一棵树加上若干条从祖先到儿子的边。</p>
<p>如何求出这棵树？一个点的父亲就是所有连向它的点中拓扑序最大的一个，注意所完点后编号就是拓扑序的逆序。</p>
<p>对于加边操作，对 <span class="math inline">\(s,t\)</span> 以及所有边的端点建虚树，统计一下虚树上的点和边的贡献即可。</p>
<p>由于此题卡常，树剖求 <code>LCA</code> 效果最佳，用邻接链表存虚树，不能用 <code>vector</code>。</p>
<p>复杂度 <span class="math inline">\(O(n+q\log n)\)</span>。</p>
<h3 id="noi2021day2t1">NOI2021Day2T1</h3>
<p><span class="math inline">\(k \le 15\)</span> 是此题的突破点，这意味着把 <span class="math inline">\(256\)</span> 平均分成 <span class="math inline">\(16\)</span> 段后必然有一段是完全相同的。</p>
<p>枚举完全相同的是哪一段，确定了 <span class="math inline">\(16\)</span> 位后，期望只有 <span class="math inline">\(7\)</span> 个符合条件的串，对它们用 <code>popcount</code> 检验即可。</p>
<h3 id="noi2021day2t2">NOI2021Day2T2</h3>
<p><del>结论题。</del></p>
<p>假设已知 <span class="math inline">\(a\)</span> 序列，怎么算答案。</p>
<p>维护最后一项 <span class="math inline">\(a_n\)</span>​ 的分子分母 <span class="math inline">\(x,y\)</span>​，一次变换后 <span class="math inline">\(\frac {x&#39;}{y&#39;}=a_{n-1}+\frac 1{a_n}=\frac {a_{k-1}x+y}x\)</span>​。发现不会发生约分，并且相当于对 <span class="math inline">\((x,y)\)</span>​​ 做了一个线性变换： <span class="math display">\[
\begin{bmatrix}
x&#39;\\
y&#39;
\end{bmatrix}
=
\begin{bmatrix}
a_{n-1}&amp;1\\
1&amp;0
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix}
\]</span> 算出 <span class="math display">\[
\begin{bmatrix}
a&amp;c\\
b&amp;d
\end{bmatrix}
=
\prod_{i=1}^n
\begin{bmatrix}
a_i&amp;1\\
1&amp;0
\end{bmatrix}
\]</span> 答案即为 <span class="math inline">\(\frac ab\)</span>。</p>
<p>然后考虑两种操作：</p>
<ul>
<li><p><code>W</code> 类型：因为 <span class="math inline">\(\begin{bmatrix}x&amp;1\\1&amp;0\end{bmatrix}\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}=\begin{bmatrix}x+1&amp;1\\1&amp;0\end{bmatrix}\)</span>​，所以 'W' 操作就是在后面乘一个 <span class="math inline">\(\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}\)</span>。</p></li>
<li><p><code>E</code> 类型：虽然定义中如果最后一项为 <span class="math inline">\(1\)</span> 时要特别处理，但发现当最后一项为 <span class="math inline">\(1\)</span> 时两种处理方式的结果是一样的。</p>
<p>给倒数第二项加 <span class="math inline">\(1\)</span> 的影响： <span class="math display">\[
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}
\rightarrow
\begin{bmatrix}
1&amp;0\\
1&amp;1
\end{bmatrix}
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}
=
\begin{bmatrix}
1&amp;1\\
2&amp;1
\end{bmatrix}
\]</span> 给数列的<strong>最后一项</strong>减 <span class="math inline">\(1\)</span>，接着在数列尾再加两项，两项的值都是 <span class="math inline">\(1\)</span> 的影响： <span class="math display">\[
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}
\rightarrow
\begin{bmatrix}
0&amp;1\\
1&amp;0
\end{bmatrix}
\begin{bmatrix}
1&amp;1\\
1&amp;0
\end{bmatrix}^2
=
\begin{bmatrix}
1&amp;1\\
2&amp;1
\end{bmatrix}
\]</span> 所以把 <code>E</code> 操作按第二种处理方式就行了，给数列的最后一项减 <span class="math inline">\(1\)</span>​ 相当于乘 <span class="math inline">\(\begin{bmatrix}1&amp;0\\-1&amp;1\end{bmatrix}\)</span>。</p>
<p>于是 <code>E</code> 操作相当于乘 <span class="math inline">\(\begin{bmatrix}1&amp;0\\-1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^2=\begin{bmatrix}2&amp;1\\-1&amp;0\end{bmatrix}\)</span>。</p></li>
</ul>
<p>此时这题就很容易了，<code>APPEND</code>，<code>FLIP</code> 和 <code>REVERSE</code> 都是可以平衡树维护的，每个结点不仅要维护区间矩阵乘积，还要维护倒着乘的结果，<code>FLIP</code> 后的结果，和 <code>FLIP</code> 后倒着乘的结果。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="noi2021day2t3">NOI2021Day2T3</h3>
<p>发现每个机器人对纸带的修改本质上只有 <span class="math inline">\(4\)</span> 种：赋值为 <span class="math inline">\(0\)</span>，赋值为 <span class="math inline">\(1\)</span>，不变，取反，分别用 <span class="math inline">\(0,1,2,3\)</span> 表示。</p>
<p>不难想到容斥原理：枚举一个起始位置集合 <span class="math inline">\(mask\)</span>，计算有多少种输入使得机器人从这些位置出发的输出都一样。每条纸带上每个位置受到的修改是确定且独立的，讨论一下一个位置的可行输入，乘起来就是贡献：</p>
<ul>
<li>如果一个位置同时包含 <span class="math inline">\(0,1\)</span> 或 <span class="math inline">\(2,3\)</span>，那么输入只能为空，方案数为 <span class="math inline">\(1\)</span>。</li>
<li>否则，如果一个位置包含两种操作，那么输入可以为空或 <span class="math inline">\(01\)</span> 中的一种，方案数为 <span class="math inline">\(2\)</span>。</li>
<li>否则，三种输入都可行，方案数为 <span class="math inline">\(3\)</span>。</li>
</ul>
<p>至此，得到一个 <span class="math inline">\(O(2^nmn^2)\)</span> 的做法。</p>
<p>考虑优化计算一个机器人对一个起始位置集合的贡献，记状压数组 <span class="math inline">\(g_{0/1/2/3,S}\)</span> 表示选择起始位置集合 <span class="math inline">\(S\)</span> 时包含 <span class="math inline">\(0/1/2/3\)</span> 的位置，<span class="math inline">\(g\)</span> 可以 <span class="math inline">\(O(2^n)\)</span> 求出，有了 <span class="math inline">\(g\)</span> 也可以 <span class="math inline">\(O(1)\)</span>​ 算贡献。</p>
<p>复杂度 <span class="math inline">\(O(2^nm)\)</span>。</p>
<p>题目限制 <span class="math inline">\(n \le 32\)</span>，猜想是分大小两类计算来平衡复杂度。进一步观察发现当 <span class="math inline">\(mask\)</span> 的最高位大于等于 <span class="math inline">\(\lceil\frac n2\rceil\)</span> 时，修改范围大于 <span class="math inline">\(\lceil\frac n2\rceil\)</span> 的机器人都会爆掉。</p>
<p>枚举 <span class="math inline">\(mask\)</span> 的最高位 <span class="math inline">\(\max\)</span>，这样就确定了哪些机器人会爆掉（不用考虑），分两种情况：</p>
<ul>
<li><p><span class="math inline">\(\max \le \lceil\frac n2\rceil\)</span>，这个可以暴力容斥，复杂度 <span class="math inline">\(O(2^{\frac n2}m)\)</span>。</p></li>
<li><p><span class="math inline">\(\max &gt; \lceil\frac n2\rceil\)</span>，这意味着需要考虑的机器人修改范围都不超过 <span class="math inline">\(n-\max+1\)</span>。</p>
<p>一个修改范围大小为 <span class="math inline">\(R\)</span>​ 的机器人所在的纸带上，一个位置的状态只和两个因素有关：</p>
<ul>
<li><p>它前面 <span class="math inline">\(R\)</span> 个位置哪些在 <span class="math inline">\(mask\)</span> 中。</p></li>
<li><p>它是否没有被某个区间覆盖。</p></li>
</ul>
<p>如果所有区间都覆盖了某个位置，说明 <span class="math inline">\(mask\)</span>​ 的最低位大于等于 <span class="math inline">\(2\max-n+1\)</span>​，可以暴力容斥，复杂度 <span class="math inline">\(O(2^{n-\max+1}m)\)</span>​。 否则只需要考虑第一条，可以 <code>DP</code>，设 <span class="math inline">\(f_{i,S}\)</span>​ 表示已经确定了 <span class="math inline">\(mask\)</span>​ 的前 <span class="math inline">\(i\)</span>​ 位，其中最后 <span class="math inline">\(n-\max+1\)</span>​ 位为 <span class="math inline">\(S\)</span>​，转移直接枚举第 <span class="math inline">\(i+1\)</span>​ 位选不选即可，可以 <span class="math inline">\(O(2^{n-\max+1}m)\)</span>​ 预处理转移系数，复杂度 <span class="math inline">\(O(2^{n-\max+1}n)\)</span>​。</p></li>
</ul>
<p>总复杂度 <span class="math inline">\(O(2^{n/2}m)\)</span>​。</p>
<h3 id="cf1548d2">CF1548D2</h3>
<p>根据 Pick 定理： <span class="math display">\[
S=i+\frac b2-1
\]</span> 合法三角形的条件即为 <span class="math inline">\(S\in \mathbb Z \land2S\equiv b \pmod 4\)</span>​。</p>
<p>对于三角形 <span class="math inline">\(ABC\)</span>​， <span class="math inline">\(2S=|\overrightarrow A\times \overrightarrow B+\overrightarrow B\times \overrightarrow C+\overrightarrow C\times \overrightarrow A|\)</span>​​​，由于 <span class="math inline">\(S\)</span> 是整数，所以绝对值不会影响 <span class="math inline">\(S\)</span> 的奇偶性，只需要各个顶点的坐标模 <span class="math inline">\(4\)</span> 的结果就可以知道 <span class="math inline">\(2S \bmod 4\)</span>​。</p>
<p>一条线段 <span class="math inline">\(AB\)</span>​​​ 的 <strong>边界数</strong> 为线段上整点数减一，<span class="math inline">\(b\)</span>​​ 就是三条线段的边界数之和。线段 <span class="math inline">\(AB\)</span>​​ 的边界数 <span class="math inline">\(\text{bounds}(A,B)=\gcd(|X_A-X_B|,|Y_A-Y_B|)\)</span>​​​​，不太好简单表示。</p>
<p>由于要求 <span class="math inline">\(S\)</span> 为整数，所以 <span class="math inline">\(b\)</span> 为偶数，这是一个很重要的条件，这意味着合法三角形三条边的边界数中至少有一条是偶数，另外两个奇偶性相同，判断 <span class="math inline">\(\text{bounds}(A,B) \bmod 4\)</span> 是 <span class="math inline">\(0\)</span> 还是 <span class="math inline">\(2\)</span> 要容易得多， <span class="math display">\[
\text{bounds}(A,B) \equiv 0\pmod 4 \iff X_A\equiv X_B\pmod 4 \land Y_A\equiv Y_B\pmod 4
\]</span> 在 <span class="math inline">\(\text{bounds}(A,B) \not\equiv 0\pmod 4\)</span> 的前提下 <span class="math display">\[
\text{bounds}(A,B) \equiv 2\pmod 4 \iff X_A\equiv X_B\pmod 2 \land Y_A\equiv Y_B\pmod 2
\]</span> 判断这两个条件只需要各个顶点的坐标模 <span class="math inline">\(4\)</span> 的结果。</p>
<p>此时做法就清晰起来了，合法三角形按三条边的边界数奇偶性可以分成 EEE 和 EOO 两类，设 <span class="math inline">\(cnt_{A,x,y,z}\)</span> 表示有多少个点 <span class="math inline">\(B\)</span>​​ 满足 <span class="math display">\[
X_B\equiv x\pmod 4 \land Y_B\equiv y\pmod 4 \land \text{bounds}(A,B) \equiv z\pmod 4
\]</span> 这个是可以 <span class="math inline">\(O(n^2\log V)\)</span> 预处理的。</p>
<p>考虑分别对两类合法三角形 <span class="math inline">\(ABC\)</span>​​​ 计数，先枚举点 <span class="math inline">\(A\)</span>​，再枚举 <span class="math display">\[
X_B\bmod 4,Y_B\bmod 4,\text{bounds}(A,B)\bmod 4\\X_C\bmod 4,Y_C\bmod 4,\text{bounds}(A,C)\bmod 4
\]</span> 满足 <span class="math display">\[
S \in \mathbb Z\\
\text{bounds}(A,B)\equiv\text{bounds}(A,C)\pmod 2\\
X_B\equiv X_C \pmod 2\\
Y_B\equiv Y_C\pmod 2\\
S\equiv \text{bounds}(A,B)+\text{bounds}(A,C)+\text{bounds}(B,C)\pmod 4
\]</span> 使用 <span class="math inline">\(cnt\)</span> 数组可以 <span class="math inline">\(O(1)\)</span>​​ 计算贡献。</p>
<p>这样每个 EEE 三角形会被算 <span class="math inline">\(3\)</span> 遍，每个 EOO 三角形会被算 <span class="math inline">\(1\)</span> 遍。</p>
<p>复杂度 <span class="math inline">\(O(n^2\log V)\)</span>。</p>
<h3 id="cf1548e">CF1548E</h3>
<p><del>最简单的 3400。</del></p>
<p>把坏格子填成 <span class="math inline">\(1\)</span>，其他填成 <span class="math inline">\(0\)</span>，问题就是求矩阵中有多少个“1”的四-连通块。</p>
<blockquote>
<p>引理：对于任意两行 <span class="math inline">\(i,j\)</span>​​​，“1” 所在列的集合一定是相互包含的。</p>
</blockquote>
<p>不妨假设 <span class="math inline">\(a_i \ge a_j\)</span>​​，<span class="math inline">\(a_i+b_k \le x \Rightarrow a_j+b_k \le x\)</span>​。</p>
<p>同时，此引理也就是这个矩阵的全部性质了，因为任何一个符合引理的矩阵都是可以构造出 <span class="math inline">\(a,b\)</span> 数组的。此题唯一的条件也就是这个引理了，目标很明确。</p>
<p>我们数连通块的思路是这样的：</p>
<ul>
<li>对于一个连通块 <span class="math inline">\(S\)</span>​​​​​​，它上到 <span class="math inline">\(L_r\)</span>​​​​​​，下到 <span class="math inline">\(R_r\)</span>​​​​​​，左到 <span class="math inline">\(L_c\)</span>​​​​​，右到 <span class="math inline">\(R_c\)</span>​​​​​​。</li>
<li>设 <span class="math inline">\(a_{L_r},a_{L_r+1},\cdots,a_{R_r}\)</span>​​​ 中第一个取到最小值的位置为 <span class="math inline">\(i\)</span>，显然 <span class="math inline">\((i,L_c),(i,L_c+1),\cdots,(i,R_c)\)</span>​ 都为 “1”。</li>
<li>我们希望 <span class="math inline">\(S\)</span> 被 <span class="math inline">\(i\)</span> 数到。</li>
</ul>
<p>再考虑对于 <span class="math inline">\(i\)</span>​，有多少个连通块会被它数到，对于第 <span class="math inline">\(i\)</span> 行的一个 “1” 的连续段 <span class="math inline">\([l,r]\)</span>，它所在的连通块会被 <span class="math inline">\(i\)</span>​​ 数当且仅当：</p>
<ul>
<li>它向上不能走到一行 <span class="math inline">\(j\)</span>​​​ 满足 <span class="math inline">\(a_j \le a_i\)</span>​​​​，形式化地，<span class="math inline">\(\min_{k\in [l,r]}a_k+\max_{k\in (j,i]}b_k&gt;x\)</span>​​。</li>
<li>它向下不能走到一行 <span class="math inline">\(j\)</span>​​ 满足 <span class="math inline">\(a_j&lt;a_i\)</span>​​​，形式化地，<span class="math inline">\(\min_{k\in [l,r]}a_k+\max_{k\in [i,j)}b_k&gt;x\)</span>​​​。</li>
</ul>
<p>综上，记 <span class="math inline">\(i\)</span> 前面第一个满足 <span class="math inline">\(a_j\le a_i\)</span> 的 <span class="math inline">\(j\)</span> 为 <span class="math inline">\(pre\)</span>， <span class="math inline">\(i\)</span> 后面第一个满足 <span class="math inline">\(a_j&lt; a_i\)</span> 的 <span class="math inline">\(j\)</span> 为 <span class="math inline">\(suf\)</span>，连续段 <span class="math inline">\([l,r]\)</span> 造成贡献当且仅当 <span class="math inline">\(\min_{i\in [l,r]}a_i&gt;x-\max_{i\in (pre,suf)}\)</span>，不等式右边对于每个 <span class="math inline">\(i\)</span> 是确定的，而且是可以通过单调栈 <span class="math inline">\(O(n)\)</span>​ 预处理的东西，对于左边则可以使用数据结构来维护。</p>
<p>下面我们进一步讨论这个数据结构需要干什么：</p>
<ul>
<li>这个数据结构维护所有连续段 <span class="math inline">\(b\)</span> 的最小值。</li>
<li>将所有行以 <span class="math inline">\(a_i\)</span>​ 为第一关键字，<span class="math inline">\(i\)</span>​​ 为第二关键字从大到小排序。每次序列中一个 <span class="math inline">\(0\)</span> 改成 <span class="math inline">\(1\)</span>​，会导致新增连续段，也会导致两个连续段合并，修改就是加入元素和删除元素。</li>
<li>询问操作就是查询有多少个元素大于 <span class="math inline">\(key\)</span>。</li>
</ul>
<p>对于新增连续段和合并连续段可以用并查集维护，元素则用反向树状数组维护。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t1">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T1</h3>
<p>把两端同色的边看成实边，两端异色的边看成虚边。</p>
<ul>
<li><code>1</code> 操作就是 <code>access(u)</code>。</li>
<li><code>2</code> 操作就是查询两点间的虚边条数，转化一下变成查询一个点到根路径上的虚边条数。</li>
<li><code>3</code> 操作转化一下就是查询 <code>dfs</code> 序区间中的点到根路径上的虚边条数总和。</li>
<li><code>4</code> 操作就是每条实链点数选二之和。</li>
</ul>
<p>对于 <code>23</code> 操作，需要维护每个点到根路径上的虚边条数，支持区间加、区间求和，树状数组即可。</p>
<p>对于 <code>4</code> 操作，在 <code>LCT</code> 中维护实链的点数，就可以在 <code>access</code> 时维护答案。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t2">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T2</h3>
<p>记 <span class="math inline">\(f_{i,j}\)</span> 表示有多少个串恰好有 <span class="math inline">\(i\)</span> 个 <code>a</code>、<span class="math inline">\(j\)</span>​​ 个 <code>b</code>，不难写出它的生成函数 <span class="math inline">\((x+y+k-2)^L\)</span>。</p>
<p>而题目中求的就是 <span class="math inline">\(\sum_{i=0}^L\sum_{j=0}^L[n|i-p][n|j-q][x^i][y^j](x+y+k-2)^L\)</span>​​。</p>
<p>题目还保证 <span class="math inline">\(n|P-1\)</span>​，考虑单位根反演，得到答案为 <span class="math display">\[
\frac 1{n^2}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}(\omega_n^i+\omega_n^j+k-2)^L\omega_n^{-ip}\omega_n^{-jq}
\]</span> 记 <span class="math inline">\(A_{i,j}=(\omega_n^i+\omega_n^j+k-2)^L\)</span> 可以 <span class="math inline">\(O(n^2\log L)\)</span> 预处理，答案矩阵 <span class="math inline">\(B\)</span> 就是 <span class="math inline">\(A\)</span> 对两维分别做 <code>IDFT</code> 得到的。每次固定一维，对另一维做 <code>IDFT</code> 就行了，暴力做复杂度 <span class="math inline">\(O(n^3)\)</span>，或者 Bluestein + MTT 可以做到 <span class="math inline">\(O(n^2\log n)\)</span>。</p>
<p>复杂度 <span class="math inline">\(O(n^3)\)</span> 或者 <span class="math inline">\(O(n^2\log L)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t9">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T9</h3>
<p>称区间中数量超过一半的数为 <strong>主元素</strong>。</p>
<p>由于一个合法区间只有一个主元素，可以考虑每个主元素的贡献。</p>
<h4 id="做法-1">做法 1</h4>
<p>考虑枚举一个值 <span class="math inline">\(v\)</span>​，计算这个值的贡献。</p>
<p>假设 <span class="math inline">\(v\)</span>​ 在序列中的出现位置为 <span class="math inline">\(p_1,p_2,\cdots,p_k\)</span>​​，区间 <span class="math inline">\([l,r]\)</span> 中第一个 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(p_i\)</span> 出现，最后一个 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(p_j\)</span>​ 出现。</p>
<p>考虑枚举 <span class="math inline">\(j\)</span>​，快速查询有多少对合法的 <span class="math inline">\((l,r)\)</span>​。把等于 <span class="math inline">\(v\)</span>​ 的位置变成 <span class="math inline">\(1\)</span>​，不等于 <span class="math inline">\(v\)</span>​ 的位置变成 <span class="math inline">\(-1\)</span>​，记前缀和为 <span class="math inline">\(sum_i\)</span>​，那么区间 <span class="math inline">\([l,r]\)</span>​ 合法的充要条件为 <span class="math inline">\(sum_{l-1}&lt;sum_r\)</span>​，因此需要维护的是 <span class="math inline">\(sum_1,sum_2,\cdots,sum_{p_j}\)</span>​ 组成的集合，<span class="math inline">\(j\rightarrow j+1\)</span>​ 时，加入的元素是 <span class="math inline">\(sum_{p_j},sum_{p_j+1},\cdots,sum_{p_{j+1}-1}\)</span>​，它们的值是连续的一段，所以这是一个区间 <span class="math inline">\(+1\)</span>​，对于一个 <span class="math inline">\(r\in[p_j,p_{j+1})\)</span>​，合法 <span class="math inline">\(l\)</span>​ 的数量就是集合中小于 <span class="math inline">\(sum_r\)</span>​​ 的元素数量，这是一个前缀和，而 <span class="math inline">\([p_j,p_{j+1})\)</span>​ 内所有的 <span class="math inline">\(sum_r\)</span>​ 构成一个区间，所以询问操作是查询前缀和的前缀和，可以用三个树状数组实现。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h4 id="做法-2">做法 2</h4>
<p>考虑分治，计算有多少个合法区间 <span class="math inline">\([l,r]\)</span>​​ 满足 <span class="math inline">\(l\le mid+1 \land r\ge mid\)</span>​​。</p>
<p>可以发现区间 <span class="math inline">\([l,r]\)</span>​​ 合法的必要条件是 <span class="math inline">\([l,mid]\)</span> 和 <span class="math inline">\([mid+1,r]\)</span> 中至少有一个是合法的。</p>
<blockquote>
<p>引理：一个序列所有前缀的主元素中本质不同只有 <span class="math inline">\(O(\log n)\)</span> 个。</p>
</blockquote>
<p>所以可能产生贡献的 <span class="math inline">\(v\)</span> 只有 <span class="math inline">\(O(\log n)\)</span> 个。枚举 <span class="math inline">\(v\)</span>。把等于 <span class="math inline">\(v\)</span> 的位置变成 <span class="math inline">\(1\)</span>，不等于 <span class="math inline">\(v\)</span> 的位置变成 <span class="math inline">\(-1\)</span>，记前缀和为 <span class="math inline">\(sum_i\)</span>，枚举 <span class="math inline">\(r\)</span> 后，需要查询有多少个 <span class="math inline">\(l\le mid+1\)</span> 满足 <span class="math inline">\(sum_{l-1}&lt;sum_r\)</span>，这个可以预处理前缀和做到 <span class="math inline">\(O(1)\)</span> 查询。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="minieye杯中国大学生算法设计超级联赛5t13">2021“MINIEYE杯”中国大学生算法设计超级联赛（5）T13</h3>
<p>先二分一个直径 <span class="math inline">\(D\)</span>，考虑用 <code>DP</code> 去判定。</p>
<p>设 <span class="math inline">\(f_{u,0/1}\)</span> 表示以下情形以 <span class="math inline">\(u\)</span>​ 为端点向子树内延伸的最长链的最小值（不存在时为 <span class="math inline">\(\infty\)</span>）：</p>
<ul>
<li>确定了 <span class="math inline">\(u\)</span>​ 子树内每个点选哪条边。</li>
<li><span class="math inline">\(u\)</span> 选的边是否是 <span class="math inline">\(u\)</span>​ 和父亲的连边。</li>
<li>子树内直径不超过 <span class="math inline">\(D\)</span>。</li>
</ul>
<p><span class="math inline">\(f_{u,1}\)</span>​​​ 可以直接从每个儿子 <span class="math inline">\(v\)</span>​​​ 用 <span class="math inline">\(\min(f_{v,0}+w(u,v),f_{v,1}+\max(w(u,v)-p_v,0))\)</span>​​​ 转移过来，如果前两大的值之和大于 <span class="math inline">\(D\)</span>​​，<span class="math inline">\(f_{u,1}=\infty\)</span>​​，否则就取这些值中的最大值。</p>
<p><span class="math inline">\(f_{u,0}\)</span>​ 的转移需要分析一下，<span class="math inline">\(u\)</span>​ 选择的边 <span class="math inline">\((u,v)\)</span>​​ 必须要满足 <span class="math inline">\(v\)</span>​ 是 <span class="math inline">\(\min(f_{v,0}+w(u,v),f_{v,1}+w(u,v)-p_v)\)</span>​​ 前两大的儿子，所以枚举一下 <span class="math inline">\(v\)</span>，就可以直接转移了。</p>
<p>复杂度 <span class="math inline">\(O(n\log V)\)</span>。</p>
<h3 id="agc041d">AGC041D</h3>
<p>考虑任意 <span class="math inline">\(k\)</span>​ 道题的总分都小于任意 <span class="math inline">\(k+1\)</span>​ 道题的总分这个限制，发现它等价于前 <span class="math inline">\(\lceil\frac n2\rceil\)</span>​ 道题的总分小于后 <span class="math inline">\(\lceil\frac n2\rceil-1\)</span>​ 道题的总分。</p>
<p>考虑如何生成一个合法的序列 <span class="math inline">\(A\)</span>：</p>
<ul>
<li>枚举第 <span class="math inline">\(\lfloor\frac n2\rfloor+1\)</span>​ 道题的分值 <span class="math inline">\(c\)</span>​，令 <span class="math inline">\(A=(c,c,\cdots,c)\)</span>​。</li>
<li>多次选一个位置 <span class="math inline">\(j&lt;\lfloor\frac n2\rfloor+1\)</span>​​，将 <span class="math inline">\(A_1,A_2,\cdots,A_j\)</span>​ 全部减一。</li>
<li>多次选一个位置 <span class="math inline">\(j&gt;\lfloor\frac n2\rfloor+1\)</span>​，将 <span class="math inline">\(A_j,A_{j+1},\cdots,A_n\)</span>​​​ 全部加一。</li>
<li>由于 <span class="math inline">\(A_1 \ge 1\)</span>​​​，所以第二种操作的次数不得超过 <span class="math inline">\(c-1\)</span>​​​，同理第三种操作的次数不得超过 <span class="math inline">\(n-c\)</span>​​​。</li>
<li>设前 <span class="math inline">\(\lceil\frac n2\rceil\)</span>​ 道题的总分减后 <span class="math inline">\(\lceil\frac n2\rceil-1\)</span>​ 道题的总分为 <span class="math inline">\(x\)</span>​，第一步后 <span class="math inline">\(x=c\)</span>​，第二种操作每一次都会使 <span class="math inline">\(x\)</span>​ 减小 <span class="math inline">\(j\)</span>​，第三种操作每一次都会使 <span class="math inline">\(x\)</span>​ 减小 <span class="math inline">\(n-j+1\)</span>​​，因此第二、三种操作的总贡献要小于 <span class="math inline">\(c\)</span>。</li>
</ul>
<p>可以看出这是一个完全背包，第二种操作就是添加体积为 <span class="math inline">\(1,2,\cdots,\lfloor\frac n2\rfloor\)</span>​​ 的物品，而且最多添加 <span class="math inline">\(c-1\)</span>​ 个，第三种操作就是添加体积为 <span class="math inline">\(1,2,\cdots,\lceil\frac n2\rceil-1\)</span>​​​​ 的物品，最多添加 <span class="math inline">\(n-c\)</span>​ 个，总体积要小于 <span class="math inline">\(c\)</span>​。</p>
<p>对于第二种操作，考虑预处理 <span class="math inline">\(L_{i,j}\)</span>​ 表示选择 <span class="math inline">\(i\)</span> 个物品，总体积为 <span class="math inline">\(j\)</span> 的方案数。用传统背包做复杂度肯定不行，事实上它能直接转移： <span class="math display">\[
L_{i,j}=L_{i-1,j-1}+L_{i,j-i}-L_{i-1,j-i-\lfloor\frac n2\rfloor}
\]</span> 对于第三种操作，同理可以预处理 <span class="math inline">\(R_{i,j}\)</span>。</p>
<p>然后就可以枚举 <span class="math inline">\(c\)</span>​ 后 <span class="math inline">\(O(n)\)</span>​​ 计算合法方案数。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc027d">AGC027D</h3>
<p>构造的思路是先黑白染色，然后填好黑格，再让每个白格满足：</p>
<ul>
<li>它大于周围四个黑格。</li>
<li>它模周围四个黑格都等于 <span class="math inline">\(1\)</span>。</li>
</ul>
<p>填白格的过程是容易的，对于一个白格，先算出周围四个黑格的 <span class="math inline">\(\text{lcm}\)</span>，然后尝试填 <span class="math inline">\(\text{lcm}+1\)</span>​，如果已经填过了，就继续尝试 <span class="math inline">\(2\text{lcm}+1,3\text{lcm}+1,\cdots\)</span>​。</p>
<p>如果没有值域限制，这题就做完了，考虑怎样让填的数尽可能小。</p>
<p>填白格没有什么好优化的（尝试过优先填 <span class="math inline">\(\text{lcm}\)</span>​​ 较大的格子，但完全没有效果），所以考虑如何填黑格，才能使 <span class="math inline">\(\text{lcm}\)</span> 比较小。</p>
<ul>
<li>填法一：顺序填或随机填，大概只能构造 <span class="math inline">\(N\)</span> 等于一百多。</li>
<li>填法二：考虑到一个白格周围四个黑格有两个是同一行的，有两个是同一列的，令 <span class="math inline">\(A_{i,j}\)</span> 是 <span class="math inline">\(\text{lcm(i,j)}\)</span> 的倍数，具体怎么确定，像确定白格那样确定，大概能构造 <span class="math inline">\(N\)</span> 等于两百多。</li>
<li>填法三：考虑到一个白格周围四个黑格只涉及四条斜线，令 <span class="math inline">\(A_{i,j}\)</span> 是 <span class="math inline">\(\text{lcm}(i+j,i-j+n)\)</span> 的倍数，大概能构造 <span class="math inline">\(N\)</span> 等于 <span class="math inline">\(425\)</span> 左右。</li>
<li>填法四：经过一番尝试，令 <span class="math inline">\(A_{i,j}\)</span>​​ 是 <span class="math inline">\(\text{lcm}(i+(n-j+1),i-(n-j+1)+n)\)</span>​（就是把列编号倒过来）可以通过。</li>
<li>填发五：考虑给每条斜线分配一个质数，黑格就等于所在的两条斜线质数的乘积，白格就等于周围四条斜线质数的乘积加一，一定不会有数重复。</li>
</ul>
<p>填发四需要用 <code>set</code> 维护哪些数填过，复杂度 <span class="math inline">\(O(n^2\log n)\)</span>​​。</p>
<p>填发五复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc025d">AGC025D</h3>
<p>对于两个距离为 <span class="math inline">\(\sqrt D\)</span>​ 的点 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>​，考虑 <span class="math inline">\(x_1-x_2,y_1-y_2\)</span>​​ 的奇偶性： <span class="math display">\[
x_1 \equiv x_2 \pmod 2,y_1 \equiv y_2 \pmod 2 \iff D \equiv 0 \pmod 4\\
x_1 \equiv x_2 \pmod 2,y_1 \not\equiv y_2 \pmod 2 \iff D \equiv 1 \pmod 4\\
x_1 \not\equiv x_2 \pmod 2,y_1 \not\equiv y_2 \pmod 2 \iff D \equiv 2 \pmod 4\\
\]</span> 因此 <span class="math inline">\(D \bmod 4\)</span>​ 说明了两点坐标差的奇偶性。</p>
<blockquote>
<p>引理：将平面上距离为 <span class="math inline">\(\sqrt D\)</span> 的点对连边后是一张二分图。</p>
</blockquote>
<p>考虑构造一个黑白染色方案，设 <span class="math inline">\(\text{color}(x,y,D)=0/1\)</span> 表示点 <span class="math inline">\((x,y)\)</span> 的颜色。</p>
<ul>
<li><p>当 <span class="math inline">\(D\equiv 3\pmod 4\)</span> 时，没有边，<span class="math inline">\(\text{color}(x,y,D)=0\)</span>。</p></li>
<li><p>当 <span class="math inline">\(D\equiv 2\pmod 4\)</span> 时，<span class="math inline">\(\text{color}(x,y,D)=x\bmod 2\)</span>，这样距离为 <span class="math inline">\(\sqrt D\)</span> 的点对就必然异色。</p></li>
<li><p>当 <span class="math inline">\(D \equiv 1\pmod 4\)</span> 时，<span class="math inline">\(\text{color}(x,y,D)=(x+y)\bmod 2\)</span>，这样距离为 <span class="math inline">\(\sqrt D\)</span> 的点对就必然异色。</p></li>
<li><p>当 <span class="math inline">\(D\equiv 0\pmod 4\)</span> 时，<span class="math inline">\(\text{color}(x,y,D)=\text{color}(\lfloor\frac x2\rfloor,\lfloor\frac y2\rfloor,\frac D4)\)</span>​​，下面证明为什么合法：</p>
<p>对于两个距离为 <span class="math inline">\(\sqrt D\)</span> 的点 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>，由于 <span class="math inline">\(x_1 \equiv x_2 \pmod 2,y_1 \equiv y_2 \pmod 2\)</span>，所以 <span class="math display">\[
\lfloor\frac {x_1}2\rfloor-\lfloor\frac {x_2}2\rfloor=\frac 12(x_1-x_2)\\
\lfloor\frac {y_1}2\rfloor-\lfloor\frac {y_2}2\rfloor=\frac 12(y_1-y_2)
\]</span> 进一步： <span class="math display">\[
\begin{aligned}
&amp;(x_1-x_2)^2+(y_1-y_2)^2=D\\
\Rightarrow &amp;(\lfloor\frac {x_1}2\rfloor-\lfloor\frac {x_2}2\rfloor)^2+(\lfloor\frac {y_1}2\rfloor-\lfloor\frac {y_2}2\rfloor)^2=\frac D4\\
\Rightarrow &amp;\text{color}(\lfloor\frac {x_1}2\rfloor,\lfloor\frac {y_1}2\rfloor,\frac D4)\ne\text{color}(\lfloor\frac {x_2}2\rfloor,\lfloor\frac {y_2}2\rfloor,\frac D4)
\end{aligned}
\]</span></p></li>
</ul>
<p>对于 <span class="math inline">\(D_1\)</span>​ 和 <span class="math inline">\(D_2\)</span>​ 分别黑白染色后本质有 <span class="math inline">\(4\)</span>​ 种颜色，这 <span class="math inline">\(4\)</span>​​ 种颜色中肯定有一种点数大于等于 <span class="math inline">\(n^2\)</span>​，输出这种颜色的 <span class="math inline">\(n^2\)</span>​ 个点即可。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="agc036d">AGC036D</h3>
<p>没有负环等价于差分约束有解，假设解为 <span class="math inline">\(d_1,d_2,\cdots,d_n\)</span>​，不妨令 <span class="math inline">\(d_1=0\)</span>。</p>
<p>由于 <span class="math inline">\(i\rightarrow i+1\)</span> 的边是不能被删的，所以 <span class="math inline">\(d\)</span> 是单调不增的，也就是一段 <span class="math inline">\(0\)</span>，一段 $-1 $，一段 <span class="math inline">\(-2\cdots\)</span> 的形式。</p>
<p>考虑一段一段的枚举 <span class="math inline">\(d\)</span>​​​，上一段是 <span class="math inline">\([a,b]\)</span>​​​，即 <span class="math inline">\(d_{a,a+1,\cdots,b}=x+1\)</span>​​​，枚举了新的一段 <span class="math inline">\([b+1,c]\)</span>​​，即 <span class="math inline">\(d_{b+1,b+2,\cdots,c}=x\)</span>​​​​​，​分析哪些边需要删：</p>
<ul>
<li>对于 <span class="math inline">\(b+1\le i &lt; j \le c\)</span>，边 <span class="math inline">\((i,j)\)</span> 需要删除。</li>
<li>对于 <span class="math inline">\(b+1\le i\le c,j&lt;a\)</span>，边 <span class="math inline">\((i,j)\)</span> 需要删除。</li>
</ul>
<p>然后就可以 <code>DP</code> 了，设 <span class="math inline">\(f_{a,b}\)</span> 表示填的最后一段为 <span class="math inline">\([a,b]\)</span> 时的最小代价，转移为 <span class="math display">\[
f_{a,b}+\text{cost}_1(b+1,c)+\text{cost}_2(b+1,c,a-1)\rightarrow f_{b+1,c}
\]</span> 其中 <span class="math inline">\(\text{cost}_1\)</span>​ 和 <span class="math inline">\(\text{cost}_2\)</span>​​ 在预处理二维前缀和后可以 <span class="math inline">\(O(1)\)</span> 算。</p>
<p>复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
<h3 id="agc045d">AGC045D</h3>
<p>如果 <code>Snuke</code> 按到了 <span class="math inline">\(p_i=i\)</span> 的位置就死了，所以他要最小化有解时死的概率，分析 <code>Snuke</code> 的最优策略：</p>
<ul>
<li>最初需要按下一个按钮，由于 <code>Snuke</code> 不知道排列，所以按每个按钮都是一样的，不妨按 <span class="math inline">\(1\)</span>。</li>
<li>如果按下了 <span class="math inline">\(p_i=i\)</span> 的按钮就死了。</li>
<li>否则，<span class="math inline">\(p_i\)</span>​ 一定是一个安全的按钮，继续按下 <span class="math inline">\(p_i\)</span>，这样就可以安全地按下许多按钮。</li>
<li>又需要尝试一个按钮时就按没按过的编号最小的按钮。</li>
</ul>
<p>于是，得到了 <code>Snuke</code> 胜利的充要条件：假设 <span class="math inline">\(1-A\)</span> 中第一个满足 <span class="math inline">\(p_i=i\)</span> 的 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(\min\)</span>​​，<span class="math inline">\(\forall i&gt;A,\exists j&lt;\min\)</span> 使得 <span class="math inline">\(j\)</span> 能到达 <span class="math inline">\(i\)</span>。</p>
<p>容易想到枚举 <span class="math inline">\(\min\)</span>​，把排列看成若干个循环，要求 <span class="math inline">\(\min\)</span>​ 前面没有孤立点，这个可以容斥：</p>
<ul>
<li>钦定 <span class="math inline">\(i\)</span>​​​ 个孤立点，系数为 <span class="math inline">\((-1)^i\binom{\min-1}i\)</span>​。</li>
<li>对于 <span class="math inline">\([1,\min-1]\)</span>​​ 中剩下的 <span class="math inline">\(\min-1-i\)</span>​​ 个点先生成若干个循环，方案数为 <span class="math inline">\((\min-1-i)!\)</span>。</li>
<li>对于 <span class="math inline">\([A+1,n]\)</span> 中的点，它们只能加入前面的循环，方案数为 <span class="math inline">\((\min-1-i)^{\overline{n-A}}\)</span>​。</li>
<li>对于 <span class="math inline">\([\min+1,A]\)</span> 中的点，它们既可以加入前面的循环，又可以新建一个环，方案数为 <span class="math inline">\((\min-1-i+n-A)^{\overline{A-\min}}\)</span>。</li>
</ul>
<p>综上，得到 <span class="math inline">\(\min\)</span> 的贡献为： <span class="math display">\[
\sum_{i=0}^{\min-1}(-1)^i\binom{\min-1}i\frac{(n-1-i)!(\min-1-i)}{\min-1-i+n-A}
\]</span> 当 <span class="math inline">\(\min\)</span>​ 不存在时需要特判，贡献为： <span class="math display">\[
\sum_{i=0}^A(-1)^i\binom Ai(n-i)!
\]</span> 复杂度 <span class="math inline">\(O(A^2+n)\)</span>。</p>
<h3 id="agc041e">AGC041E</h3>
<h4 id="对于-t1">对于 <span class="math inline">\(T=1\)</span></h4>
<p>将网络抽象成一张有向图：</p>
<ul>
<li>将每条线的起点、终点和平衡器的端点抽象成结点。</li>
<li>同一条线上的结点后面向前面连边。</li>
<li>平衡器抽象成两个方向的边。</li>
</ul>
<p>考虑暴力怎么做，枚举最终汇聚到第 <span class="math inline">\(t\)</span>​ 条线，判断 <span class="math inline">\(t\)</span> 的终点是否可以到达所有的起点。</p>
<p>可以用一个 <code>bitset</code> 来压哪些汇点能到达这个点，然后 <code>DFS</code> 来求这些 <code>bitset</code>。可以做到 <span class="math inline">\(O(\frac {nm}{\omega})\)</span>​​​ 的复杂度。</p>
<h4 id="对于-t2">对于 <span class="math inline">\(T=2\)</span></h4>
<p><span class="math inline">\(n=2\)</span> 时显然无解，下面构造说明了 <span class="math inline">\(n&gt;2\)</span> 时一定有解。</p>
<p>考虑从右往左依次插入每个平衡器，维护 <span class="math inline">\(size_i\)</span> 表示当前网络有多少个起点会到达第 <span class="math inline">\(i\)</span> 条线的终点。</p>
<ul>
<li>初始时，<span class="math inline">\(size_i=1\)</span>。</li>
<li>加入平衡器 <span class="math inline">\((x,y)\)</span> 时，要么 <span class="math inline">\(size_x+1\)</span>，要么 <span class="math inline">\(size_y+1\)</span>，选择 <span class="math inline">\(size_x\)</span> 和 <span class="math inline">\(size_y\)</span> 中较小的一个 <span class="math inline">\(+1\)</span>。一定不会出现 <span class="math inline">\(size_x=n-1\land size_y=n-1\)</span> 的情况，因为 <span class="math inline">\(size_x+size_y\le n\)</span>。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<h3 id="abc214g">ABC214G</h3>
<p>以下解法可以解决 <span class="math inline">\(n \le 10^5\)</span>​​ 的问题。</p>
<p>设 <span class="math inline">\(F_k\)</span>​​​ 表示确定 <span class="math inline">\(k\)</span>​​​ 个位置的值 <span class="math inline">\(r_{i_1},r_{i_2},\cdots,r_{i_k}(i_1&lt;i_2&lt;\cdots&lt;i_k)\)</span>​​​​​​​​ 满足以下条件的方案数： <span class="math display">\[
\forall x\in[1,k],r_{i_x}=p_{i_x}\lor r_{i_x}=q_{i_x}
\]</span> 根据二项式反演，答案为 <span class="math display">\[
\sum_{i=0}^n(-1)^iF_i(n-i)!
\]</span> 将 <span class="math inline">\(p_i,q_i\)</span>​​​​​​​ 连边，得到一张由若干个环组成的图，选择一个满足 <span class="math inline">\(r_i=p_i\lor r_i=q_i\)</span>​​ 的位置 <span class="math inline">\(i\)</span>​​​​ 就是选择一条边并占用一个端点，这对于每个环是独立的，所以对每个环求出 <span class="math inline">\(F\)</span>​​ 数组，再用分治 <code>FFT</code> 合并就可以得到整张图的 <span class="math inline">\(F\)</span>​ 数组。</p>
<p>考虑求一个大小为 <span class="math inline">\(m\)</span>​ 的环的 <span class="math inline">\(F\)</span>​ 数组，假设点编号为 <span class="math inline">\(1,2,\cdots,m\)</span>，边为 <span class="math inline">\((1,2),(2,3),\cdots,(m-1,m),(m,1)\)</span>，将选择 <span class="math inline">\(i\)</span> 条边的方案分为以下两类：</p>
<ul>
<li><p>不选边 <span class="math inline">\((1,2)\)</span>​，把边 <span class="math inline">\((2,3)\)</span> 占用 <span class="math inline">\(2\)</span> 的方式编号为 <span class="math inline">\(1\)</span>，边 <span class="math inline">\((2,3)\)</span> 占用 <span class="math inline">\(3\)</span> 的方式编号为 <span class="math inline">\(2\)</span>，边 <span class="math inline">\((3,4)\)</span> 占用 <span class="math inline">\(3\)</span> 的方式编号为 <span class="math inline">\(3\)</span>，边 <span class="math inline">\((3,4)\)</span> 占用 <span class="math inline">\(4\)</span> 的方式编号为 <span class="math inline">\(4\)</span>，依次类推。方案就是从 <span class="math inline">\(2m-2\)</span>​ 种选择方式选 <span class="math inline">\(i\)</span>​ 种，限制就是编号相邻的不能同时选择。</p>
<blockquote>
<p>引理：从 <span class="math inline">\(n\)</span> 个物品中选 <span class="math inline">\(r\)</span> 个，编号相邻的不能同时选择的方案数为 <span class="math inline">\(\binom {n-r+1}r\)</span>​。</p>
<p>证明：将选择的第 <span class="math inline">\(i\)</span> 个物品的编号减去 <span class="math inline">\(i-1\)</span> 就得到了从 <span class="math inline">\(n-r+1\)</span> 个物品中选 <span class="math inline">\(r\)</span> 个的方案数。</p>
</blockquote>
<p>这部分方案数为 <span class="math inline">\(\binom{2m-i-1}i\)</span>​。</p></li>
<li><p>选边 <span class="math inline">\((1,2)\)</span>​​，那么边 <span class="math inline">\((1,2)\)</span>​​ 可以占用 <span class="math inline">\(1\)</span>​​ 或 <span class="math inline">\(2\)</span>​​，但两种方式是等价的，不妨假设占用了 <span class="math inline">\(1\)</span>​​。方案就是从 <span class="math inline">\(2m-3\)</span>​​ 种选择方式选 <span class="math inline">\(i-1\)</span>​​​​ 种，限制还是编号相邻的不能同时选择。</p>
<p>这部分方案数为 <span class="math inline">\(2\binom{2m-i-1}{i-1}\)</span>。</p></li>
</ul>
<p>对于一个大小为 <span class="math inline">\(m\)</span> 的环 <span class="math display">\[
F_i=\binom{2m-i-1}i+2\binom{2m-i-1}{i-1}=\binom{2m-i}i+\binom{2m-i-1}{i-1}
\]</span> 然后每个环的 <span class="math inline">\(F\)</span>​ 就可以 <span class="math inline">\(O(n)\)</span>​ 求了，复杂度瓶颈在于分治 <code>FFT</code>，复杂度 <span class="math inline">\(O(n\log^2n)\)</span>​​​。</p>
<p>分治 <code>FFT</code> 有两种优化：</p>
<ul>
<li>由于每个环的大小之和为 <span class="math inline">\(n\)</span>，故只有 <span class="math inline">\(O(\sqrt n)\)</span> 种大小不同的环，大小相同的环可以通过快速幂 <span class="math inline">\(O(n\log n)\)</span>​ 地算出乘积。</li>
<li>整个分治过程形成一棵二叉树的结构，总时间就是 <span class="math inline">\(\sum_{u\in \mathbb{leaf}}\text{degree}_u\text{depth}_u\)</span>​，最小化时间就是 <code>Huffman</code> 树，每次贪心地将两个次数最小的多项式乘起来。 ​​​</li>
</ul>
<h3 id="abc214h">ABC214H</h3>
<p>走到了一个强连通分量就肯定会走完内部的所有点，缩点后图就变成了 <code>DAG</code>，假设原图就是 <code>DAG</code>。</p>
<p>想到用最小费用流解决：</p>
<ul>
<li>把每个点 <span class="math inline">\(u\)</span> 拆成 <span class="math inline">\(\text{in}_u\)</span> 和 <span class="math inline">\(\text{out}_u\)</span>。</li>
<li><span class="math inline">\(\text{in}_u\)</span> 向 <span class="math inline">\(\text{out}_u\)</span> 连一条容量为 <span class="math inline">\(1\)</span>​，费用为 <span class="math inline">\(-X_u\)</span>​ 的边，再连一条容量为 <span class="math inline">\(K\)</span>，费用为 <span class="math inline">\(0\)</span> 的边。</li>
<li>对于原图中的边 <span class="math inline">\((u,v)\)</span>​，<span class="math inline">\(\text{out}_u\)</span>​ 向 <span class="math inline">\(\text{in}_v\)</span>​ 连一条容量为 <span class="math inline">\(K\)</span>​，费用为 <span class="math inline">\(0\)</span>​ 的边。</li>
<li><span class="math inline">\(S\)</span> 向 <span class="math inline">\(\text{in}_1\)</span> 连一条容量为 <span class="math inline">\(K\)</span>，费用为 <span class="math inline">\(0\)</span> 的边，<span class="math inline">\(\text{out}_u\)</span> 向 <span class="math inline">\(T\)</span> 连一条容量为 <span class="math inline">\(K\)</span>，费用为 <span class="math inline">\(0\)</span> 的边。</li>
</ul>
<p><code>SSP</code> 算法肯定是通过不了的，考虑变成 <code>Primal-Dual</code> 算法可以做的问题。</p>
<h4 id="sol-1">Sol 1</h4>
<p>初始图是一张 <code>DAG</code>，可以跑一遍 <code>DP</code> 预处理最短路作为点的初始势能。</p>
<h4 id="sol-2">Sol 2</h4>
<p>求出 <code>DAG</code> 的一组拓扑序，然后给每个点按拓扑序从大到小重新编号（也就是缩完点后的编号）。</p>
<p>容易构造一组满足差分约束的初始势能：</p>
<ul>
<li><span class="math inline">\(S\)</span>​​ 势能为 <span class="math inline">\(\sum X_u\)</span>​​，<span class="math inline">\(T\)</span>​​​ 势能为 <span class="math inline">\(0\)</span>​​。</li>
<li><span class="math inline">\(\text{in}_u\)</span>​ 的势能为 <span class="math inline">\(\sum_{i=1}^uX_i\)</span>​，<span class="math inline">\(\text{out}_u\)</span> 的势能为 <span class="math inline">\(\sum_{i=1}^{u-1}X_i\)</span>。</li>
</ul>
<p>上述两种做法复杂度都是 <span class="math inline">\(O(nK\log n)\)</span>。</p>
<h3 id="agc027e">AGC027E</h3>
<p>考虑什么样的串能变成单个字母 <span class="math inline">\(a\)</span> 或 <span class="math inline">\(b\)</span>。</p>
<p>打表发现能变成 <span class="math inline">\(a\)</span> 的串 <span class="math inline">\(S\)</span> 满足的 <span class="math inline">\(a,b\)</span> 数量关系是 <span class="math inline">\(a\)</span> 的数量减 <span class="math inline">\(b\)</span> 的数量模 <span class="math inline">\(3\)</span> 余 <span class="math inline">\(1\)</span>，并且这个条件在 <span class="math inline">\(|S|\)</span> 为偶数时也是充分条件，当 <span class="math inline">\(|S|\)</span> 为奇数时恰好多了一个串 <span class="math inline">\(ababab\cdots aba\)</span>​。​</p>
<blockquote>
<p>引理一：记 <span class="math inline">\(p(S)\)</span>​ 表示 <span class="math inline">\(S\)</span>​ 中 <span class="math inline">\(a\)</span>​ 的个数减 <span class="math inline">\(b\)</span>​ 的个数模 <span class="math inline">\(3\)</span>​，<span class="math inline">\(S\)</span>​ 能变成单个字母 <span class="math inline">\(c\)</span>​ 当且仅当：</p>
<ul>
<li><span class="math inline">\(p(S)=p(c)\)</span></li>
<li><span class="math inline">\(S=c\)</span> 或 <span class="math inline">\(S\)</span> 中有相邻的相同字母。</li>
</ul>
</blockquote>
<p>必要性显然，下面证明充分性：当 <span class="math inline">\(|S|\le 3\)</span> 时显然成立，当 <span class="math inline">\(|S|&gt;3\)</span> 时取出 <span class="math inline">\(S\)</span> 中最长的连续相同子串，不妨假设它是 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(a\)</span>，分两种情况讨论：</p>
<ul>
<li><span class="math inline">\(n \ge 4\)</span>，直接将前两个 <span class="math inline">\(a\)</span>​​ 合并，<span class="math inline">\(|S|\)</span> 减小了 <span class="math inline">\(1\)</span>，并且还满足引理条件。</li>
<li><span class="math inline">\(n\le 3\)</span>​，由于 <span class="math inline">\(|S|&gt;3\)</span>​，这个子串不可能前后都没有字母，不妨假设它不在开头，那么它前面必然是 <span class="math inline">\(b\)</span>​，将前两个 <span class="math inline">\(a\)</span>​ 合并成 <span class="math inline">\(b\)</span>，那么此时有两个 <span class="math inline">\(b\)</span> 会相邻，<span class="math inline">\(|S|\)</span> 减小了 <span class="math inline">\(1\)</span>​，并且还满足引理条件。</li>
</ul>
<p>然后问题就转化成了有多少个串 <span class="math inline">\(T\)</span> 满足以下条件：</p>
<ul>
<li>存在一种将 <span class="math inline">\(S\)</span> 划分为 <span class="math inline">\(|T|\)</span> 段的方式，使得每一段与 <span class="math inline">\(T\)</span>​​ 中的对应字母满足引理一。</li>
</ul>
<p>这个问题的主要难点在于引理一的条件二。</p>
<p>事实上，当 <span class="math inline">\(S\)</span>​ 中有相邻的相同字母时，<strong>忽略引理一的条件二</strong> 不会影响答案。</p>
<blockquote>
<p>引理二：若 <span class="math inline">\(S\)</span> 中有相邻的相同字母，<span class="math inline">\(S\)</span> 能够变成 <span class="math inline">\(T\)</span>​ 当且仅当：</p>
<ul>
<li>存在一种将 <span class="math inline">\(S\)</span>​ 划分为 <span class="math inline">\(|T|\)</span>​ 段的方式，设 <span class="math inline">\(S\)</span>​ 被划分成了 <span class="math inline">\(S_1,S_2,\cdots,S_{|T|}\)</span>​，<span class="math inline">\(T\)</span>​ 中每个字母分别为 <span class="math inline">\(T_1,T_2,\cdots,T_{|T|}\)</span>​。</li>
<li>满足 <span class="math inline">\(\forall i,p(S_i)=p(T_i)\)</span>。</li>
</ul>
</blockquote>
<p>必要性显然，下面证明充分性：</p>
<ul>
<li>假设存在一组满足上述条件的划分 <span class="math inline">\((S_1,S_2,\cdots,S_{|T|})\)</span>​。</li>
<li>将 <span class="math inline">\(S_1,S_2,\cdots,S_{|T|-1}\)</span> 的长度最小化得到新的划分 <span class="math inline">\((S_1&#39;,S_2&#39;,\cdots,S_{|T|}&#39;)\)</span>​。</li>
<li>由于最小化，容易发现 <span class="math inline">\(S_1,S_2,\cdots,S_{|T|-1}\)</span>​ 已经满足了引理一。</li>
<li>此时 <span class="math inline">\(S_{|T|}\)</span> 有可能不合法，比如 <span class="math inline">\(S_{|T|}=abab\cdots aba\)</span>，由于不合法时 <span class="math inline">\(|T|&gt;1\)</span>，可以让 <span class="math inline">\(S_{|T|}\)</span> 只保留最后一个字母，把前面的部分扔给 <span class="math inline">\(S_{|T|-1}\)</span>，于是 <span class="math inline">\(T\)</span> 删去最后一个字母对于 <span class="math inline">\(S\)</span>​ 删去最后一个字母满足引理二，故 <span class="math inline">\(S\)</span> 可以变成 <span class="math inline">\(T\)</span>。</li>
</ul>
<p>有了引理二就很好做了，特判掉 <span class="math inline">\(S\)</span> 中没有相邻的相同字母的情况，容易用一个自动机来判断 <span class="math inline">\(T\)</span>​ 是否合法，计数可以在自动机上 <code>DP</code>。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="gym101667g">Gym101667G</h3>
<p>如果两个楼梯一个朝上一个朝下，那么就没有封闭区域，如果两个朝下可以对称一下，变成两个都朝上的情况。</p>
<p>可以看出一个封闭区域开始的标志是 L 横线和 U 竖线相交，结束的标志是 U 横线和 L 竖线相交。考虑用扫描线来求出每一个封闭区域，从左到右处理每一条竖线，并维护变量 <code>isRegion</code> 表示当前竖线是否经过一个封闭区域，<code>area</code> 表示当前区域的面积：</p>
<ul>
<li>当 <code>isRegion</code> 为真时将 <code>area</code> 加上当前竖线和上一条竖线之间矩形的面积。</li>
<li>当一个封闭区域开始时清零 <code>area</code>。</li>
<li>当一个封闭区域结束时，答案累加上 <code>area</code>。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<figure>
<img src="https://i.loli.net/2021/09/08/a4fEq6tJWRbrxDy.png" alt=".png" /><figcaption aria-hidden="true">.png</figcaption>
</figure>
<h3 id="gym101667j">Gym101667J</h3>
<p>完美匹配的存在性容易想到 Hall 定理，设 <span class="math inline">\(f(S)\)</span> 表示与点集 <span class="math inline">\(S\)</span> 距离恰好等于 <span class="math inline">\(1\)</span> 的点集，问题转化为判定： <span class="math display">\[
\forall |S|\le\frac n2,|T|=\frac n2,S \cap T=\varnothing\\
|f(S)\cap T| \ge |S|
\]</span> 由于 <span class="math inline">\(|f(S)\cap T|\)</span> 最小值为 <span class="math inline">\(|f(S)|+|S|-\frac n2\)</span>，条件改写为 <span class="math inline">\(|f(S)|\ge\frac n2\)</span>。</p>
<p>考虑求 <span class="math inline">\(\min_{|S|\le \frac n2}|f(S)|\)</span>，事实上这就是图的最小点割（删去最少的点使图不连通）：</p>
<ul>
<li><span class="math inline">\(f(S)\)</span> 是 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(V-S-f(S)\)</span> 之间的一组点割。</li>
<li>任意一组点割 <span class="math inline">\(T\)</span> 割出来的多个连通块都有一个点数不超过 <span class="math inline">\(\frac n2\)</span>，设这个连通块的点集为 <span class="math inline">\(S\)</span>，那么 <span class="math inline">\(|f(S)|\le |T|\)</span>。</li>
</ul>
<p>求最小点割就是每对点都求一遍最小割：</p>
<ul>
<li>把每个点 <span class="math inline">\(u\)</span> 拆成 <span class="math inline">\(\text{in}_u\)</span> 和 <span class="math inline">\(\text{out}_u\)</span>。</li>
<li><span class="math inline">\(\text{in}_u\)</span> 向 <span class="math inline">\(\text{out}_u\)</span> 连一条代价为 <span class="math inline">\(1\)</span> 的边。</li>
<li>对于原图中的边 <span class="math inline">\((u,v)\)</span>，<span class="math inline">\(\text{out}_u\)</span> 向 <span class="math inline">\(\text{in}_v\)</span>，<span class="math inline">\(\text{out}_v\)</span> 向 <span class="math inline">\(\text{in}_u\)</span> 分别连一条代价为 <span class="math inline">\(\infty\)</span> 的边。</li>
<li>枚举两个不同的点 <span class="math inline">\(u,v\)</span>，用 <span class="math inline">\(\text{out}_u\)</span> 到 <span class="math inline">\(\text{in}_v\)</span> 的最小割更新答案。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(n^2\cdot flow)\)</span>。</p>
<p><del>负</del>优化：注意到如果最小点割小于 <span class="math inline">\(\frac n2\)</span>，那么不在割中的点就超过一半，每次随机选取一个点 <span class="math inline">\(u\)</span>，枚举点 <span class="math inline">\(v\)</span>，求 <span class="math inline">\(\text{out}_u\)</span> 到 <span class="math inline">\(\text{in}_v\)</span> 的最小割，都有大半的概率求出最优解，如果随机 <span class="math inline">\(k\)</span> 次，复杂度为 <span class="math inline">\(O(nk\cdot flow)\)</span>。</p>
<h3 id="abc215h">ABC215H</h3>
<p>如何判定当前的卷心菜是否能满足所有公司？</p>
<ul>
<li><span class="math inline">\(S\)</span> 向卷心菜 <span class="math inline">\(i\)</span> 连容量为 <span class="math inline">\(A_i\)</span> 的边。</li>
<li>公司 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(T\)</span> 连容量为 <span class="math inline">\(B_i\)</span> 的边。</li>
<li>如果 <span class="math inline">\(c_{i,j}=1\)</span>，那么卷心菜 <span class="math inline">\(i\)</span> 向公司 <span class="math inline">\(j\)</span> 连容量为 <span class="math inline">\(\infty\)</span> 的边。</li>
<li><span class="math inline">\(\max flow=\sum_{i=1}^mB_i\)</span>。</li>
</ul>
<p>也等价于 <span class="math inline">\(T\)</span> 的所有入边不是最小割。由于 <span class="math inline">\(S\)</span> 的出边很少，考虑枚举最小割中有哪些 <span class="math inline">\(S\)</span> 的出边，假设这些边为 <span class="math inline">\(mask\)</span>，割掉 <span class="math inline">\(mask\)</span> 后有一些 <span class="math inline">\(T\)</span> 的入边就不需要割了，假设这些边的容量和为 <span class="math inline">\(sum\)</span>，那么需要吃点的卷心菜数量就是 <span class="math inline">\(\sum_{i\in mask}A_i-sum+1\)</span>，要求 <span class="math inline">\(sum&gt;0\)</span>。</p>
<p>这时就可以解决第一问了，考虑对于所有 <span class="math inline">\(mask\)</span>，怎么求它们的 <span class="math inline">\(sum\)</span>，注意到 <span class="math inline">\(B_i\)</span> 贡献给 <span class="math inline">\(mask\)</span> 的条件是 <span class="math inline">\(mask\)</span> 包含所有能供应给公司 <span class="math inline">\(i\)</span> 的卷心菜，可以用子集前缀和（<code>FMT</code>）求出。然后枚举 <span class="math inline">\(mask\)</span> 用 <span class="math inline">\(\sum_{i\in mask}A_i-sum+1\)</span> 更新第一问的答案即可。</p>
<p>第二问还要进一步分析，为了不算重，我们枚举一个 <span class="math inline">\(mask\)</span> 表示被吃的卷心菜品种的集合，一个 <span class="math inline">\(mask\)</span> 可行当前仅当存在一个取到第一问答案的 <span class="math inline">\(S\)</span>，使得 <span class="math inline">\(mask\subseteq S\)</span>，这个同样可以用 <code>FMT</code> 做。设第一问答案为 <span class="math inline">\(ans\)</span>，最后是对于一个 <span class="math inline">\(mask\)</span>，求有多少种从 <span class="math inline">\(mask\)</span> 中吃掉 <span class="math inline">\(ans\)</span> 个卷心菜的方式，满足 <span class="math inline">\(mask\)</span> 中的每种卷心菜至少被吃一个。容易想到容斥，钦定一些卷心菜品种不吃，然后不考虑每种卷心菜必吃的限制，但对每个 <span class="math inline">\(mask\)</span> 都通过容斥来计算复杂度高达 <span class="math inline">\(O(3^n)\)</span>。</p>
<p>设 <span class="math inline">\(f_S\)</span> 表示有多少种从 <span class="math inline">\(S\)</span> 中吃掉 <span class="math inline">\(ans\)</span> 个卷心菜的方式，满足 <span class="math inline">\(mask\)</span> 中的每种卷心菜至少被吃一个，发现 <span class="math display">\[
\sum_{T\subseteq S}f_T=\binom{\sum_{i\in S}A_i}{ans}
\]</span> 对右边做 <code>IFMT</code> 就可以求得 <span class="math inline">\(f\)</span> 数组。</p>
<p>复杂度 <span class="math inline">\(O(n2^n+nm)\)</span>。</p>
<h3 id="agc020e">AGC020E</h3>
<p>先考虑对于一个串 <span class="math inline">\(S\)</span> 如何单独计算答案，这个不难，容易想到用区间 <code>DP</code> 做。设 <span class="math inline">\(f_{l,r}\)</span> 表示子串 <span class="math inline">\([l,r]\)</span> 的改写方案数，转移分两种：</p>
<ul>
<li><span class="math inline">\(s_l\)</span> 没有参与改写，贡献为 <span class="math inline">\(f_{l+1,r}\)</span>。</li>
<li><span class="math inline">\(s_l\)</span> 参与改写了，枚举最外层的覆盖 <span class="math inline">\(s_l\)</span> 的改写：周期 <span class="math inline">\(T\)</span> 和循环次数 <span class="math inline">\(i&gt;1\)</span>，如果合法，则贡献为 <span class="math inline">\(f_{l,l+T-1}\cdot f_{l+Ti,r}\)</span>。</li>
</ul>
<p>当尝试用区间 <code>DP</code> 做原问题的时候，发现做不了，因为当 <span class="math inline">\(s_l\)</span> 参与改写时，原来的 <span class="math inline">\(f_{l,l+T-1}\)</span> 不再是一个区间的 <code>DP</code> 值。详细地说，设 <span class="math inline">\(f(s)\)</span> 表示字符串 <span class="math inline">\(s\)</span> 的答案（子集的改写方案数总和），设 <span class="math inline">\(suf(i)\)</span> 表示 <span class="math inline">\(s\)</span> 从 <span class="math inline">\(s_i\)</span> 开始的后缀，转移为两种：</p>
<ul>
<li><p>第一个字符没有参与改写，贡献为 <span class="math inline">\((s_0+1)f(suf(1))\)</span>。</p></li>
<li><p>第一个字符参与了，枚举最外层的覆盖 <span class="math inline">\(s_l\)</span> 的改写：周期 <span class="math inline">\(T\)</span> 和循环次数 <span class="math inline">\(i&gt;1\)</span>，由于每个周期内要相等，所有子集的限制要叠加，设 <span class="math inline">\(s[l,r]\)</span> 表示 <span class="math inline">\(s\)</span> 的第 <span class="math inline">\(l\)</span> 个字符到第 <span class="math inline">\(r\)</span> 个字符的子串，设 <span class="math display">\[
t=s[0,T-1]\&amp;s[T,2T-1]\&amp;\cdots\&amp;s[T(i-1),Ti-1](\&amp;\ is\ \text{bitand})
\]</span> 那么贡献为 <span class="math inline">\(f(t)\cdot f(suf(Ti))\)</span>。</p></li>
</ul>
<p>这里的复杂度上限看起来是 <span class="math inline">\(O(2^{n+1})\)</span>，这个题最重要的地方就是，你要看出来这个做法其实是 <span class="math inline">\(O(能过)\)</span> 的，进而分析出其真正的复杂度，而不是被假上限给吓跑了。</p>
<p>下面证明，有一个上界是 <span class="math inline">\(O(n^3+2^{\frac n8})\)</span>。首先长度小于等于 <span class="math inline">\(\frac n8\)</span> 的串最多有 <span class="math inline">\(2^{\frac n8}\)</span> 个，长度大于等于 <span class="math inline">\(\frac n8\)</span> 的串最多被压缩两次（因为每压缩一次长度减半），只有三种压缩方式：</p>
<ul>
<li>先选择一个子段划分成 <span class="math inline">\(2\)</span> 段，再选择一个子段划分成 <span class="math inline">\(2\)</span> 段。</li>
<li>先选择一个子段划分成 <span class="math inline">\(2\)</span> 段，再选择一个子段划分成 <span class="math inline">\(3\)</span> 段。</li>
<li>先选择一个子段划分成 <span class="math inline">\(3\)</span> 段，再选择一个子段划分成 <span class="math inline">\(2\)</span> 段。</li>
</ul>
<p>显然第一种压缩方式可以得到的串是最多的，考虑第一种压缩方式得到的串是怎样的，形如：</p>
<p><span class="math inline">\(s[a,a+k-1]\&amp;s[a+k,a+2k-1]\&amp;s[b,b+k-1]\&amp;s[b+k,b+2k-1]\)</span></p>
<p>显然它是由 <span class="math inline">\(a,b,k\)</span> 三个参数决定的，故数量是 <span class="math inline">\(O(n^3)\)</span>，因此三种压缩方式的总和也是 <span class="math inline">\(O(n^3)\)</span>。</p>
<p>另外，通过打表可以求出长度大于 <span class="math inline">\(12\)</span> 的串更为精准的上界为 <span class="math inline">\(41703\)</span>。</p>
<h3 id="cf1562e">CF1562E</h3>
<p>先分析最长上升子序列有什么性质，假设最长上升子序列为 <span class="math display">\[
s[l_1,r_1],s[l_2,r_2],\cdots,s[l_k,r_k]
\]</span> 比较显然的是对于每个 <span class="math inline">\(l\)</span>，选择的 <span class="math inline">\(r\)</span> 是一个区间。更强的结论是存在一组最优解满足对于每个 <span class="math inline">\(l\)</span>，选择的 <span class="math inline">\(r\)</span> 是一个后缀。</p>
<p>反证法：假设对于一个 <span class="math inline">\(l\)</span>，选择的 <span class="math inline">\(r\in[r_1,r_2]\)</span>，其中 <span class="math inline">\(r_2&lt;n\)</span>，<span class="math inline">\(s[l,r_2]\)</span> 之后的子串为 <span class="math inline">\(s[l&#39;,r&#39;]\)</span>。如果 <span class="math inline">\(s[l,r_2+1]&lt;s[l&#39;,r&#39;]\)</span>，直接在 <span class="math inline">\(s[l,r_2]\)</span> 后插入 <span class="math inline">\(s[l,r_2+1]\)</span>，得到一组更优的解。否则 <span class="math inline">\(s[l,r_2]&lt;s[l&#39;,r&#39;]\le s[l,r_2+1]\)</span>，说明 <span class="math display">\[
s[l&#39;,l&#39;+r_1-l]=s[l,r_1]\\
s[l&#39;,l&#39;+r_1+1-l]=s[l,r_1+1]\\
s[l&#39;,l&#39;+r_1+2-l]=s[l,r_1+2]\\
\cdots\\
s[l&#39;,l&#39;+r_2-l]=s[l,r_2]
\]</span> 于是可以用前者们一一替换后者们，得到一组不存在 <span class="math inline">\(l\)</span> 作为左端点的子串的解。</p>
<p>然后就可以 <code>DP</code> 了，设 <span class="math inline">\(f_i\)</span> 表示以 <span class="math inline">\(s[i,n]\)</span> 结尾的最长上升子序列，转移为 <span class="math display">\[
f_i=\max_{j&lt;i\land s[j,n]&lt;s[i,n]}f_j+n-\text{lcp}(s[i,n],s[j,n])+1
\]</span> 可以预处理 <span class="math inline">\(\text{lcp}(s[i,n],s[j,n])\leftarrow \text{lcp}(s[i+1,n],s[j+1,n])\)</span>，复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h4 id="优化">优化</h4>
<p>可以优化到 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>首先是 <code>LCP</code> 怎么处理，通常是使用后缀数组的 <code>height</code> 数组，这里也可以这么处理。</p>
<p>求出后缀数组 <span class="math inline">\(SA\)</span> 和 <code>height</code> 数组，转移为 <span class="math display">\[
f_{SA_i}=\max_{j&lt;i \land SA_j&lt;SA_i}f_{SA_j}+\max_{k=j+1}^in-height_k+1
\]</span> 注意关于 <code>height</code> 的那项是一个后缀 <span class="math inline">\(\max\)</span>，考虑单调栈维护，栈内维护两元组 <span class="math inline">\((v,S)\)</span>，每次将 <span class="math inline">\((n-height_{i+1}+1,\{i\})\)</span> 压栈。假设栈顶元素为 <span class="math inline">\((v_1,S_1)\)</span>，下一个元素为 <span class="math inline">\((v_2,S_2)\)</span>，如果 <span class="math inline">\(v_1\ge v_2\)</span>，就把这两个元素合并成 <span class="math inline">\((v_1,S_1\cup S_2)\)</span>。</p>
<p>在插入 <span class="math inline">\(i\)</span> 个元素后，就可以这样计算 <span class="math inline">\(f_{i+1}\)</span>：遍历栈内每个三元组 <span class="math inline">\((v,S)\)</span>，用 <span class="math inline">\(\max_{j \in S\land SA_j\le SA_i}+v\rightarrow f_{SA_{i+1}}\)</span>。但栈内元素可能很多，不能全部遍历，考虑把 <span class="math inline">\(|S|\le \sqrt n\)</span> 的栈元素的贡献用一个数据结构 <span class="math inline">\(A\)</span> 一起维护，每个 <span class="math inline">\(|S|&gt;\sqrt n\)</span> 的元素用数据结构 <span class="math inline">\(B\)</span> 单独维护，这样就只需要遍历最多 <span class="math inline">\(\sqrt n\)</span> 个 <span class="math inline">\(|S|&gt;\sqrt n\)</span> 的栈元素，即在 <span class="math inline">\(A\)</span> 中查询一次前缀 <span class="math inline">\(\max\)</span>，<span class="math inline">\(B\)</span> 中查询 <span class="math inline">\(\sqrt n\)</span> 次前缀 <span class="math inline">\(\max\)</span>。</p>
<p>元素合并的时候需要分类维护：</p>
<ul>
<li>当 <span class="math inline">\(|S_1|+|S_2|\le \sqrt n\)</span> 时，相当于把 <span class="math inline">\(S_2\)</span> 的贡献整体加上一个正数，可以在 <span class="math inline">\(A\)</span> 中进行 <span class="math inline">\(|S_2|\)</span> 次增大修改操作，这类操作总共不超过 <span class="math inline">\(n\sqrt n\)</span> 次。</li>
<li>当 <span class="math inline">\(|S_1|&gt;\sqrt n\land |S_2|\le \sqrt n\)</span> 时，在 <span class="math inline">\(B\)</span> 中进行 <span class="math inline">\(|S_2|\)</span> 次插入新元素，这类操作总共不超过 <span class="math inline">\(n\)</span> 次。</li>
<li>当 <span class="math inline">\(|S_1|,|S_2|&gt;\sqrt n\)</span> 或 <span class="math inline">\(|S_1|,|S_2|\le \sqrt n\land |S_1|+|S_2|&gt;\sqrt n\)</span> 时，用 <span class="math inline">\(|S_1|+|S_2|\)</span> 个元素重构一个 <span class="math inline">\(B\)</span>，这类操作总共不超过 <span class="math inline">\(\sqrt n\)</span> 次。</li>
</ul>
<p>综上，当 <span class="math inline">\(A\)</span> 做到 <span class="math inline">\(O(1)\)</span> 修改，<span class="math inline">\(O(\sqrt n)\)</span> 查询，<span class="math inline">\(B\)</span> 做到 <span class="math inline">\(O(\sqrt n)\)</span> 修改，<span class="math inline">\(O(1)\)</span> 查询时，复杂度为 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>因为修改是增大值，查询是前缀 <span class="math inline">\(\max\)</span>，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 都可以通过分块实现。</p>
<h3 id="cf1562f">CF1562F</h3>
<blockquote>
<p>有个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span>，元素两两不同且值域连续，但你不知道这个序列，每次可以询问两个不同数的 <span class="math inline">\(\text{lcm}\)</span>，最多使用 <span class="math inline">\(n+5000\)</span> 次询问求出 <span class="math inline">\(A\)</span>。</p>
<p><span class="math inline">\(n\le 10^5,A_i\le 2\cdot 10^5\)</span></p>
</blockquote>
<p>如果 <span class="math inline">\(\gcd(a,b)=1\)</span>，那么 <span class="math inline">\(\text{lcm}(a,b)=ab\)</span>，如果求出了 <span class="math inline">\(A\)</span> 序列中最大的质数 <span class="math inline">\(p\)</span>，就只需要 <span class="math inline">\(n-1\)</span> 次询问就可以求出 <span class="math inline">\(A\)</span>。</p>
<p>先考虑 <span class="math inline">\(p\)</span> 存在的情况，怎么求出 <span class="math inline">\(p\)</span> 和它的位置？询问 <span class="math inline">\(\text{lcm}(A_1,A_2),\text{lcm}(A_2,A_3),\text{lcm}(A_3,A_4),\cdots,\text{lcm}(A_{n-1},n)\)</span>，所有质因子中最大的就是 <span class="math inline">\(p\)</span>，同时也可以推断出 <span class="math inline">\(p\)</span> 的位置。然后再进行 <span class="math inline">\(n-1\)</span> 次询问就求出了 <span class="math inline">\(A\)</span>，询问次数为 <span class="math inline">\(2n-2\)</span>，可以处理 <span class="math inline">\(100&lt;n\le7500\)</span>。</p>
<p>再分别考虑 <span class="math inline">\(n\le 100\)</span> 和 <span class="math inline">\(n&gt;7500\)</span> 的情况。</p>
<p><span class="math inline">\(n\le 100\)</span> 可以先两两询问 <span class="math inline">\(\text{lcm}\)</span>，再逐个确定。当 <span class="math inline">\(n&gt;3\)</span> 时至少有两个奇数，根据两个奇数的 <span class="math inline">\(\text{lcm}\)</span> 为奇数就可以确定所有数的奇偶性，再取 <span class="math inline">\(\text{lcm}\)</span> 中最大的一个，它一定是 <span class="math inline">\(\max A_i(\max A_i-1)\)</span>，结合奇偶性就可以确定最大的 <span class="math inline">\(A_i\)</span>，然后删除最大值，重复上述过程，直到 <span class="math inline">\(n=3\)</span> 时，分类讨论即可。</p>
<p>当 <span class="math inline">\(n&gt;7500\)</span> 时需要用不超过 <span class="math inline">\(5000\)</span> 次询问求出 <span class="math inline">\(A\)</span> 序列中最大的质数 <span class="math inline">\(p\)</span>，然而比较困难，考虑不找最大的质数，找一个大于 <span class="math inline">\(450\)</span> 的质数 <span class="math inline">\(p&#39;\)</span> 就行了。</p>
<p>考虑随机询问 <span class="math inline">\(\text{lcm}(A_i,A_j)\)</span>，如果它是两个大于 <span class="math inline">\(450\)</span> 的质数 <span class="math inline">\(p,q\)</span> 的乘积，那么 <span class="math inline">\(A_i,A_j\)</span> 一定就是 <span class="math inline">\(p,q\)</span>，考虑进一步确定 <span class="math inline">\(A_i\)</span>，随机一个 <span class="math inline">\(k\)</span>，如果 <span class="math inline">\(p\not|\text{lcm}(A_i,A_k)\)</span> 说明 <span class="math inline">\(A_i=p\)</span>，如果 <span class="math inline">\(q\not|\text{lcm}(A_j,A_k)\)</span> 说明 <span class="math inline">\(A_i=q\)</span>，期望的总随机次数是 <span class="math inline">\(O(\ln^2n)\)</span>。</p>
<p>考虑 <span class="math display">\[
\text{lcm}(p&#39;,x)=
\begin{cases}
x&amp;(x|p&#39;)\\
xp&#39;&amp;(x\not|p&#39;)
\end{cases}
\]</span> 如果 <span class="math inline">\(\text{lcm}(p&#39;,x)&gt;2\cdot 10^5\)</span> 就说明 <span class="math inline">\(x\not|p&#39;\)</span>，可以确定 <span class="math inline">\(x\)</span> 的值，这样至少可以确定 <span class="math inline">\(n-900\)</span> 个数，并且最大的质数 <span class="math inline">\(p\)</span> 一定被确定了，最后再用 <span class="math inline">\(p\)</span> 和剩下的数询问即可。</p>
<h3 id="auoj1760">AUOJ1760</h3>
<blockquote>
<p>有 <span class="math inline">\(n\)</span> 个物品，其中可能有一个次品，它的质量与其他物品有差异。你需要多次使用天平后回答谜题：是否存在次品？次品是偏轻还是偏重？称量时，在天平两边放相同数量的物品，以得知那边更重。</p>
<p>构造一个能够解决谜题且称量次数最少的<strong>固定</strong>称量方案。</p>
<p><span class="math inline">\(n \le 10^6\)</span></p>
</blockquote>
<p>考虑什么样的称量方案能够解决谜题。</p>
<p>假设称量次数为 <span class="math inline">\(m\)</span>，定义矩阵 <span class="math inline">\(A\)</span>： <span class="math display">\[
A_{i,j}=
\begin{cases}
-1 &amp;(第 j 次称量物品 i 在天平左边)\\
0 &amp;(第 j 次称量物品 i 不在天平上)\\
1 &amp;(第 j 次称量物品 i 在天平右边)
\end{cases}
\]</span> 首先怎么判断有没有次品：如果有物品没上过天平，哪无论如何都不能判断，否则可以判断，不存在次品当且仅当每次天平都平衡。</p>
<p>得到条件一：<span class="math inline">\(A_i\ne \{0,0,\cdots, 0\}\)</span>。</p>
<p>确定了有次品，怎么确定是哪一个：先考虑已知次品偏重时怎么确定，根据每次天平的倾斜情况，可以得到每次称量时次品在天平的哪一边或不在天平上，定义序列 <span class="math inline">\(B\)</span>： <span class="math display">\[
B_i=
\begin{cases}
-1 &amp;(第 i 次称量次品在天平左边)\\
0 &amp;(第 i 次称量次品不在天平上)\\
1 &amp;(第 i 次称量次品在天平右边)
\end{cases}
\]</span> 然后看 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(A_?\)</span> 相等就可以确定次品是哪一个。</p>
<p>但是并不知道次品偏重还是偏轻，上面说了假设次品偏重可以得到一个序列 <span class="math inline">\(B\)</span>，类似地假设次品偏轻可以得到一个序列 <span class="math inline">\(C\)</span>，并且满足 <span class="math inline">\(C=-B\)</span>（元素对于互为相反数），可以解决谜题的条件是 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(C\)</span> 不能同时和某个 <span class="math inline">\(A_i\)</span> 相等。</p>
<p>得到条件二：<span class="math inline">\(\forall i \ne j, A_i\ne A_j \land A_i \ne -A_j\)</span>。</p>
<p>由于每次称量时两边放相同数量的物品。</p>
<p>得到条件三：<span class="math inline">\(\forall j\in[1,m],\sum_{i=1}^nA_{i,j}=0\)</span>。</p>
<p>满足以上三个条件就已经合法了，考虑对于一个 <span class="math inline">\(m\)</span>，哪些 <span class="math inline">\(n\)</span> 可以构造出 <span class="math inline">\(A\)</span> 矩阵。</p>
<p>首先在前两个条件的限制下，<span class="math inline">\(n\)</span> 最大能取得 <span class="math inline">\(\frac{3^m-1}2\)</span>，再加上第三个限制，<span class="math inline">\(n\)</span> 还能不能取到 <span class="math inline">\(\frac{3^m-1}2\)</span>？</p>
<p>答案是否定的，因为对于所有的方案，<span class="math inline">\(\forall j\in[1,m],\sum_{i=1}^n|A_{i,j}|=3^{m-1}\)</span>。</p>
<blockquote>
<p>引理，<span class="math inline">\(m\)</span> 次称量可以解决谜题当且仅当 <span class="math inline">\(n\le \frac{3^m-3}2\)</span>。</p>
</blockquote>
<p>这样就可以求出最小的 <span class="math inline">\(m\)</span> 了，怎么求方案？</p>
<p>当 <span class="math inline">\(3|n\)</span> 时有一个简单的构造：定义 <span class="math inline">\(\text{next}(A)\)</span> 表示把序列 <span class="math inline">\(A\)</span> 每一项循环移位（<span class="math inline">\(-1\rightarrow 0,0\rightarrow 1,1\rightarrow -1\)</span>）后得到的序列，不难发现一个事实，<span class="math inline">\(A,\text{next}(A),\text{next}(\text{next}(A))\)</span> 这三个序列对应位置之和等于 <span class="math inline">\(0\)</span>。</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 -1 1</span><br><span class="line">-1 1 0 -1</span><br><span class="line">0 -1 1 0</span><br></pre></td></tr></table></figure>
<p>除去 <span class="math inline">\(\{-1,-1,\cdots,-1\}\)</span> 和 <span class="math inline">\(\{1,1,\cdots,1\}\)</span>，把每三个这样的序列分为一组，恰好可以分成 <span class="math inline">\(\frac {3^m-3}3\)</span> 组，其中两两组互相为相反序列，于是删去一 半这样的组，恰好可以得到一个合法的矩阵 <span class="math inline">\(A\)</span>。</p>
<h3 id="思路一">思路一</h3>
<p>当 <span class="math inline">\(3\not|n\)</span> 时，感觉问题非常困难，考虑模拟退火：</p>
<ul>
<li>用 <span class="math inline">\(\sum_{j=1}^m|\sum_{i=1}^nA_{i,j}|\)</span> 作为一个解的权值，问题就是求权值最小的解。</li>
<li>还是先分组，取若干个组和一个不完整的组作为初始解。</li>
<li>每次以以下方式之一生成一个新解，如果新解更优则接受新解，否则以很低的概率接受新解。
<ul>
<li>选择一个 <span class="math inline">\(i\)</span>，将 <span class="math inline">\(A_i\)</span> 替换成 <span class="math inline">\(-A_i\)</span>。</li>
<li>选择一个 <span class="math inline">\(i\)</span>，选择一个 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(-B\)</span> 都没有在 <span class="math inline">\(A\)</span> 中出现过，令 <span class="math inline">\(A_i=B\)</span>。</li>
</ul></li>
</ul>
<p>效率还行，但不稳定，对于少数 <span class="math inline">\(n\)</span> 速度极慢，<span class="math inline">\(n\le 10^4\)</span> 是完全没有问题的。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lf = <span class="keyword">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gen</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ll k = <span class="number">0x9ddfea08eb382d69</span>ull;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">3</span>) x *= k, x ^= x &gt;&gt; <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">return</span> x * k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll s = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (s += <span class="built_in">gen</span>(s)) &amp; INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">2</span>, t = <span class="number">9</span>, nw[<span class="number">15</span>], idx, A[<span class="number">2500000</span>][<span class="number">15</span>], c[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, <span class="number">4</span>) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">1</span>, m) A[idx][k] = (nw[k] + j) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(idx == t) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">-1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        nw[i] = j, <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == t) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(t - <span class="number">3</span> &gt;&gt; <span class="number">1</span> &lt; n) m++, t *= <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">wrt</span>(m, <span class="number">10</span>);</span><br><span class="line">    t = t - <span class="number">1</span> &gt;&gt; <span class="number">1</span>, <span class="built_in">dfs</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">rep</span>(j, <span class="number">1</span>, m) c[j] += A[i][j];</span><br><span class="line">    <span class="keyword">int</span> su = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) su += <span class="built_in">abs</span>(c[i]);</span><br><span class="line">    <span class="keyword">while</span>(su) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rnd</span>() % n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rnd</span>() % t &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, m) d += <span class="built_in">abs</span>(c[j] - <span class="number">2</span> * A[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(d &lt; su || <span class="built_in">rnd</span>() % n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                su = d;</span><br><span class="line">                <span class="built_in">rep</span>(j, <span class="number">1</span>, m) c[j] -= <span class="number">2</span> * A[i][j], A[i][j] *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">rnd</span>() % (t - n) + n + <span class="number">1</span>, d = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, m) d += <span class="built_in">abs</span>(c[j] - A[i][j] + A[k][j]);</span><br><span class="line">            <span class="keyword">if</span>(d &lt; su || <span class="built_in">rnd</span>() % n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                su = d;</span><br><span class="line">                <span class="built_in">rep</span>(j, <span class="number">1</span>, m) c[j] -= A[i][j] - A[k][j], <span class="built_in">swap</span>(A[i][j], A[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">per</span>(j, m, <span class="number">1</span>) v = v * <span class="number">3</span> + A[i][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">wrt</span>(v, <span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="思路二">思路二</h3>
<p>另外，还有一种优秀的乱搞做法。</p>
<ul>
<li>先分组，取若干个组和一个不完整的组作为初始解，那么 <span class="math inline">\(\forall j\in[1,m],|\sum_{i=1}^nA_{i,j}|\le 1\)</span>。</li>
<li>对于每个 <span class="math inline">\(j\)</span>，如果 <span class="math inline">\(\sum_{i=1}^nA_{i,j}=-1\)</span>，找到一个 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(A_{i,j}&lt;1\)</span> 并且将 <span class="math inline">\(A_{i,j}\)</span> 增大一后仍然合法，然后将 <span class="math inline">\(A_{i,j}\)</span> 加一。</li>
</ul>
<p>会有极个别 <span class="math inline">\(n\)</span> 求出的解不合法，<span class="math inline">\(10^6\)</span> 以内应该不会超过 <span class="math inline">\(10\)</span> 个，而且都比较小，取决于初始解（所有可以通过）。</p>
<p>结合思路一可以构造出 <span class="math inline">\(10^6\)</span> 内的所有 <span class="math inline">\(n\)</span>。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">2</span>, t = <span class="number">9</span>, nw[<span class="number">15</span>], idx, A[<span class="number">1000005</span>], c[<span class="number">15</span>], as;</span><br><span class="line"><span class="keyword">bool</span> vs[<span class="number">1600000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i) <span class="built_in">rep</span>(j, <span class="number">-1</span>, <span class="number">1</span>) &#123; nw[i] = j, <span class="built_in">dfs</span>(i - <span class="number">1</span>); <span class="keyword">if</span>(idx == n) <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">per</span>(k, m, <span class="number">1</span>) x = x * <span class="number">3</span> + (j + nw[k]) % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(!x || vs[x] || idx == n) <span class="keyword">break</span>;</span><br><span class="line">        A[++idx] = x, vs[x] = vs[t - x] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, m) c[k] += (j + nw[k]) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(t - <span class="number">3</span> &gt;&gt; <span class="number">1</span> &lt; n) m++, t *= <span class="number">3</span>;</span><br><span class="line">    t--, vs[t / <span class="number">2</span>] = <span class="number">1</span>, <span class="built_in">wrt</span>(m, <span class="number">10</span>), nw[m] = <span class="number">-1</span>, <span class="built_in">dfs</span>(m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) as += <span class="built_in">abs</span>(c[i]);</span><br><span class="line">        <span class="keyword">int</span> th = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!c[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> v = A[i] / th % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">auto</span> Try = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nw = A[i] + x * th;</span><br><span class="line">                    <span class="keyword">if</span>(vs[nw]) <span class="keyword">return</span>;</span><br><span class="line">                    vs[A[i]] = vs[t - A[i]] = <span class="number">0</span>, vs[nw] = vs[t - nw] = <span class="number">1</span>;</span><br><span class="line">                    as -= <span class="built_in">abs</span>(c[j]), c[j] += x, v += x, as += <span class="built_in">abs</span>(c[j]), A[i] = nw;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">if</span>(v &lt; <span class="number">2</span> &amp;&amp; c[j] &lt; <span class="number">0</span>) <span class="built_in">Try</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(v &gt; <span class="number">0</span> &amp;&amp; c[j] &gt; <span class="number">0</span>) <span class="built_in">Try</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            th *= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">wrt</span>(A[i], <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="思路三">思路三</h3>
<p>这是官方解法，说是爬山算法，但感觉比较微妙，因为稍微扰动一下初始解就会有极个别 <span class="math inline">\(n\)</span> 跑不出来，流程是这样的：</p>
<ul>
<li><p>用 <span class="math inline">\(\sum_{j=1}^m|\sum_{i=1}^nA_{i,j}|\)</span> 作为一个解的权值，问题就是求权值最小的解。</p></li>
<li><p><span class="math inline">\(A\)</span> 矩阵初始为空，然按字典序<strong>从大到小</strong>枚举长度为 <span class="math inline">\(m\)</span>，值域为 <span class="math inline">\(\{-1,0,1\}\)</span> 的序列 <span class="math inline">\(B\)</span>，如果 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(-B\)</span> 没有在 <span class="math inline">\(A\)</span> 出现过，就把 <span class="math inline">\(B,\text{next}(B),\text{next}(\text{next}(B))\)</span> 依次加入 <span class="math inline">\(A\)</span> 末尾，加入 <span class="math inline">\(n\)</span> 行时终止。那么 <span class="math inline">\(\forall j\in[1,m],|\sum_{i=1}^nA_{i,j}|\le 1\)</span>。</p></li>
<li><p>对当前解重复进行如下修改，直到权值为 <span class="math inline">\(0\)</span>：</p>
<p>从小到大依次枚举 <span class="math inline">\(j\)</span> 和 <span class="math inline">\(i\)</span>，然后进行以下操作：</p>
<ul>
<li>如果 <span class="math inline">\(\sum_{i=1}^nA_{i,j}=-1\land A_{i,j}&lt;1\)</span>，尝试让 <span class="math inline">\(A_{i,j}\)</span> 加一。</li>
<li>如果 <span class="math inline">\(\sum_{i=1}^nA_{i,j}=1\)</span>，尝试让 <span class="math inline">\(A_{i,j}=0\)</span>。</li>
</ul></li>
</ul>
<p>实测能构造出 <span class="math inline">\(10^6\)</span> 内的所有 <span class="math inline">\(n\)</span>。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> streambuf* out = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pc out -&gt; sputc</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c[<span class="number">11</span>]; <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> c[++sz] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(sz) <span class="built_in">pc</span>(c[sz--] + <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">pc</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">2</span>, t = <span class="number">9</span>, nw[<span class="number">15</span>], idx, A[<span class="number">797170</span>], c[<span class="number">15</span>], as;</span><br><span class="line"><span class="keyword">bool</span> vs[<span class="number">1600000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i) <span class="built_in">per</span>(j, <span class="number">1</span>, <span class="number">-1</span>) &#123; nw[i] = j, <span class="built_in">dfs</span>(i - <span class="number">1</span>); <span class="keyword">if</span>(idx == n) <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">per</span>(k, m, <span class="number">1</span>) x = x * <span class="number">3</span> + (j + nw[k]) % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == t || vs[x] || idx == n) <span class="keyword">break</span>;</span><br><span class="line">        A[++idx] = x, vs[x] = vs[t - x] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, m) c[k] += (j + nw[k]) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(t - <span class="number">3</span> &gt;&gt; <span class="number">1</span> &lt; n) m++, t *= <span class="number">3</span>;</span><br><span class="line">    t--, vs[t / <span class="number">2</span>] = <span class="number">1</span>, <span class="built_in">wrt</span>(m, <span class="number">10</span>), nw[m] = <span class="number">1</span>, <span class="built_in">dfs</span>(m - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) as += <span class="built_in">abs</span>(c[i]);</span><br><span class="line">    <span class="keyword">while</span>(as) &#123;</span><br><span class="line">        <span class="keyword">int</span> th = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!c[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> v = A[i] / th % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">auto</span> Try = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nw = A[i] + x * th;</span><br><span class="line">                    <span class="keyword">if</span>(vs[nw]) <span class="keyword">return</span>;</span><br><span class="line">                    vs[A[i]] = vs[t - A[i]] = <span class="number">0</span>, vs[nw] = vs[t - nw] = <span class="number">1</span>;</span><br><span class="line">                    as -= <span class="built_in">abs</span>(c[j]), c[j] += x, v += x, as += <span class="built_in">abs</span>(c[j]), A[i] = nw;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">if</span>(v &lt; <span class="number">2</span> &amp;&amp; c[j] &lt; <span class="number">0</span>) <span class="built_in">Try</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(v &gt; <span class="number">0</span> &amp;&amp; c[j] &gt; <span class="number">0</span>) <span class="built_in">Try</span>(-v);</span><br><span class="line">            &#125;</span><br><span class="line">            th *= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">wrt</span>(A[i], <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="auoj1761">AUOJ1761</h3>
<blockquote>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span> （下标从 <span class="math inline">\(1\)</span> 开始）和一个长度为 <span class="math inline">\(m\)</span> 的序列 <span class="math inline">\(B\)</span>（下标从 <span class="math inline">\(0\)</span> 开始）。</p>
<p><span class="math inline">\(A\)</span> 初始全为 <span class="math inline">\(0\)</span>，每一天 <span class="math inline">\(A_i\)</span> 会增加 <span class="math inline">\(i\)</span>，在第 <span class="math inline">\(j\)</span> 天，如果 <span class="math inline">\(A_i&gt;B_{j\bmod m}\)</span>，则进行一次操作，令 <span class="math inline">\(A_i=B_{j\bmod m}\)</span>。</p>
<p><span class="math inline">\(q\)</span> 次询问，每次询问前 <span class="math inline">\(d_i\)</span> 天总共会进行多少次操作。</p>
<p><span class="math inline">\(n,m,q\le 3\cdot 10^5,d_i\le 3\cdot 10^{12},t_i\le 10^{18}\)</span></p>
</blockquote>
<p>由于 <span class="math inline">\(d_i\)</span> 很大，应该会用到操作的周期性，事实上对于每个 <span class="math inline">\(A_i\)</span>，从第一次操作它开始周期就为 <span class="math inline">\(m\)</span>。</p>
<blockquote>
<p>引理：假设在第 <span class="math inline">\(p\)</span> 天操作了 <span class="math inline">\(A_i\)</span>，那么它在第 <span class="math inline">\(p+m\)</span> 天又会被操作。</p>
</blockquote>
<p>证明：第 <span class="math inline">\(p-m\)</span> 天 <span class="math inline">\(A_i\)</span> 小于等于第 <span class="math inline">\(p\)</span> 天的 <span class="math inline">\(A_i=B_{p \bmod m}\)</span>，感性理解 <span class="math inline">\(A_i\)</span> 越小在 <span class="math inline">\(m\)</span> 天后越容易操作，第 <span class="math inline">\(p\)</span> 天操作了，第 <span class="math inline">\(p+m\)</span> 天肯定要操作。</p>
<p>设 <span class="math inline">\(A_i\)</span> 第一次操作在第 <span class="math inline">\(p_i\)</span> 天，那么在第 <span class="math inline">\(p_i,p_i+m,p_i+2m,pi+3m,\cdots\)</span> 都会操作，于是周期就是 <span class="math inline">\(m\)</span>。</p>
<p>不难发现 <span class="math inline">\(p_i\)</span> 是递减的，因为任意时刻 <span class="math inline">\(A\)</span> 序列都是递增的，每次操作的都是一段后缀。那么对于一次询问，进行过操作的 <span class="math inline">\(A_i\)</span> 是一段后缀，只要求出了 <span class="math inline">\(p_i\)</span> 就可以二分出这个后缀，下面考虑怎么求 <span class="math inline">\(p_i\)</span>。</p>
<p>设 <span class="math inline">\(pos\)</span> 表示 <span class="math inline">\(B\)</span> 中最小元素的位置，对于每个 <span class="math inline">\(i\)</span> 可以直接算出 <span class="math inline">\(A_i\)</span> 第一次被 <span class="math inline">\(B_{pos}\)</span> 操作的时间 <span class="math inline">\(T_i\)</span>，那么 <span class="math inline">\(p_i\in[T_i-m+1,T_i]\)</span>，设 <span class="math inline">\(p_i=T_i-m+k_i\)</span>，<span class="math inline">\(k_i\)</span> 就是最小的 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(ix+(T_i-m)i&gt;B_{pos+x}\)</span>，考虑在线段树上每个结点 <span class="math inline">\([l,r]\)</span> 维护 <span class="math inline">\(\min_{j=l}^rB_{pos+j}-ij\)</span>，每次只需要二分出最小的 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(\min_{j=1}^x\{B_{pos+j}-ij\}&lt;(T_i-m)i\)</span>，注意到式子是可以斜率优化的，随着 <span class="math inline">\(i\)</span> 的增大，对每个结点用一个单调队列维护下凸包。复杂度为 <span class="math inline">\(O(n\log n)\)</span>。这样就求出了 <span class="math inline">\(p_i\)</span>。</p>
<p>对于询问 <span class="math inline">\(d\)</span>，每个 <span class="math inline">\(A_i\)</span> 的贡献可以分为若干个完整周期和一个不完整周期。对于完整周期，由于周期长度为 <span class="math inline">\(m\)</span>，可以用线段树直接模拟周期中每一天的修改，然后就知道每个 <span class="math inline">\(A_i\)</span> 一个周期被清理多少次。对于不完整周期，可以把所有询问离线下来，然后用一个线段树模拟这个不完整周期，大致思路是在 <span class="math inline">\(p_i\bmod m\)</span> 天插入 <span class="math inline">\(A_i\)</span>，在 <span class="math inline">\(d\bmod m\)</span> 天进行查询，但有可能 <span class="math inline">\(d\bmod m&lt;p_i\bmod m\)</span>，所以实现上需要分类讨论一下。</p>
<h3 id="codechef-btree">CodeChef-btree</h3>
<blockquote>
<p>定义 <span class="math inline">\(S(u,k)\)</span> 表示与 <span class="math inline">\(u\)</span> 距离不超过 <span class="math inline">\(k\)</span> 的点集。</p>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，<span class="math inline">\(q\)</span> 次询问，每次询问 <span class="math inline">\(|S(u_1,k_1)\cup S(u_2,k_2)\cup S(u_3,k_3)\cup \cdots \cup S(u_{m_i},k_{m_i})|\)</span> 。</p>
<p><span class="math inline">\(n,q\le 5\cdot 10^4,\sum_{i=1}^qm_i\le 5\cdot 10^5\)</span>。</p>
</blockquote>
<p>考虑 <span class="math inline">\(|S(u,k)|\)</span> 怎么求，可以离线后点分治，也可以建出点分树在线求。</p>
<h4 id="sol-1-1">Sol 1</h4>
<p>先对 <span class="math inline">\(u_1,u_2,u_3,\cdots,u_{m_i}\)</span> 建虚树，假设虚树中非关键点的半径为 <span class="math inline">\(0\)</span>。</p>
<p>如果 <span class="math inline">\((u_1,k_1),(u_2,k_2)\)</span> 满足 <span class="math inline">\(k_1-\text{dis}(u_1,u_2)&gt;k_2\)</span>，就说明了 <span class="math inline">\(S(u_2,k_2)\subsetneq S(u_1,k_1)\)</span>，即 <span class="math inline">\(S(u_2,k_2)\)</span> 是没用的，但不能删去它，而是令 <span class="math inline">\(k_2=k_1-\text{dis}(u_1,u_2)\)</span>。</p>
<p>考虑对所有点的半径更新，直到不能更新为止，一种方法是像 <code>Dijkstra</code> 一样每次取半径最大的点更新周围点的半径，另一种做法是树形 <code>DP</code>，自底向上更新一遍，再自顶向下更新一遍。</p>
<p>然后发现一个很好的性质，记虚树点集为 <span class="math inline">\(V\)</span>，边集为 <span class="math inline">\(E\)</span>，<span class="math inline">\(u\)</span> 的半径为 <span class="math inline">\(r_u\)</span>，答案等于 <span class="math inline">\(\sum_{u\in V}|S(u,r_u)|-\sum_{(u,v)\in E}|S(u,r_u)\cap S(v,r_v)|\)</span>。证明很简单，考虑自顶向下将每个 <span class="math inline">\(S(u,r_u)\)</span> 并入，每次新增的点数为 <span class="math inline">\(|S(u,r_u)|-|S(u,r_u)\cap S(fa_u,r_{fa_u})|\)</span>。</p>
<p><span class="math inline">\(|S(u,r_u)|\)</span> 可以在点分树上查询，<span class="math inline">\(|S(u,r_u)\cap S(v,r_v)|\)</span> 是一个 <span class="math inline">\(S(w,r)\)</span>，其中 <span class="math inline">\(w\)</span> 可能是顶点，也可能是一条边的中点，如果在每条边上新建一个点，<span class="math inline">\(w\)</span> 就一定是顶点了。</p>
<p>复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>
<h4 id="sol-2-1">Sol 2</h4>
<p>答案求的是并集的大小，是 <code>bitset</code> 可以优化的。</p>
<p>注意到 <span class="math inline">\(nq \le 2.5\cdot 10^9,n\sum_{i=1}^qm_i\le 2.5\cdot 10^{10}\)</span>，一个时间复杂度 <span class="math inline">\(O(\frac{n\sum_{i=1}^qm_i}\omega)\)</span>，空间复杂度 <span class="math inline">\(O(\frac{nq}\omega)\)</span> 的算法是可以通过的。</p>
<p>怎么快速求 <span class="math inline">\(S(u,k)\)</span> 的 <code>bitset</code> 形式，希望能做到 <span class="math inline">\(O(\frac n\omega)\)</span>。</p>
<p>考虑把所有询问离线下来，在点分治的过程中每个 <span class="math inline">\(S(u,k)\)</span> 都被分解成了 <span class="math inline">\(O(\log n)\)</span> 个形如”深度不超过 <span class="math inline">\(d\)</span> 的点集”的并，如果每次都把”深度不超过 <span class="math inline">\(d\)</span> 的点集”并上去，求 <span class="math inline">\(S(u,k)\)</span> 就是 <span class="math inline">\(O(\frac{n\log n}\omega)\)</span> 的，不太行。注意到这 <span class="math inline">\(O(\log n)\)</span> 个点集的范围分别为 <span class="math inline">\(n,\frac n2,\frac n4,\frac n8,\cdots\)</span>，总和是 <span class="math inline">\(2n\)</span> 的，但每个点集编号的范围都是 <span class="math inline">\([1,n]\)</span>，每次并上去就太不优秀了，如何缩小编号的范围？只需要把所有点按照点分树的 <code>DFS</code> 序重新编号，那么每个点集编号的范围就缩小到了 <span class="math inline">\(n,\frac n2,\frac n4,\frac n8,\cdots\)</span>，每次只需要并到一个区间上，复杂度 <span class="math inline">\(O(\frac n\omega)\)</span>。</p>
<p>做法就是对每个询问开一个 <code>bitset</code>，点分治的过程中更新 <code>bitset</code> 的一个区间，答案就是对于 <code>bitset</code> 的 <code>popcount</code>，需要用 <code>unsigned long long</code> 实现 <code>bitset</code>，<code>popcount</code> 也建议手写，预处理 <span class="math inline">\([0,65536)\)</span> 内所有数的 <code>popcount</code>，把每个 <code>unsigned long long</code> 拆成四个 <span class="math inline">\([0,65536)\)</span> 内的数。</p>
<p>实测比 Sol 1 快。</p>
<h3 id="ural2118">URAL2118</h3>
<blockquote>
<p>给定前 <span class="math inline">\(k\)</span> 个字母的 <span class="math inline">\(01\)</span> 前缀编码（不存在一个编码是另一个编码的前缀）。</p>
<p>给定字符串 <span class="math inline">\(s\)</span>，设其解码后的 <span class="math inline">\(01\)</span> 串为 <span class="math inline">\(S\)</span>，求最多能将 <span class="math inline">\(S\)</span> 划分为多少段使得每一段都无法解码，无解输出 <span class="math inline">\(-1\)</span>。</p>
<p><span class="math inline">\(k \le 52, n\le 10^6\)</span></p>
</blockquote>
<p>首先考虑两种特殊情况：</p>
<ul>
<li>编码中既有 <span class="math inline">\(0\)</span>，也有 <span class="math inline">\(1\)</span>，那 <span class="math inline">\(S\)</span> 无论怎么划分都可以解码。</li>
<li>编码中既没 <span class="math inline">\(0\)</span>，也没 <span class="math inline">\(1\)</span>，那么答案为 <span class="math inline">\(|S|\)</span>。</li>
</ul>
<p>剩下的情况为：有 <span class="math inline">\(0\)</span> 无 <span class="math inline">\(1\)</span> 和有 <span class="math inline">\(1\)</span> 无 <span class="math inline">\(0\)</span>，由于对称性，只考虑有 <span class="math inline">\(0\)</span> 无 <span class="math inline">\(1\)</span>。</p>
<p>首先答案的上界为 <span class="math inline">\(1\)</span> 的个数，因为全 <span class="math inline">\(0\)</span> 的一段是可以被解码的。</p>
<p>如果最后一位为 <span class="math inline">\(1\)</span>，那么在每个 <span class="math inline">\(1\)</span> 后面断开，就可以取到这个上界。</p>
<p>如果最后一位为 <span class="math inline">\(0\)</span>，假设最后一段 <span class="math inline">\(T\)</span>，可以说明存在最优解满足 <span class="math inline">\(T\)</span> 前面是 <span class="math inline">\(1\)</span>：假设 <span class="math inline">\(T\)</span> 前面有 <strong>连续</strong> 的 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(0\)</span>，前面总共有 <span class="math inline">\(y\)</span> 个 <span class="math inline">\(1\)</span>。那么答案的上界为 <span class="math inline">\(y+1\)</span>，把这 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(0\)</span> 加入 <span class="math inline">\(T\)</span>，然后在 <span class="math inline">\(T\)</span> 前面的每个 <span class="math inline">\(1\)</span> 后面断开就可以到达这个上界。</p>
<p>如果 <span class="math inline">\(T\)</span> 前面有 <span class="math inline">\(y\)</span> 个 <span class="math inline">\(1\)</span>，最大段数就是 <span class="math inline">\(y+1\)</span>，问题就是求最大的 <span class="math inline">\(y\)</span>，假设 <span class="math inline">\(T&#39;\)</span> 是最短的无法被解码的后缀，可以说明最大的 <span class="math inline">\(y\)</span> 等于 <span class="math inline">\(T&#39;\)</span> 前面 <span class="math inline">\(1\)</span> 的个数：由于 <span class="math inline">\(|T|\ge |T&#39;|\)</span>，所以 <span class="math inline">\(y\)</span> 不会超过 <span class="math inline">\(T&#39;\)</span> 前面 <span class="math inline">\(1\)</span> 的个数，另外，令 <span class="math inline">\(T=T&#39;前面极长的一段0+T&#39;\)</span>，<span class="math inline">\(y\)</span> 就可以取到这个上界。</p>
<p>问题转化成了求 <span class="math inline">\(T&#39;\)</span>，那么 <span class="math inline">\(T&#39;\)</span> 的任何前缀都无法解码，否则 <span class="math inline">\(T&#39;\)</span> 不是最短的，记 <span class="math inline">\(suffix(i)\)</span> 表示 <span class="math inline">\(S\)</span> 长度为 <span class="math inline">\(i\)</span> 的后缀，问题就是依次判断 <span class="math inline">\(suffix(1),suffix(2),suffix(3),\cdots\)</span> 是否有前缀可以被解码，<code>AC</code> 自动机即可。</p>
<p>复杂度 <span class="math inline">\(O(nk)\)</span>。</p>
<h3 id="graph-subpaths">Graph Subpaths</h3>
<blockquote>
<p>没有提交地址。</p>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的有向无环图，再给定 <span class="math inline">\(k\)</span> 条路径，每条路径长度为 <span class="math inline">\(l_i\)</span>，一条合法路径不包含这 <span class="math inline">\(k\)</span> 条路径。</p>
<p>对于 <span class="math inline">\(i \in [2,n]\)</span>，求 <span class="math inline">\(1\rightarrow i\)</span> 的合法路径条数。</p>
<p><span class="math inline">\(n,m,\sum_{i=1}^kl_i \le 10^5\)</span></p>
</blockquote>
<h3 id="sol-1-2">Sol 1</h3>
<p>首先把所有边反向，就转化成了求 <span class="math inline">\(i\rightarrow 1\)</span> 的合法路径条数。</p>
<p>对于边 <span class="math inline">\((u,v)\)</span>，标记它的权值为 <span class="math inline">\(v\)</span>，设 <span class="math inline">\(T_i\)</span> 表示 <span class="math inline">\(i\rightarrow 1\)</span> 所有合法路径组成的 <code>trie</code>，考虑怎么按拓扑序求出每一个 <span class="math inline">\(T_u\)</span>，对于边 <span class="math inline">\((u,v)\)</span>，<span class="math inline">\(T_v\)</span> 是已经求过了，把 <span class="math inline">\(T_v\)</span> 复制到根的儿子，但这样会有一些以 <span class="math inline">\(u\)</span> 为起点的不合法路径，需要删除这些路径：从 <span class="math inline">\(T_u\)</span> 的根出发沿着不合法路径走，把以终点为根的子树删除即可。<span class="math inline">\(u\)</span> 的答案就是 <span class="math inline">\(T_u\)</span> 的叶子个数。</p>
<p>由于 <span class="math inline">\(T_u\)</span> 非常大，当然不能直接存下来，可行的方法是用可持久化的 <code>trie</code>，对于边 <span class="math inline">\((u,v)\)</span>，只需要从 <span class="math inline">\(T_u\)</span> 的根向 <span class="math inline">\(T_v\)</span> 连一条边就行了，而不用复制整棵 <span class="math inline">\(T_v\)</span>，删除子树也只需要对路径上的结点建新版本。</p>
<p>一个问题是儿子列表的维护，如果用链表维护的话，删除子树时新建的结点需要从原版本复制整个链表，复杂度可能达到 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>用主席树维护儿子列表就可以 <span class="math inline">\(O(n\log n)\)</span> 地新建结点。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="sol-2-2">Sol 2</h3>
<p>对所有路径建 <code>AC</code> 自动机，不难想到一个 <span class="math inline">\(O(n^2)\)</span> 状态的 <code>DP</code>，设 <span class="math inline">\(f_{i,u}\)</span> 表示在原图中走到 <span class="math inline">\(i\)</span>，<code>AC</code> 自动机上走到 <code>u</code>，且没有经过 <code>AC</code> 自动机上终止结点的路径条数。</p>
<p>由于 <code>AC</code> 自动机上的点对应唯一原图中的点的，所以 <code>DP</code> 状态定义成 <span class="math inline">\(f_u\)</span> 就可以转移了。</p>
<p>由于建 <code>AC</code> 自动机需要主席树，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="zoj3390">ZOJ3390</h3>
<blockquote>
<p>对于两棵树 <span class="math inline">\(T_1,T_2\)</span>，定义 <span class="math inline">\(T_1+T_2\)</span> 表示把根合并，<span class="math inline">\(T_1\cdot T_2\)</span> 表示把 <span class="math inline">\(T_1\)</span> 中每个结点换成 <span class="math inline">\(T_2\)</span>，<span class="math inline">\(T_1=T_2\)</span> 表示树同构。</p>
<p>给定树 <span class="math inline">\(A,B,C\)</span>，求 <span class="math inline">\(X,Y\)</span> 满足 <span class="math inline">\(AX+BY=C\)</span>。</p>
<p><span class="math inline">\(|A|,|B|,|C| \le 10^5\)</span></p>
</blockquote>
<p>设 <span class="math inline">\(height(T)\)</span> 表示 <span class="math inline">\(T\)</span> 的树高（最深叶子到根的距离）。</p>
<p>可以发现 <span class="math inline">\(height(T_1+T_2)=\max(height(T_1),height(T_2)),height(T_1\cdot T_2)=height(T_1)+height(T_2)\)</span>。</p>
<p>那么 <span class="math inline">\(\max(height(A)+height(X),height(B)+height(Y))=height(C)\)</span>，假设 <span class="math inline">\(height(A)+height(X)=height(C)\)</span>（另一种情况是一样的）。</p>
<p>这样就知道了 <span class="math inline">\(height(X)\)</span>，考虑怎么求 <span class="math inline">\(X\)</span>，很简单，假设 <span class="math inline">\(u\)</span> 为 <span class="math inline">\(C\)</span> 中最深叶子的 <span class="math inline">\(height(X)\)</span> 级祖先，以 <span class="math inline">\(u\)</span> 为根的子树就是 <span class="math inline">\(X\)</span>，这样就知道了 <span class="math inline">\(AX\)</span>，然后就可以求出 <span class="math inline">\(BY\)</span>，再用类似的方法就可以求出 <span class="math inline">\(Y\)</span> 了。</p>
<p>虽然思路很简单，但是有一定实现难度，求 <span class="math inline">\(BY\)</span> 时树的“减法“，以及判定答案是否合法都需要用到树哈希。</p>
<p>树哈希公式： <span class="math display">\[
f_u=1+\sum_{v\in son(u)}f_v\cdot \text{prime}(size_v)
\]</span> 其中 <span class="math inline">\(\text{prime}(i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个质数。</p>
<p><strong>注：</strong>对于两棵大小不同的树 <span class="math inline">\(T_1,T_2\)</span>，<span class="math inline">\(f_{T_1}=f_{T_2}\)</span> 是可能的，因此哈希应当和子树大小捆绑在一起。</p>
<p><code>Generator</code> ：参数 <span class="math inline">\(T,A,B,C,D\)</span> 可调，分别表示数据组数和树 <span class="math inline">\(A,X,B,Y\)</span> 的大小。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) int((x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc o * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmi(a, b) (a = min(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cma(a, b) (a = max(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ub upper_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs binary_search</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop __builtin_popcount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpop __builtin_popcountll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ctz __builtin_ctz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llctz __builtin_ctzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clz __builtin_clz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llclz __builtin_clzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> par __builtin_parity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpar __builtin_parityll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lf = <span class="keyword">double</span>;</span><br><span class="line"><span class="comment">// using P = pair&lt;int, int&gt;;</span></span><br><span class="line"><span class="keyword">using</span> V = vector&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="comment">// using cmp = complex&lt;lf&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gen</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ll k = <span class="number">0x9ddfea08eb382d69</span>ull;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">3</span>) x *= k, x ^= x &gt;&gt; <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">return</span> x * k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll s = <span class="built_in">time</span>(<span class="number">0</span>) + (ll)<span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">    <span class="keyword">return</span> (s += <span class="built_in">gen</span>(s)) &amp; INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">tmul</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>, su = n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? i : b[j] + su - <span class="number">1</span>);</span><br><span class="line">        su += m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">tplus</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? <span class="number">1</span> : b[j] + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>, A = <span class="number">5</span>, B = <span class="number">5</span>, C = <span class="number">5</span>, D = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">100000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T);</span><br><span class="line">    <span class="built_in">rep</span>(kase, <span class="number">1</span>, T) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rnd</span>() % A + <span class="number">1</span>, b = <span class="built_in">rnd</span>() % B + <span class="number">1</span>, c = <span class="built_in">rnd</span>() % C + <span class="number">1</span>, d = <span class="built_in">rnd</span>() % D + <span class="number">1</span>;</span><br><span class="line">        V t1&#123;<span class="number">0</span>&#125;, t2&#123;<span class="number">0</span>&#125;, t3&#123;<span class="number">0</span>&#125;, t4&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> get = [](V&amp; t, <span class="keyword">int</span> n) &#123; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) t.<span class="built_in">pb</span>(i &gt; <span class="number">1</span> ? <span class="built_in">rnd</span>() % (i - <span class="number">1</span>) + <span class="number">1</span> : <span class="number">0</span>); &#125;;</span><br><span class="line">        <span class="built_in">get</span>(t1, a), <span class="built_in">get</span>(t2, b), <span class="built_in">get</span>(t3, c), <span class="built_in">get</span>(t4, d);</span><br><span class="line">        V t5 = <span class="built_in">tplus</span>(<span class="built_in">tmul</span>(t1, t2), <span class="built_in">tmul</span>(t3, t4));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %llu\n&quot;</span>, a, c, t5.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> prt = [](V&amp; v) &#123; <span class="built_in">For</span>(i, <span class="number">1</span>, v.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); &#125;;</span><br><span class="line">        <span class="built_in">prt</span>(t1), <span class="built_in">prt</span>(t3), <span class="built_in">prt</span>(t5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p><code>Special judge</code>：假设保存为 <code>checker.cpp</code>，编译后在命令行中使用：<code>checker &lt;input-file&gt; &lt;output-file&gt;</code>，答案正确返回值为 <span class="math inline">\(0\)</span>，否则返回值为 <span class="math inline">\(1\)</span>，输出为第一组出错的数据。</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) int((x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc o * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmi(a, b) (a = min(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cma(a, b) (a = max(a, b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ub upper_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs binary_search</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop __builtin_popcount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpop __builtin_popcountll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ctz __builtin_ctz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llctz __builtin_ctzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clz __builtin_clz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llclz __builtin_clzll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> par __builtin_parity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llpar __builtin_parityll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lf = <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> V = vector&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="comment">// using cmp = complex&lt;lf&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">1299709</span>;</span><br><span class="line"><span class="keyword">int</span> f[M + <span class="number">5</span>], pid, prm[N];</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">tmul</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>, su = n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? i : b[j] + su - <span class="number">1</span>);</span><br><span class="line">        su += m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">tplus</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>, m = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">2</span>, m) a.<span class="built_in">pb</span>(b[j] == <span class="number">1</span> ? <span class="number">1</span> : b[j] + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> V G[])</span> </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">re</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [h, sz] = <span class="built_in">dfs</span>(v, G);</span><br><span class="line">        re.fi = (re.fi + (ll)h * prm[sz]) % <span class="number">999999937</span>;</span><br><span class="line">        re.se += sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> V&amp; t)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">1</span>, t.<span class="built_in">size</span>()) G[t[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, G).fi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(FILE* f)</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">fscanf</span>(f, <span class="string">&quot;%d&quot;</span>, &amp;x) == <span class="number">1</span> ? x : <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, M) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) prm[++pid] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i * prm[j] &lt;= M; j++) &#123;</span><br><span class="line">            f[i * prm[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prm[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *in = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>), *out = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> T = <span class="built_in">read</span>(in); T--;) &#123;</span><br><span class="line">        V t1&#123;<span class="number">0</span>&#125;, t2&#123;<span class="number">0</span>&#125;, t3&#123;<span class="number">0</span>&#125;, t4&#123;<span class="number">0</span>&#125;, t5&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> get = [](FILE* f, V&amp; t, <span class="keyword">int</span> n) &#123; <span class="built_in">rep</span>(i, <span class="number">1</span>, n) t.<span class="built_in">pb</span>(<span class="built_in">read</span>(f)); &#125;;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">read</span>(in), b = <span class="built_in">read</span>(in), c = <span class="built_in">read</span>(in);</span><br><span class="line">        <span class="built_in">get</span>(in, t1, a), <span class="built_in">get</span>(in, t3, b), <span class="built_in">get</span>(in, t5, c);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="built_in">read</span>(out), e = <span class="built_in">read</span>(out);</span><br><span class="line">        <span class="keyword">auto</span> err = [&amp;]() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n%d %d %d\n&quot;</span>, a, b, c);</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t1[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, b) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t3[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, c) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t5[i]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!~d) <span class="built_in">err</span>();</span><br><span class="line">        <span class="built_in">get</span>(out, t2, d), <span class="built_in">get</span>(out, t4, e);</span><br><span class="line">        <span class="keyword">if</span>((ll)a * d + (ll)b * e != c &amp;&amp; <span class="built_in">Hash</span>(<span class="built_in">tplus</span>(<span class="built_in">tmul</span>(t1, t2), <span class="built_in">tmul</span>(t3, t4))) != <span class="built_in">Hash</span>(t5)) <span class="built_in">err</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="izho-2020-d1t3">IZhO 2020 D1T3</h3>
<blockquote>
<p><a href="codeforces.com/group/Uo1lq8ZyWf/contest/265564">题目链接</a></p>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span>，问有多少三元组 <span class="math inline">\((i,j,k)\)</span> 满足 <span class="math inline">\(i\le j&lt;k\)</span> 且 <span class="math inline">\([i,j]\)</span> 和 <span class="math inline">\([j+1,k]\)</span> 两个区间中数的集合相同。</p>
<p><span class="math inline">\(n \le 2\cdot 10^5\)</span></p>
</blockquote>
<p>记 <span class="math inline">\(prev_i\)</span> 表示 <span class="math inline">\(A_i\)</span> 上一次出现的位置，<span class="math inline">\(next_i\)</span> 表示 <span class="math inline">\(A_i\)</span> 下一次出现的位置。</p>
<p>三元组 <span class="math inline">\((i,j,k)\)</span> 合法的充要条件为：</p>
<ul>
<li>区间 <span class="math inline">\([j+1,k]\)</span> 中的数都在 <span class="math inline">\([i,j]\)</span> 中出现，即 <span class="math inline">\(i \le \min prev_{j+1\cdots i}\)</span>，相当于 <span class="math inline">\(i\)</span> 有个上界 <span class="math inline">\(R_{j,k}=\min prev_{j+1\cdots k}\)</span>。</li>
<li>区间 <span class="math inline">\([i,j]\)</span> 中的数都在 <span class="math inline">\([j+1,k]\)</span> 中出现，即 <span class="math inline">\(\max next_{i\cdots j}\le k\)</span>，相当于 <span class="math inline">\(i\)</span> 有个下界 <span class="math inline">\(L_{j,k}\)</span>，其中 <span class="math inline">\(L_{j,k}\)</span> 是最小的 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(\max next_{i\cdots j}\le k\)</span>。</li>
</ul>
<p>那么 <span class="math inline">\((j,k)\)</span> 的贡献就是 <span class="math inline">\(\max(R_{j,k}-L_{j,k}+1,0)\)</span>，考虑只枚举 <span class="math inline">\(k\)</span>，用数据结构动态维护 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span>。</p>
<p>先考虑 <span class="math inline">\(L_{j,k}\)</span> 和 <span class="math inline">\(R_{j,k}\)</span> 分别怎么维护。</p>
<p>对于 <span class="math inline">\(R_{j,k}=\min prev_{j+1\cdots k}\)</span>，这是 <span class="math inline">\(prev\)</span> 数组上的后缀 <span class="math inline">\(\min\)</span>，当 <span class="math inline">\(k\rightarrow k+1\)</span> 时，<span class="math inline">\(R_{j,k}\)</span> 发生的改变是一个后缀变成了 <span class="math inline">\(prev_{k+1}\)</span>，具体可以用单调栈求出这个后缀，然后区间赋值。</p>
<p>对于 <span class="math inline">\(L_{j,k}\)</span>，直接分析 <span class="math inline">\(k\rightarrow k+1\)</span> 不太行，换一个角度考虑对于一个 <span class="math inline">\(j\)</span>，<span class="math inline">\(L_{j,k}\)</span> 和 <span class="math inline">\(k\)</span> 的关系，<span class="math inline">\(\max next_{i\cdots j}\)</span> 是 <span class="math inline">\(next\)</span> 数组上的后缀 <span class="math inline">\(\max\)</span>，将 <span class="math inline">\(next_{1\cdots j}\)</span> 依次插入单调栈，设单调栈中元素分别为 <span class="math inline">\(next_{i_1},next_{i_2},next_{i_3},\cdots,next_{i_k}\)</span>：</p>
<ul>
<li>当 <span class="math inline">\(k\in[j+1,next_{i_k}-1]\)</span> 时，<span class="math inline">\(L_{j,k}=\infty\)</span>。</li>
<li>当 <span class="math inline">\(k\in [next_{i_k},next_{i_{k-1}-1}]\)</span>，<span class="math inline">\(L_{j,k}=i_{k-1}+1\)</span>。</li>
<li><span class="math inline">\(\cdots\)</span></li>
<li>当 <span class="math inline">\(k\in [next_{i_1},n]\)</span>，<span class="math inline">\(L_{j,k}=1\)</span>。</li>
</ul>
<p>综上，单调栈元素 <span class="math inline">\(i_x\)</span> 意味着当 <span class="math inline">\(k\in [next_{i_x},next_{i_{x-1}}-1]\)</span>，<span class="math inline">\(L_{j,k}=i_{x-1}+1\)</span>，假设插入 <span class="math inline">\(next_y\)</span> 后 <span class="math inline">\(next_{i_x}\)</span> 被弹掉了，那么当 <span class="math inline">\(j\in [i_x,y-1],k\in [next_{i_x},next_{i_{x-1}}-1]\)</span> 时，<span class="math inline">\(L_{j,k}=i_{x-1}+1\)</span>，相当于 <span class="math inline">\(k\)</span> 从 <span class="math inline">\(next_{i_x}-1\rightarrow next_{i_x}\)</span> 时，对 <span class="math inline">\(L_{i_x\cdots y-1,k}\)</span> 进行区间赋值为 <span class="math inline">\(i_x+1\)</span>。每个单调栈元素意味着一次区间赋值，所以只需要 <span class="math inline">\(n\)</span> 次区间赋值就可以维护 <span class="math inline">\(L_{j,k}\)</span>。</p>
<p>但维护的是 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span>，相当于夹在两条递增折线之间的面积。由于 <span class="math inline">\(L_{j,k}\)</span> 和 <span class="math inline">\(R_{j,k}\)</span> 都是随着 <span class="math inline">\(k\)</span> 增大而减小的，所以每次赋值都是减小。比如将 <span class="math inline">\(R_{l\cdots r,k}\)</span> 改为 <span class="math inline">\(v\)</span>，如果 <span class="math inline">\(v \le \min L_{l\cdots r,k}\)</span>，这一段的面积就是 <span class="math inline">\(0\)</span>，如果 <span class="math inline">\(v \ge \max L_{l\cdots r,k}\)</span>，这一段的面积就是 <span class="math inline">\(\sum_{j=l}^rR_{j,k}-\sum_{j=l}^rL_{j,k}+(r-l+1)\)</span>，否则可以二分一个分界点 <span class="math inline">\(x\)</span>，使得 <span class="math inline">\(\forall j \in[l,x], v\ge L_{j,k},\forall j\in[x+1,r],v\le L_{j,k}\)</span>，分界点左右两段分别对应上述两种情况。所以只要维护了 <span class="math inline">\(L_{j,k},R_{j,k}\)</span> 的区间 <span class="math inline">\(\min,\max\)</span> 和 <span class="math inline">\(sum\)</span> 就可以维护 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span> 了。</p>
<p>在实现上并不需要求 <span class="math inline">\(x\)</span>，假设当前要将 <span class="math inline">\(L_{ql\cdots qr,k}\)</span> 赋值为 <span class="math inline">\(v\)</span>，当前线段树结点区间为 <span class="math inline">\([l,r]\)</span>，一般区间赋值是在 <span class="math inline">\(ql\le l\land r \le qr\)</span> 时停止递归，这里把条件改成 <span class="math inline">\(ql\le l\land r \le qr \land (v \le \min L_{l\cdots r,k}\lor v \ge \max L_{l\cdots r,k})\)</span> 才可以方便地维护 <span class="math inline">\(\sum_{j=1}^{k-1}\max(R_{j,k}-L_{j,k}+1,0)\)</span>，由于只有一个分界点，所以复杂度不变。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>，实现难度较大，附上代码：</p>
<details>
<summary>
<span style="font-size: large; font-weight: bold; color: rgb(33,150,243);">查看代码</span>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = (l); i &lt;= (r); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(int i = (r); i &gt;= (l); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, l, r) for(int i = (l), i##e = (r); i &lt; i##e; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc o * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc o * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch l, mid, lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch mid + 1, r, rc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], pre[N], nxt[N], L[N];</span><br><span class="line">vector&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vl[N], vr[N];</span><br><span class="line"><span class="keyword">int</span> tagL[N * <span class="number">4</span>], minL[N * <span class="number">4</span>], maxL[N * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> tagR[N * <span class="number">4</span>], minR[N * <span class="number">4</span>], maxR[N * <span class="number">4</span>];</span><br><span class="line">ll sum[N * <span class="number">4</span>], sumL[N * <span class="number">4</span>], sumR[N * <span class="number">4</span>], as;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    sum[o] = sum[lc] + sum[rc];</span><br><span class="line">    sumL[o] = sumL[lc] + sumL[rc];</span><br><span class="line">    sumR[o] = sumR[lc] + sumR[rc];</span><br><span class="line">    minL[o] = <span class="built_in">min</span>(minL[lc], minL[rc]);</span><br><span class="line">    minR[o] = <span class="built_in">min</span>(minR[lc], minR[rc]);</span><br><span class="line">    maxL[o] = <span class="built_in">max</span>(maxL[lc], maxL[rc]);</span><br><span class="line">    maxR[o] = <span class="built_in">max</span>(maxR[lc], maxR[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushL</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    tagL[o] = minL[o] = maxL[o] = v, sumL[o] = v * (r - l + <span class="number">1ll</span>);</span><br><span class="line">    sum[o] = <span class="built_in">max</span>(sumR[o] - sumL[o], <span class="number">0ll</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushR</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    tagR[o] = minR[o] = maxR[o] = v, sumR[o] = v * (r - l + <span class="number">1ll</span>);</span><br><span class="line">    sum[o] = <span class="built_in">max</span>(sumR[o] - sumL[o], <span class="number">0ll</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~tagL[o]) <span class="built_in">pushL</span>(tagL[o], lch), <span class="built_in">pushL</span>(tagL[o], rch), tagL[o] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(~tagR[o]) <span class="built_in">pushR</span>(tagR[o], lch), <span class="built_in">pushR</span>(tagR[o], rch), tagR[o] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updL</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; (v &lt;= minR[o] || v &gt;= maxR[o])) <span class="keyword">return</span> <span class="built_in">pushL</span>(v, l, r, o);</span><br><span class="line">    <span class="built_in">pushDown</span>(l, r, o);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">updL</span>(L, R, v, lch);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">updL</span>(L, R, v, rch);</span><br><span class="line">    <span class="built_in">pushUp</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updR</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; (v &gt;= maxL[o] || v &lt;= minL[o])) <span class="keyword">return</span> <span class="built_in">pushR</span>(v, l, r, o);</span><br><span class="line">    <span class="built_in">pushDown</span>(l, r, o);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">updR</span>(L, R, v, lch);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">updR</span>(L, R, v, rch);</span><br><span class="line">    <span class="built_in">pushUp</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) L[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) pre[i] = L[a[i]], L[a[i]] = i;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) L[i] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">per</span>(i, n, <span class="number">1</span>) nxt[i] = L[a[i]], L[a[i]] = i;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; j = L[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &amp;&amp; pre[j] &gt;= pre[i]; j = L[j]);</span><br><span class="line">        vr[i].<span class="built_in">eb</span>(<span class="built_in">max</span>(j, <span class="number">1</span>), i - <span class="number">1</span>, pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; j = L[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &amp;&amp; nxt[j] &lt;= nxt[i]; j = L[j])</span><br><span class="line">            vl[nxt[j]].<span class="built_in">eb</span>(<span class="built_in">max</span>(j, <span class="number">1</span>), i - <span class="number">1</span>, L[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mem</span>(tagL, <span class="number">63</span>), <span class="built_in">mem</span>(tagR, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [l, r, v] : vl[i]) <span class="built_in">updL</span>(l, r, v, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [l, r, v] : vr[i]) <span class="built_in">updR</span>(l, r, v, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        as += sum[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; as;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="cf566c">CF566C</h3>
<blockquote>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的带权树，每个点住了 <span class="math inline">\(w_i\)</span> 个人，一个人从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的花费为距离的 <span class="math inline">\(1.5\)</span> 次方。</p>
<p>定义 <span class="math inline">\(f(u)\)</span> 表示所有人到点 <span class="math inline">\(u\)</span> 的总花费，求 <span class="math inline">\(f(u)\)</span> 最小的点。</p>
<p><span class="math inline">\(n \le 2\cdot 10^5\)</span></p>
</blockquote>
<p>首先研究 <span class="math inline">\(f(u)\)</span> 有什么性质，假设花费等于距离的话 <span class="math inline">\(f(u)\)</span> 就是单峰的，因此猜想 <span class="math inline">\(f(u)\)</span> 是单蜂的。</p>
<p>证明：由于 <span class="math inline">\(w_v\text{dis}^{1.5}_v(u)\)</span> 是下凸函数，所以它们加起来也是下凸函数。</p>
<p>回忆实数上的单蜂函数是怎么求最值的：当前确定最优点在 <span class="math inline">\([l,r]\)</span> 中，在 <span class="math inline">\(\frac {l+r}2\)</span> 处求导来确定最远点在 <span class="math inline">\(\frac {l+r}2\)</span> 左边还是右边，然后将范围减半。</p>
<p>考虑怎么在树上实现这个过程：求出整棵树的重心，通过确定最优解在重心的哪个子树来将范围减半。</p>
<p>怎么确定最优解在哪棵子树？把 <span class="math inline">\(f(u)\)</span> 的定义域扩大，<span class="math inline">\(u\)</span> 可以是一条边上的位置。求出重心向各个方向的导数，由于 <span class="math inline">\(f(u)\)</span> 单峰，所以最多有一个导数小于 <span class="math inline">\(0\)</span>，这是最优解的方向。假设最优解的方向沿着边 <span class="math inline">\((u,v)\)</span>，由于 <span class="math inline">\(f(u)\)</span> 的最优点可能在 <span class="math inline">\((u,v)\)</span> 上，所以 <span class="math inline">\(v\)</span> 不一定比 <span class="math inline">\(u\)</span> 优，应该把经过的所有点取个最小值作为答案。</p>
<p>根 <span class="math inline">\(u\)</span> 向儿子 <span class="math inline">\(v\)</span> 方向的导数为： <span class="math display">\[
\frac 32\left(\sum_{i=1}^nw_i\sqrt{\text{dis}(i,u)}-2\sum_{i\in \text{subree}(v)}w_i\sqrt{\text{dis}(i,u)}\right)
\]</span> 可以 <span class="math inline">\(O(n)\)</span> 求出 <span class="math inline">\(u\)</span> 向每个儿子的导数，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/problem4/" rel="prev" title="一道题 4">
                  <i class="fa fa-chevron-left"></i> 一道题 4
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="SOHUCS"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">platelet</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">190k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:53</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cyvEvVbLv","appkey":"5ad530a5ec52a4592621eb7b7437748c"}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
